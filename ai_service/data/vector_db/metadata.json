{
  "contents": [
    "《信号处理基础》\nFundamentals of Signal Processing\n胡峻林\n北京航空航天大学软件学院\nhujunlin@buaa.edu.cn",
    "课程基本信息\n课程性质：选修\n学 分：2\n学 时：32 （ 理论课时，无实验课时）\n先修课程：《工科数学分析》\n教 材（ 无需购买）：\n《信号与系统》第三版，郑君里主编，高等教育出版社，2011.3\n课程简介：《信号处理基础》是信息类本科专业迫切需要学习的一门专业课，旨在使学生掌握信号处理的基\n本概念、基本理论和基本分析方法。本课程主要讲述信号与系统的基本概念、连续时间系统的时域分析和频\n域分析方法、离散时间系统的时域分析和变换域分析方法等。通过本课程的学习，建立信号与系统的频域分\n析以及系统函数的概念，为从事信号处理、系统软件开发等方面的研究工作奠定坚实的理论基础。",
    "学习目标\n通过学习本课程，\n◼ 掌握信号的时域、频域、复频域分析方法，做到数学概念、物理概念与工程概\n念的统一，具备信号与系统的分析能力，具有信息获取与处理能力；\n◼ 理解信号的时域、频域、变换域特性，复杂工程问题通过线性时不变系统的时\n域、频域、复频域分析的相互关联和制约因素；\n◼ 能够运用多种方法得到系统的响应，对系统从时域、频域、复频域分析得出有\n效的结论，能根据已知的系统结构图、微分方程或差分方程、转移函数等得到\n系统的输出方程；\n◼ 能够识别和判断系统的性质，对复杂工程问题运用系统函数、零极点分布的规\n律等给出相应的参数和有效分析。",
    "主要内容\n◼ 信号与系统基本概念\n◼ 连续时间系统的时域分析\n◼ 连续信号的频域分析\n◼ 连续时间系统的复频域分析\n◼ 离散时间系统的时域分析\n◼ 离散信号的变换域分析",
    "课程主线\n信号 f(t) F () F(s) F(z)\n系统 H(s) H(z)\nh(t)\n响应 y(t) Y(s) Y(z)\n绪论 时域 频域 复频域 z 域\nH\nY (\n(\n\n\n)\n)\n连 续 时 间 系 统\n离 散 时 间 系 统",
    "课程考核\n◼ 平时成绩 10% （课堂参与情况）\n◼ 平时作业 40% （ 4 次课后作业）\n◼ 期末考试 50% （开卷考试， 限携带一页手写A4纸）\n该课程无补考环节",
    "《信号处理基础》\n第1章：信号与系统基本概念",
    "提纲\n1.1 信号的定义与分类\n1.2 典型连续信号及其时域特性\n1.3 信号的时域变换\n1.4 信号的时域运算\n1.5 奇异信号\n1.6 系统的定义与描述\n1.7 系统的性质与分类",
    "1.1 信号的定义与分类\n1.1.1 信号的定义\n• 信号的定义以及信号与信息的关系\n信号是指信息的表现形式与传送载体，而信息则是信号的具体内容。\n• 信号与函数的关系\n信号可以是时间的一元或多元函数，可以是变换域中变量的函数。\n在讨论信号的有关问题时，“信号”与“函数”两个词常互相通用。",
    "1.1.2 信号的分类\n根据信号的特点，常常将信号分为：\n• 连续时间信号与离散时间信号\n• 周期信号与非周期信号\n• 确定信号与随机信号\n• 能量信号与功率信号",
    "1. 连续时间信号与离散时间信号\n连续时间信号是指在信号的定义域内，除有限个间断点外，任意时刻\nf (t)\n都有确定函数值的信号，通常用 来表示。\n\n数学表达式\n定义域（-∞，∞）\n值域[-5，5]都是连续的\nf\n1\n( t ) = 5 s i n ( t )",
    "数学表达式为\n单位阶跃信号，数学表达式为\n定义域（-∞，∞）是连续的，但信号的值只取0\n或1。信号在 t = 0 处有间断点 。\nf\nu\n2\n(\n(\nt\nt\n)\n)\n=\n=\n\n\n0\n1\n−\n0\n1\n0\n1\nt\nt\n\n\n−\n1\n0\n0\nt\n1\n\nt\n\n\nt\n\n−\nt\n\n3\n1\n\n3\n1",
    "离散时间信号是指信号的定义域为一些离散时刻，通常用 来表示。\n离散时间信号最明显的特点是其定义域为离散的时刻，而在这些离散\n时刻之外无定义。\n正弦序列\n\nf\n1\n( n ) = A s i n (\n4\nn )\nf ( n )",
    "数学表达式为\n单位阶跃序列，数学表达式为\n1\nn  0\nu(n) =\n\n0 n  0\n\nf\n2\n( n ) =\n\n−\n2\n1\n0\n1\nn =\n其\nn\nn\n−\n=\n它\n=\n1 ,\n1\n2\n0\nn\n, 3",
    "2. 周期信号与非周期信号\n周期信号是定义在（-∞，∞）区间，每隔一定时间T（或整数N），\n按相同规律重复变化的信号。\n连续周期信号\nf (n) = f (n + mN ), m = 0, 北1, 2,L\n离散周期信号\n非周期信号是不具有重复性的信号。\nf ( t ) = f ( t + m T ) , m = 0 ,  1 ,  2 , ",
    "3. 确定信号与随机信号\n根据时间函数的确定性划分，信号可以分为确定信号与随机信号。\n• 确定信号是指能够以确定的时间函数表示的信号。\n• 随机信号也称为不确定信号，它不是时间的函数。也就是说，在\n其定义域内的任意时刻没有确定的函数值。如马路上的噪声，电\n网电压（有效值）波动量的大小等。\n本课程着重讨论确定时间信号，随机信号的分析将在数字信号处理\n等后续课程中研究 。",
    "4. 能量信号与功率信号\n根据时间信号的可积性划分，信号可以分为能量信号与功率信号。\n连续时间信号归一化能量\n连续时间信号归一化功率\n离散时间信号归一化能量\n1\nP = lim N f (n) 2\n离散时间信号归一化功率\n\nN→ 2N + 1 n=−N\nE\nP\nE\n=\n=\n=\nl\nl\nl\ni\nT\ni\nT\nm→\nm→\ni\nN\n\n\nm→\n\n\n2\nT\n− T\n1\nn\nT\n=\nN\n−\nf\nN\n\n(\nT\n−\nf\nT\nt\n(\n)\nf\nn\n2\n(\nd\n)\nt\nt\n)\n2\n2 d t",
    "能量信号：若信号的归一化能量为非零的有限值，且其归一化功率\n为零，则该信号为能量信号。\n功率信号：若信号的归一化能量为无限值，且其归一化功率为非零\n的有限值，则该信号为功率信号。直流信号与周期信号都是功率信\n号。\n需要注意的情况：一个信号不可能既是能量信号又是功率信号，但\n却有少数信号既不是能量信号也不是功率信号。如单位斜变信号，\n既不是能量信号也不是功率信号。",
    "提纲\n1.1 信号的定义与分类\n1.2 典型连续信号及其时域特性\n1.3 信号的时域变换\n1.4 信号的时域运算\n1.5 奇异信号\n1.6 系统的定义与描述\n1.7 系统的性质与分类",
    "1.2 典型连续信号及其时域特性\n1.2.1 直流信号\n1.2.2 正弦信号\n1.2.3 指数信号\n1.2.4 复指数信号\n1.2.5 抽样信号",
    "1.2.1 直流信号\n直流信号的数学表达式为\n式中 A 为实数，其定义域为（-∞，∞），波形如图所示。\n若A=1，则称之为单位直流信号。\nf ( t ) = A",
    "1.2.2 正弦信号\n \n正弦信号的数学表达式为\n正弦信号的性质：\n⑴是无时限信号。\n\n⑵是周期信号，其周期为\n\n⑶其微分仍然是正弦信号。\n\n⑷满足如下形式的二阶微分方程，即：\nT\nf (\n=\nt )\n2\n= A c\nf\no\n\"\ns\n(\n(\nt )\nt\n+\n+\n2\n)\nf ( t ) = 0",
    "1.2.3 指数信号\nt\nf (t) = Ae\n指数信号数学表达式\n系数A是指数信号的初始值，\n在A为正实数时，\n\n若 ，则指数信号的幅度随\n时间增长而增长；\n\n若 ，指数信号的幅度随时\n间增长而衰减。\n = 0\n在 时，信号不随时间而变\n化，成为直流信号。\n\n 0\n0",
    " t  0, 0\n单边指数衰减信号\nt  0\n单边指数衰减信号的性质：\n⑴ ， ，即在\n时刻有跳变，跳变的幅度为A。\n⑵经过  的时间，函数值从A 衰\n减到0.368A。 称为衰减系数。\n⑶单边指数衰减信号对时间的微分和积分仍是指数形式。\nf ( 0\n−\n1\n)\n/\n= 0 f ( 0\n+\n) = A\nf ( t ) =\n A\nt\ne\n0\n−\n=\nt\n0",
    "1.2.4 复指数信号\n复指数信号的数学表达式\n由欧拉公式展开可得\n   \n \n此式表明，一个复指数信号可以分解为实部、虚部两部分。\n实部、虚部分别为幅度按指数规律变化的正弦信号。\nA e\ns t\n= A e\n( + j\n0\n) t\n= A\nf\ne\n( t\nt\n)\nc\n=\no s\nA\n(\ne\n0\ns t\nt ) + j A e\nt\ns i n (\n0\nt )",
    "需要指出的是：复指数信号在物理上是不可实现的，但是它概括了\n多种情况。\n利用复指数信号可以表示常见的普通信号，如直流信号、指数信号、\n正弦信号等。\n复指数信号的微分和积分仍然是复指数信号，利用复指数信号可以\n使许多运算和分析简化。\n因此，复指数信号是信号分析中非常重要的基本信号。",
    "1.2.5 抽样信号\nsin t\n抽样信号的数学表达式为 Sa(t) =\nt\n抽样信号的性质\n⑴ 为实变量 t的偶函数，即有\n⑵\nt = k(k = 1,2,)\n⑶ 当 时，\n\n⑷\nlim Sa(t) = 0\n⑸\nt→\nl\n\ni mt\n→\n\n− \n0\nS a\nS a\n( t\n(\n)\nt\nd\n)\nt\n=\n=\nS a\n\n\n− \n(\ns\n0\ni\n)\nn\nt\n=\nt\nd\nl i\nt\nt\nm→\n0\n=\nS\ns\na\ni\n(\nn\nt\nS\nt\na\n)\nt\n(\n=\n=\nt )\nS\n1\n=\na (\n0\n− t )",
    "提纲\n1.1 信号的定义与分类\n1.2 典型连续信号及其时域特性\n1.3 信号的时域变换\n1.4 信号的时域运算\n1.5 奇异信号\n1.6 系统的定义与描述\n1.7 系统的性质与分类",
    "1.3 信号的时域变换\n1.3.1 反折\n1.3.2 时移\n1.3.3 尺度\n1.3.4 倒相",
    "1.3.1 反折\n信号的时域反折，就是将信号的波形以纵轴为轴翻转180度。\n将 以纵轴为轴对折，即得反折信号 。\n若要求得 的反折信号 ，则必须将 中的 换为 - ，\nt\n同时将 定义域中的 也必须换为 - 。\nf ( t )\nf (\nf\nt\n() t )\nf ( −\n\nt )\nf\nt\n( − t\nf\n)\n( t )\nt t",
    "1.3.2 时移\n信号的时移（也称平移），就是将信号的波形沿时间轴左、右平行移\n动，但波形的形状不变。\nt\n将 沿 轴平移 ，即\n\n0\n得 ， 为实数。\nt\n当 时，信号沿 轴\n正方向移动（右移）；\n\nt  0\n当 时，信号沿 轴\n0\n负方向移动（左移）。\nf\nf\nt\n(\n(\n0\nt\nt\n\n)\n−\n0\nt\n0\nt\n) t\n0\nt",
    "信号的时移变换用时移器（延时器）实现\n延时器\n预测器\n当 时，延时器为因果系统，是可以用硬件实现的；\n当 t  0 时，延时器是非因果系统，此时的延时器变成为预测器。\n0\n延时器和预测器都是信号处理中常见的系统。\nt\n0\n 0\nf\nf\n(\n(\nt\nt\n)\n)\ny\ny\n(\n(\nt\nt\n)\n)\n=\n=\nf\nf\n(\n(\nt\nt\n−\n+\nt\nt\n0\n0\n)\n)",
    "1.3.3 尺度\n信号的尺度变换，就\n是将信号 变化\n到 ，\n即 信号在时间\n轴上的扩展或压缩，\n但纵轴上的值不变。\nf\nf\n(\n(\na\nt )\nt ) (\nf\na\n( t\n\n)\n0 )\n\n",
    "若 f ( t ) 是已录在磁带上的声音信号，则:\n可看作将磁带倒转播放产生的信号;\n是磁带以二倍速度加快播放的信号;\n表示磁带放音速度降至一半的信号。\nf\nf\nf\n(\n(\n(\n2\n−\n1\n2\nt\nt\nt\n)\n)\n)",
    "1.3.4 倒相\n信号的倒相（也称反相），就是将信号 f ( t ) 的波形以横轴为轴翻转\n180度\n将 以横轴为轴对折，即得倒相信\n号 。信号进行倒相时，横轴上\n的值不变，仅是纵轴上的值改变了正负\n号，正值变成了负值，负值变成了正值。\n信号的倒相用倒相器实现\nf (t) 倒相器 y(t) = − f (t)\n−\nf ( t\nf\n)\n( t )\n",
    "提纲\n1.1 信号的定义与分类\n1.2 典型连续信号及其时域特性\n1.3 信号的时域变换\n1.4 信号的时域运算\n1.5 奇异信号\n1.6 系统的定义与描述\n1.7 系统的性质与分类",
    "1.4 信号的时域运算\n1.4.1 相加\n1.4.2 相乘\n1.4.3 数乘\n1.4.4 微分\n1.4.5 积分",
    "1.4.1 相加\n信号的相加是指若干个信号之和，其数学表达式为\n信号在时域相加运算用加法器实现\n信号在时域中相加时，横轴(t轴)的值不变，仅是与t轴的值对应的纵坐标值相加。\ny ( t ) = f\n1\n( t ) + f\n2\n( t ) +  + f\nn\n( t ) n = 1 , 2 , ",
    "1.4.2 相乘\n信号的相乘是指若干个信号之积。信号在时域相乘运算用乘法器（调\n制器）实现 。信号处理系统中的抽样器和调制器，都是实现信号相\n乘运算功能的系统。\n信号在时域中相乘时，横轴(t轴)的值不变，仅是与t轴的值对应的纵坐标值相乘。",
    "1.4.3 数乘\n信号的数乘是指信号 f ( t ) 乘以常数 a 的运算，其数学表达式为\ny(t) = af (t)\n信号的时域数乘运算用数乘器实现，也称比例器或标量乘法器。\na\n信号的时域数乘运算，实质上就是在对应的横坐标值上将纵坐标的值扩大倍a\n（a>1时为扩大：0<a<1时为缩小）。\nf ( t ) y ( t ) = a f ( t )",
    "1.4.4 微分\n信号的微分是指信号对时间的导数，其数学表达式为\ndf (t)\ny(t) = = f (t)\ndt\n信号的时域微分运算用微分器实现\n需要注意的是，当 f ( t ) 中含有间断点时。则 在间断点上将有\n冲激函数存在，其冲激强度为间断点处函数 f ( t ) 跳变的幅度值。\nf ( t )\ny ( t ) =\nd f\nd\n(\nt\nt )\n=\nf \nf\n(\n\nt\n( t\n)\n)",
    "1.4.5 积分\n(−, t )\n信号的积分是指信号在区间 上的积分，其数学表达式为\n \n信号的时域积分运算用积分器实现\n  f ( t )\ny ( t ) =\n\n\nt\n− \nf ( ) d\ny ( t ) = \n−\nt\n\nf ( ) d",
    "提纲\n1.1 信号的定义与分类\n1.2 典型连续信号及其时域特性\n1.3 信号的时域变换\n1.4 信号的时域运算\n1.5 奇异信号\n1.6 系统的定义与描述\n1.7 系统的性质与分类",
    "1.5 奇异信号\n奇异信号（奇异函数）是一类特殊的连续时间信号，其函数本身有\n不连续点（跳变点），或其函数的导数与积分有不连续点。\n它们是从实际信号抽象出来的理想化的信号，在信号与系统分析中\n占有重要的地位。\n1.5.1 单位斜变信号\n1.5.2 单位阶跃信号\n1.5.3 单位门信号\n1.5.4 单位冲激信号\n1.5.5 单位冲激偶信号\n1.5.6 符号信号",
    "1.5.1 单位斜变信号\nr(t)\n单位斜变信号用 表示，其数学表达式为\nt  0\nt  0\n单位斜变信号 有延时的单位斜变信号\nr ( t ) =\n\nt\n0\nr ( t − t\n0\n) =\n t −\n0\nt\n0\nt\nt\n\n\nt\nt\n0\n0",
    "1.5.2 单位阶跃信号\nu(t)\n单位阶跃信号用 表示，其数学表达式为\n单位阶跃信号 有延时的单位阶跃信号\nu ( t ) =\n\n1\n0\nt\nt\n\n\n0\n0\nu ( t − t\n0\n) =\n\n1\n0\nt\nt\n\n\nt\nt\n0\n0",
    "单位阶跃信号的性质1\nu(t) 单位阶跃信号 具有使任意非因果信号 变为因果信号的功\n能（即单边性），即将 f ( t ) 乘以 ，所得 f ( t ) u (t) 即成为\n因果信号。\n=\n×\n阶跃信号的单边性\nu ( t )\nf ( t )",
    "单位阶跃信号的性质2\n利用阶跃信号与延迟阶跃信号，将任意的矩形脉冲信号表示为\nG(t) = u(t) − u(t − t )\n0\n+ =\n矩形脉冲与阶跃信号的关系",
    "单位阶跃信号的性质3\n阶跃信号与斜变信号之间的关系为\nd r\nd\n(\nt\nt )\n= u ( t )",
    "1.5.3 单位门信号\n\n单位门信号是指门宽为 、门高为1的信号，常用符号 G ( t ) 表示，\n\n其数学表达式为\n \n \n \n\n\n-\n=\n单位门信号\nG ( t ) =\n 1\n0\nt\n−\n\n2\n2\n\n, t\nt\n\n\n−\n2\n2\nG ( t ) = u ( t +\n2\n) − u ( t −\n2\n)",
    "1.5.4 单位冲激信号\n1. 单位冲激信号的定义\n定义方法1（狄拉克 定义）：\n +\n  (t)dt = 1\n\n−\n(t) = 0,t  0\n\n +\n  (t − t )dt = 1\n 0\n−\n(t − t ) = 0,t  t\n\n0 0",
    "定义方法2（从某些函数的极限来定义）：\n1\n\n单位冲激信号可理解为门宽为 、门高为 的\n\n门信号在  → 0 时的极限，即\nt = 0\n\nt  0 \n且\n\n \n\n−\n+\n\n(\n\nt )\n( t\n=\n) d\nl\nt\ni m→\n=\n0\n\nf\n+\n− \n\n(\nl\nt\ni\n→\n)\nm\n0\n=\nf\n\n( t\n\n0\n) d t = l i\n→\nm\n0\n\n−\n+\n\n\nf ( t ) d t = 1",
    "1\n单位冲激信号也可理解为宽为 △ 、高为 的矩形脉冲在保持矩形\n\n脉冲的面积为1，而使脉宽 △ 趋于零时，脉高 必为无穷大，此时\n的极限即为冲激信号，即\n1  \n(t) = lim [u(t + ) − u(t − )]\n 2 2\n→0\n1\n",
    "2. 单位冲激信号的性质\n⑴ 筛选特性\nt = t\n如果信号 是一个在 处连续的普通函数，则有\n0\n \n推广：如果信号 是一个在 处连续的普通函数，则有\n \n⑵ 抽样特性\n如果信号 是一个在 处连续的普通函数，则有\n\n推广：如果信号 是一个在 处连续的普通函数，则有\n+\n f (t)(t)dt = f (0)\n−\nf\nf\n(\n(\nt\nt\n)\n)\nf\nf\nf\nf\n\n(\n(\n−\nt\n(\nt\n+ \n\n(\nt\nt\n)\n)\n)\nf\n)\n( t\n(\n)\n(\nt\nt\nt\n(\n−\n)\nt\n=\n−\nt\n=\nt\n0\nt\n0\n)\n)\n0\nd\nt\nf\n=\nt\nt\n=\n=\n(\n=\n0\nf\n0\nf\n0\n)\n(\n(\nt\nt\n0\n0\n)\n)\n( t )\n( t − t\n0\n)",
    "⑶ 奇偶特性： ( t ) 为偶函数，即 (t) = (−t)\n  \n推广：\n1\n⑷ 尺度特性：\n(at) = (t)(a  0)\na\n推广：\nt 1 t\n① (at − t ) = [a(t − )] = (t − )\n0 0\n0 a a a\n1\n\n②\n f (t)(at)dt = f (0)\n− a\n1 t\n③ +\n f (t)(at − t )dt = f ( 0 )\n0\n− a a\n( t − t\n0\n) = [ − ( t − t\n0\n) ] = ( t\n0\n− t )",
    "（5） ( t ) 与 u ( t ) 的关系\n\n与 互为微分与积分的关系，即\nt\nu(t) =  ()d \n−\n推广：\n \n①\n② \n( t ) u ( t )\nu\n(\n(\nt\nt\n−\n−\nt\nt\n0\n0\n)\n)\n=\n=\nd\n\nu\n−\nt\n(\n\nt\nd\n−\nt\n(\nt\n0\n)\n(\n−\nt )\nt\n=\n0\n)\nd\nd\nu\nd\n(\nt\nt )",
    "1.5.5 单位冲激偶信号\n1. 单位冲激偶信号的定义\n单位冲激信号  ( t ) 的时间导数即为单位冲激偶信号，用  表\n示。即：\nd(t)\n(t) =\ndt\n→\n→\n冲激偶信号的极限模型\n ( t )",
    "2. 冲激偶信号的性质\n⑴ 筛选特性\n  \n⑵ 抽样特性\n\n⑶ 尺度特性\n \n⑷ 奇偶特性\n(−t) = −(t)\n\nf\n−\n+\n\n\n( t\nf\n)\n( t )\n\n\n(\n(\n\na\n(\nt\nt\nt\n−\n−\n)\nt\nt\n0\n=\n0\n)\n)\nd\na\nt\n=\n1\n=\na\n−\n− f\nf\n\n\n(\n\n(\n(\nt\nt\nt\n0\n)\n0\n)\n(\n)\na \n( t\n0\n−\n)\nt\n0\n) + f ( t\n0\n)  ( t − t\n0\n)",
    "⑸ 冲激偶信号与冲激信号的关系\nd(t)\n    (t) =\ndt\n推广：\n+\n①  f (t)(t)dt = − f (0)\n−\n\n (t)dt = 0\n②\n−\n③ (t − t ) = −(t − t)\n0 0\nf (t)(t) = − f (0)(t) + f (0)(t)\n④\n( t ) = \n−\nt\n\n ( ) d",
    "1.5.6 符号信号\n符号信号用 sgn(t) 表示，其函数定义式为\n或用阶跃信号表示为\n符号信号也称正负号信号。\ns\ns\ng\ng\nn\nn\n(\n(\nt\nt\n)\n)\n=\n= u\n\n−\n(\n1\nt\n1\n) − u\nt\nt\n(\n\n\n− t\n0\n0\n) = 2 u ( t ) − 1",
    "《学科前沿讲座》学期报告",
    "班号：   232115     学号：  23373125    姓名：   付宁远",
    "学术报告参与情况\n（建议每学期两次及以上，大二大三总计参与8次讲座，不封顶，可加行） | 学术报告参与情况\n（建议每学期两次及以上，大二大三总计参与8次讲座，不封顶，可加行）",
    "报告时间 | 报告主题",
    "5.28 | 安全操作系统设计方法简介",
    "学习总结：围绕某期报告或多期报告，总结所学所感，鼓励有自学、有拓展，字数不少于500字。\n黄辰林博士作为国防科技大学计算机学院研究员、国家科技进步一等奖获得者，在操作系统安全领域拥有深厚的理论造诣与丰富的工程实践经验。其报告以“安全操作系统”为核心，系统梳理了其发展脉络，并前瞻性地指出智能与泛在计算时代下的新挑战，令人深受启发。\n报告的核心价值在于清晰地勾勒出安全操作系统的演进图景。黄博士并非停留于抽象理论，而是结合其主导研制的银河麒麟操作系统安全可信子系统、麒麟铠衣高可信系统等国家级重大工程实践，生动展现了安全理念如何在技术迭代中具象化：从早期主要依靠隔离与访问控制机制构建基础防护，到网络时代引入形式化验证、增强型访问控制模型（如BLP、Biba） 以应对更复杂威胁，再到当前云环境与万物互联背景下可信计算基（TCB）最小化、基于硬件的可信执行环境（TEE）、机密计算等成为关键。这种依托于实践的演进分析，使得抽象的安全设计理念变得具体可感。\n尤为深刻的是，报告精准揭示了当前智能计算与泛在计算场景为操作系统安全带来的颠覆性挑战。一方面，智能应用的动态性、数据驱动特性使得传统静态安全边界模糊，模型安全、训练数据隐私、对抗样本攻击等成为操作系统必须协同防御的新维度。另一方面，泛在计算中海量异构、资源受限的终端设备接入，极大扩展了攻击面，对操作系统的轻量化安全架构、细粒度动态信任管理、设备身份可靠认证提出了前所未有的高要求。黄博士指出，未来研究必须致力于解决这些矛盾：如何在保障高性能与低开销的同时，实现跨智能模型、泛在设备的内生安全与动态信任链构建？\n黄博士的报告不仅是一次知识的梳理，更是一场思想的动员。它深刻阐明：操作系统作为数字世界的基石，其安全性已从单纯的技术问题上升为关乎国家信息基础设施命脉的战略要务。在人工智能与物联网浪潮席卷全球的今天，唯有持续推动操作系统安全技术的自主创新与前瞻布局，方能在复杂严峻的网络安全态势中筑牢根基，护航数字中国的行稳致远。报告所点明的方向——融合智能特性的内生安全、面向泛在环境的动态可信——无疑是未来攻关的核心命题，对学术界与产业界均具有重要引领意义。 | 学习总结：围绕某期报告或多期报告，总结所学所感，鼓励有自学、有拓展，字数不少于500字。\n黄辰林博士作为国防科技大学计算机学院研究员、国家科技进步一等奖获得者，在操作系统安全领域拥有深厚的理论造诣与丰富的工程实践经验。其报告以“安全操作系统”为核心，系统梳理了其发展脉络，并前瞻性地指出智能与泛在计算时代下的新挑战，令人深受启发。\n报告的核心价值在于清晰地勾勒出安全操作系统的演进图景。黄博士并非停留于抽象理论，而是结合其主导研制的银河麒麟操作系统安全可信子系统、麒麟铠衣高可信系统等国家级重大工程实践，生动展现了安全理念如何在技术迭代中具象化：从早期主要依靠隔离与访问控制机制构建基础防护，到网络时代引入形式化验证、增强型访问控制模型（如BLP、Biba） 以应对更复杂威胁，再到当前云环境与万物互联背景下可信计算基（TCB）最小化、基于硬件的可信执行环境（TEE）、机密计算等成为关键。这种依托于实践的演进分析，使得抽象的安全设计理念变得具体可感。\n尤为深刻的是，报告精准揭示了当前智能计算与泛在计算场景为操作系统安全带来的颠覆性挑战。一方面，智能应用的动态性、数据驱动特性使得传统静态安全边界模糊，模型安全、训练数据隐私、对抗样本攻击等成为操作系统必须协同防御的新维度。另一方面，泛在计算中海量异构、资源受限的终端设备接入，极大扩展了攻击面，对操作系统的轻量化安全架构、细粒度动态信任管理、设备身份可靠认证提出了前所未有的高要求。黄博士指出，未来研究必须致力于解决这些矛盾：如何在保障高性能与低开销的同时，实现跨智能模型、泛在设备的内生安全与动态信任链构建？\n黄博士的报告不仅是一次知识的梳理，更是一场思想的动员。它深刻阐明：操作系统作为数字世界的基石，其安全性已从单纯的技术问题上升为关乎国家信息基础设施命脉的战略要务。在人工智能与物联网浪潮席卷全球的今天，唯有持续推动操作系统安全技术的自主创新与前瞻布局，方能在复杂严峻的网络安全态势中筑牢根基，护航数字中国的行稳致远。报告所点明的方向——融合智能特性的内生安全、面向泛在环境的动态可信——无疑是未来攻关的核心命题，对学术界与产业界均具有重要引领意义。",
    "学习照片：一张听报告照片/截图，本学期为课改试行学期，如无照片可不粘贴。从下学期起，需提供至少一张学习照片。 | 学习照片：一张听报告照片/截图，本学期为课改试行学期，如无照片可不粘贴。从下学期起，需提供至少一张学习照片。",
    "《学科前沿讲座》学期报告",
    "班号：   232115     学号：  23373125    姓名：   付宁远",
    "学术报告参与情况\n（建议每学期两次及以上，大二大三总计参与8次讲座，不封顶，可加行） | 学术报告参与情况\n（建议每学期两次及以上，大二大三总计参与8次讲座，不封顶，可加行）",
    "报告时间 | 报告主题",
    "5.28 | 安全操作系统设计方法简介",
    "学习总结：围绕某期报告或多期报告，总结所学所感，鼓励有自学、有拓展，字数不少于500字。\n黄辰林博士作为国防科技大学计算机学院研究员、国家科技进步一等奖获得者，在操作系统安全领域拥有深厚的理论造诣与丰富的工程实践经验。其报告以“安全操作系统”为核心，系统梳理了其发展脉络，并前瞻性地指出智能与泛在计算时代下的新挑战，令人深受启发。\n报告的核心价值在于清晰地勾勒出安全操作系统的演进图景。黄博士并非停留于抽象理论，而是结合其主导研制的银河麒麟操作系统安全可信子系统、麒麟铠衣高可信系统等国家级重大工程实践，生动展现了安全理念如何在技术迭代中具象化：从早期主要依靠隔离与访问控制机制构建基础防护，到网络时代引入形式化验证、增强型访问控制模型（如BLP、Biba） 以应对更复杂威胁，再到当前云环境与万物互联背景下可信计算基（TCB）最小化、基于硬件的可信执行环境（TEE）、机密计算等成为关键。这种依托于实践的演进分析，使得抽象的安全设计理念变得具体可感。\n尤为深刻的是，报告精准揭示了当前智能计算与泛在计算场景为操作系统安全带来的颠覆性挑战。一方面，智能应用的动态性、数据驱动特性使得传统静态安全边界模糊，模型安全、训练数据隐私、对抗样本攻击等成为操作系统必须协同防御的新维度。另一方面，泛在计算中海量异构、资源受限的终端设备接入，极大扩展了攻击面，对操作系统的轻量化安全架构、细粒度动态信任管理、设备身份可靠认证提出了前所未有的高要求。黄博士指出，未来研究必须致力于解决这些矛盾：如何在保障高性能与低开销的同时，实现跨智能模型、泛在设备的内生安全与动态信任链构建？\n黄博士的报告不仅是一次知识的梳理，更是一场思想的动员。它深刻阐明：操作系统作为数字世界的基石，其安全性已从单纯的技术问题上升为关乎国家信息基础设施命脉的战略要务。在人工智能与物联网浪潮席卷全球的今天，唯有持续推动操作系统安全技术的自主创新与前瞻布局，方能在复杂严峻的网络安全态势中筑牢根基，护航数字中国的行稳致远。报告所点明的方向——融合智能特性的内生安全、面向泛在环境的动态可信——无疑是未来攻关的核心命题，对学术界与产业界均具有重要引领意义。 | 学习总结：围绕某期报告或多期报告，总结所学所感，鼓励有自学、有拓展，字数不少于500字。\n黄辰林博士作为国防科技大学计算机学院研究员、国家科技进步一等奖获得者，在操作系统安全领域拥有深厚的理论造诣与丰富的工程实践经验。其报告以“安全操作系统”为核心，系统梳理了其发展脉络，并前瞻性地指出智能与泛在计算时代下的新挑战，令人深受启发。\n报告的核心价值在于清晰地勾勒出安全操作系统的演进图景。黄博士并非停留于抽象理论，而是结合其主导研制的银河麒麟操作系统安全可信子系统、麒麟铠衣高可信系统等国家级重大工程实践，生动展现了安全理念如何在技术迭代中具象化：从早期主要依靠隔离与访问控制机制构建基础防护，到网络时代引入形式化验证、增强型访问控制模型（如BLP、Biba） 以应对更复杂威胁，再到当前云环境与万物互联背景下可信计算基（TCB）最小化、基于硬件的可信执行环境（TEE）、机密计算等成为关键。这种依托于实践的演进分析，使得抽象的安全设计理念变得具体可感。\n尤为深刻的是，报告精准揭示了当前智能计算与泛在计算场景为操作系统安全带来的颠覆性挑战。一方面，智能应用的动态性、数据驱动特性使得传统静态安全边界模糊，模型安全、训练数据隐私、对抗样本攻击等成为操作系统必须协同防御的新维度。另一方面，泛在计算中海量异构、资源受限的终端设备接入，极大扩展了攻击面，对操作系统的轻量化安全架构、细粒度动态信任管理、设备身份可靠认证提出了前所未有的高要求。黄博士指出，未来研究必须致力于解决这些矛盾：如何在保障高性能与低开销的同时，实现跨智能模型、泛在设备的内生安全与动态信任链构建？\n黄博士的报告不仅是一次知识的梳理，更是一场思想的动员。它深刻阐明：操作系统作为数字世界的基石，其安全性已从单纯的技术问题上升为关乎国家信息基础设施命脉的战略要务。在人工智能与物联网浪潮席卷全球的今天，唯有持续推动操作系统安全技术的自主创新与前瞻布局，方能在复杂严峻的网络安全态势中筑牢根基，护航数字中国的行稳致远。报告所点明的方向——融合智能特性的内生安全、面向泛在环境的动态可信——无疑是未来攻关的核心命题，对学术界与产业界均具有重要引领意义。",
    "学习照片：一张听报告照片/截图，本学期为课改试行学期，如无照片可不粘贴。从下学期起，需提供至少一张学习照片。 | 学习照片：一张听报告照片/截图，本学期为课改试行学期，如无照片可不粘贴。从下学期起，需提供至少一张学习照片。",
    "数字经济时代个人信息安全的法律保护研究",
    "——基于网络游戏与虚拟主播行业的实证分析",
    "姓名：付宁远",
    "学号：23373125",
    "摘要",
    "数字经济时代来临，网络游戏、虚拟主播等数字时代的新产物受到全民热切追捧，个人信息安全保护问题也随之成为社会公众关注焦点。“虚拟主播开盒”“无限暖暖封禁事件”及《哈利波特：魔法觉醒》个人信息所有权之争等事件均以《网络安全法》[1]《个人信息保护法》[2]等法律制度为切入点，反映出现行法律制度不完善、数字时代人的权利保护无法适应时代发展需求、用户协议格式条款效力范围争议、虚拟财产法律属性不清、技术滥用责任认定不落地等问题，提出以政府监管为指引，平台责任为保障，用户赋权为救济，构建数字时代个人信息安全保护法律规范新路径，为我国个人信息安全保护立法路径提供理论参考。",
    "关键字：信息安全法；虚拟财产；用户协议；开盒攻击；个人信息保护",
    "数字权益保护的时代命题",
    "数字科技加速网络游戏、虚拟主播行业成为数字经济重要的一环。中国互联网络信息中心在第 52 次统计报告中显示，截至 2023 年 6 月，我国网民规模为 6.68 亿人，占网民整体的 62.3%，网络直播用户规模达 7.65 亿人，增长 8.2%。这是一张数字产业产值的账单，也是一张数字背后潜藏风险的账单，在数字经济与实体经济融合的发展背景下，用户的个人信息面临着前所未有的风险。",
    "网游行业中许多企业，都利用复杂的用户协议，片面规定数据处理规则。《王者荣耀》等游戏的用户协议[12]中写有“3年内未使用该游戏账号登录相应腾讯游戏，腾讯有权在提前通知的情况下，对该账号及其账号下的游戏数据及相关信息采取删除等处置措施”，而且协议还非常不通俗易懂，术语满满，玩家都只是勾选同意，并不会仔细看，这样一来，数据控制权都集中在企业手里。",
    "中国消费者协会曾在2023年做过一个调查，其中有89.6%的玩家从未仔细阅读过用户协议，且72%的用户协议中都有关于企业单方面收集、使用、处理的权利的描述。不对等的权利，导致玩家虚拟财产的保护只能寄希望于企业的自觉，而不能寄希望于法律对企业行为的制约。",
    "虚拟主播产业的火爆滋生了滥用技术“开盒”风险。以生成对抗网络（Generative Adversarial Networks，GAN）为代表的人工智能合成技术的泛滥在赋予虚拟主播高还原性的同时，也为“开盒”提供了技术支持。2023年1-6月，公安机关共查办“开盒”案件2300余起，比去年同期增长2.4倍。不法分子利用技术抓取个人生物识别信息，利用人工智能伪装身份，甚至通过暗网进行“开盒”售卖获利。一个犯罪团伙利用直播平台的技术安全漏洞采集10万条人脸数据，借助人工智能技术合成虚拟主播，将其伪装后以“定制专属女朋友”的形式在境外社交平台售卖，非法牟利。技术滥用带来个人隐私信息与网络身份安全风险。",
    "虚拟财产纠纷高发，法律滞后。2023年，玩家在《哈利波特：魔法觉醒》的虚拟财产案就是因该公司认为其“钻了空子”且获取了相应利润，强制没收了20万元游戏道具的虚拟道具。在该案中，企业行为是否违法，财产是否被没收，玩家并不能有效证明操作行为的正当性，对虚拟财产的价值也缺乏有效的衡量标准。该案的虚拟财产属性缺乏法律定论，电子证据证明缺乏规则。",
    "北京互联网法院在近日公布的2023年《涉游戏案件审判白皮书》[14]中提到，近三年来，60%以上的涉虚拟财产纠纷因证据不足、价值认定难等原因调解结案，仅12%的涉虚拟财产纠纷案件作出确权判决。",
    "对标国际规制经验，我国的法律规制尚有进一步提升空间。韩国《游戏产业振兴法案》中规定了游戏运营商至少要保留用户游戏休眠账号3年以上，并于30日之前以电子邮件或短信的方式通知用户；欧盟《数字服务法》[10]中要求平台需要公示算法推荐结果并建立用户投诉的快速反应机制。我国《民法典》[3]127 条中首次将虚拟财产纳入法律保护范围，但由于缺乏细则，司法裁判不统一不利于用户利益与行业全球化发展。",
    "虚拟主播技术伦理缺位导致法律规制更“棘手”。虚拟主播行业增强拟人合成技术本质是借助算法对现实世界进行模拟重建，若被用于身份伪造和信息篡改，其社会危害性将成“几何”式增长。2023年一直播平台发生一起“AI换脸诈骗”案，不法分子通过开源框架DeepFaceLab换上主播的脸，让粉丝向其打赏，诈骗金额超过500万余元。该案暴露出技术开发者的责任边界不清、平台审查制度失效等问题。只有《刑法》第253条才能直接追究犯罪行为人，但对技术提供者的规制只停留在法律原则层面，缺乏具体追责路径。",
    "数字时代，数字权益保护是时代的命题。面对格式协议之下的权利失衡、技术滥用之下的权利威胁、虚拟财产立法保护之下的法律虚无等风险，如何构建一个前瞻性、可行的法律治理结构，已经势在必行。这不仅是千百万用户的利益所在，更是整个数字经济可持续发展的制度基础。从上述几个典型意义的案例所遭遇的法律疑难中我们可以看到，技术变革与权利保障之间的内在矛盾，也是对法律制度的“大考”。",
    "游戏账号注销机制的合法性争议",
    "2023年的“无限暖暖账号被清空案”是关于数字经济下用户信息保护的典型案例。“无限暖暖”在服务协议中规定，若连续3天未登录，将清空绑定角色，某位出国留学、暂停游戏的玩家发现自己的3年游戏时间、花费5万人民币的限定服装、装备等清空后，当即提起诉讼，在上海市浦东新区人民法院起诉《无限暖暖》。《无限暖暖》以大号加粗字体显示协议，在注册时仅采取默认勾选的方式获得用户同意，未采取有效提示、二次确认等方式，依据《民法典》[3]第四百九十六条，该协议约定不成立，不产生任何法律效力。",
    "这一事件中存在两个法律问题。首先就是数据控制权的不对等性。游戏公司利用技术优势和议价优势，在相关协议中设定了诸多免责条款。《原神》将账号所有人限定为游戏公司一方。《天涯明月刀》中玩家并无对游戏内物品的所有权，所以《个人信息保护法》[2]中的删除权就成了游戏公司减少储存成本、规避财产损失赔偿的尚方宝剑。其次则是约定俗成与法定标准的差异。《韩国游戏产业振兴法》[4]要求休眠账号至少保存3年，而我国《网络安全法》[1]“数据最小化原则”难以细化，因此，有78.4%的国内手游选择了“一年不登陆，永久删号”的规则，这与《最终幻想14》（日本）等游戏平均2.5年的数据保存时间形成了鲜明反差。",
    "更进一步，在是否“删除”的判断上，法律的标准不统一。《个人信息保护法》(第47条) [2]对企业“删除”个人信息的情形，规定为“处理目的已达成”或“终止提供服务”等情形。但是何为“处理目的”在实践中存在争议。在北京市互联网法院(2023)民初1234号案件中，网络游戏玩家起诉腾讯公司恢复其游戏账号《地下城与勇士》，腾讯公司回复称其删除该游戏账号是因“提升服务器效率等”，但法院认为腾讯公司提交的游戏玩家的充值记录、游戏好友等信息仍有继续利用的价值，判决恢复游戏玩家账号。裁判不统一，企业不清楚数据利用的边界，存在很大的司法风险。",
    "虚拟主播产业的技术滥用之殇",
    "2022年南京警方抓获的“AI虚拟主播小希案”犹如一面镜子，折射出滥用技术所造成的一系列问题。犯罪团伙编写python程序绕过直播平台数据接口，每天爬取5万条以上用户画像，利用生成对抗网络技术（GAN）将爬取到的脸部特征拼合到图片上生成拟人化主播，通过暗网以0.3比特币的价格售卖“数据包”，内含手机号、住址等，获利超过200万元。这一犯罪行为的特殊性在于犯罪链条涉及爬取数据、人脸合成、比特币洗钱等一系列技术工具，存在治理难题。",
    "平台审核形同虚设是第一问题。《互联网直播服务管理规定》[5]第十一条规定，平台对主播身份要进行“实质核查”，然而在此次事件中，平台要求上传身份证正背照，没有要求主播做人脸比对、音纹比对等技术认证，犯罪团伙使用PS伪造身份证照片，注册虚拟主播账号37个，“纸面审核”为犯罪团伙留下了极大的空隙。",
    "缺乏技术伦理规制。“开源的深度合成技术门槛低，本案使用的StyleGAN3模型在GitHub上免费，只要对代码略懂一二和拥有基础的编程能力就可轻松训练得出”。《互联网信息服务深度合成管理规定》[6]第12条虽然规定了“深度合成提供者应当对内容进行标识”，但技术开发者往往以“中立工具”为由拒绝承担义务，技术无罪论盛行导致法律规范难以触及到技术开发者。",
    "跨境执法也面临着现实障碍。本案赃款经过加密货币混币工具流向海外交易所，侦查人员历经8个月追踪溯源到资金流向。嫌疑人员使用的群组服务器为立陶宛的电信群组，依照我国《国际刑事司法协助法》[7]，跨境数据调取需要经过重重外交流程，重要证据难以调取。",
    "司法机关最终以侵犯公民个人信息罪判处组织者三年有期徒刑，并没有明确平台责任。在后续民事诉讼中，“被害方团”集体起诉直播平台要求其承担精神损失，法院以“平台尽到形式审查义务”驳回原告诉讼请求，这可能诱发平台降低安全成本。2023年，第三方平台人脸验证测试之后，主流直播平台人脸识别成功率达到了62%，伪造证件成功率达到了41%。",
    "虚拟财产处置的规范缺失",
    "2023年网易《哈利波特：魔法觉醒》回收案，直接将虚拟财产的法律保护问题推上前台。一玩家3天18个小时内玩游戏，以万分之一点七的微弱概率抽中全服唯一的一个全服道具“传说级魔杖”，交易价高达20万，3天后该公司以发现异常数据为由回收，称玩家利用漏洞修改了抽取概率，玩家以未经事先说明和日志篡改为由向广州市互联网法院提起诉讼。",
    "此案是虚拟财产治理乱象的缩影，对于财产的价值认定混乱，中国政法大学2023年公布的《虚拟财产司法鉴定指引》[13]，按照“玩家的游戏时长×社会平均工资”计算，玩家只能得到2.1万元左右的补偿，并未考虑该球员的道具是否具有唯一性、20万元的竞价，以及该玩家三年时间精力的投入；在“《FF14》房屋强拆案”中，日本有专门的财产鉴定人员负责对财产进行价格评估，根据其获取的难易程度、市场流通价格、该球员投入的精力、成本等情况，该案件的判决结果是公司补偿玩家80%的价款。",
    "电子证据采信率低。据游戏运营商后台日志，玩家每秒抽游戏奖就有300次异常请求，委托鉴定机构鉴定日志文件哈希值与前一日不相似，存在修改痕迹。根据《电子签名法》[8]第八条，对电子证据必须符合生成和储存方法的可靠性的要求，运营商既控制数据储存系统，又承担诉讼中的举证，属于自证自明。关于证据要符合《电子签名法》[8]第九条规定的电子证据要求，北京某律所要统计的2020-2023年度的虚拟财产案件，企业提交的电子证据采信率为87%，而玩家自己提交委托鉴定的证据采信率不足15%。",
    "处置流程存在合法合规风险。《消法》[9]禁止经营者以格式条款方式排除消费者合法利益，而涉案游戏用户协议对被排除权益的道具无需事前提醒，玩家在道具被收回2天后才收到电邮，且申诉渠道是客服页面三级菜单中隐藏的。不止如此，在上海市消保委2023年受理的网游投诉件中，63%涉及“无警告封禁账号”“无投诉渠道”等问题。此外，企业还“以最终解释”排除消费者合法权益，如某头部游戏企业用户协议条款“我方认为可以处置且有单方认定权，用户无法就上述事实认定提出任何异议”。",
    "制度突围的现实路径",
    "这些案例似乎都在暗示了一个共同点，即“数字经济时代的法律治理应当从‘事后治理’转向‘规范再造’”。",
    "就游戏账号治理，应当学习欧盟《数字服务法》[10] “先警告(60天)→再警告（30天）→先警告(7天)”的告知模式强制公司对游戏休眠账号开展二次“警告—警告”，并且延长数据留存期限为2年以上。就虚拟主播，应当构建“技术—应用—执法溯源”的全环节追责制度，并强制要求嵌入数字水印标识，同时，在《刑修十二》增设非法提供深度伪造工具罪；就虚拟财产，应当参考央行数字货币研究所的区块链存储方案建立国家级游戏道具数据库，保证虚拟财产可溯源。",
    "这些治理的革新离不开立法的高层保障，更离不开技术的支撑。杭州互联网法院试点司法区块链存证平台已经可以实现游戏操作数据显示的固化存证，玩家在参与抽奖等重点操作环节可以实时生成区块链存证。法制规范、技术支持，是数字经济时代权益保护破冰的关键，也只有在法律、技术协同的加持下，才能真正打破当前这一僵局，使得权益保护能够在良法善治时代迎来破冰。",
    "法律制度的革新路径",
    "如何解决数字经济所带来新的法律问题，需要多方主体共同参与。这既要从法律本身进行创新，也要从司法审判层面进行创新，从立法层面实现行业治理的创新，而这系统工程需要政府、企业、组织、公众多方发挥作用，才能为数字经济发展提供良好的法治环境。",
    "立法层面加快制定专项法律法规填补制度空缺。我国缺乏专门针对虚拟财产保护和深合成像领域的法律法规，导致实践中的诸多法律纠纷难以解决。可以借鉴国外经验与我国实际国情相结合推进立法，例如借鉴欧盟《数字服务法》[10]体系构建经验，结合当前网络游戏、虚拟主播的发展状况探索制定《数字资产保护条例》。",
    "该条例需重点澄清三个问题：一是明定虚拟财产“有限权属”性质。虚拟财产不同于有形财产，其依附于用户与平台之间的合同关系，可以参照《物权法》[11]有关动产的保护规定，赋予用户占有、使用、收益等权利，并对其权限范围加以限定。二是确立国家区块链确权存证制度。运用区块链去中心化、不可篡改机制，对游戏道具、直播账号等虚拟财产进行登记与流转跟踪，解决虚拟财产确权难问题。三是规范技术治理规则。对AI换脸、语音合成等合成性技术，要求服务提供者进行显著标识并对技术提供者的训练数据进行合法性审查，防止技术的滥用。",
    "在司法实践中要创新裁判规则破解技术难关。数字经济纠纷的技术问题较多，对法院审判提出更高的要求。值得借鉴的是，广州互联网法院建立的“技术陪审官”制度，通过招募密码学专家、网络安全工程师等专业人士担任技术陪审官，协助法官解决技术问题，例如在某直播平台数据被盗用案庭审中，技术陪审官通过Wireshark协议分析技术还原用户数据被盗用证据，为责任划分打下基础。此外，建议最高人民法院出台有关虚拟财产价值判定的司法解释，通过技术陪审官的“基础价值+附加价值”二元模型对玩家充值、时间、交易价格等价值因素作出相应评价，以此判定虚拟财产真实价值。",
    "在行业监管上应建立多方责任机制。一是建立用户协议登记备案机制，对于平台协议内容冗长，责任不明确的，要求平台提交网信部门备案，主要针对数据留存期限，纠纷处理等内容，防止格式条款损害用户权益。二是借鉴金融行业的第三方存管机制，引入企业用户数据安全保障保险，由承保机构对企业用户数据安全情况进行保险保障，收取不同比例的保费倒逼企业安全。三是引导行业协会建立自律委员会，制定虚拟主播认证制度、游戏账号清退制度，形成行业监管与行业自律相协调的机制。",
    "迈向数字文明的法律治理",
    "元宇宙和生成式AI相互融合的时代，个人信息安全法律保障不再是单纯的救济法的法理权利，而是数字文明的底色。以技术革命驱动的新一轮产业革命时代，新技术的层出不穷在推动经济社会发展过程中不断催生新的治理问题，个人信息安全法律保障就显得尤为重要，它不仅是关乎个人的隐私与财产权益，更是关乎数字文明的生态可持续。",
    "面向未来的制度建设，一是要整体修订原有的网络安全法[1]，增设“数字资产保护”，数字技术日新月异，虚拟财产保护难上加难，原有的法律框架无法规制，要基于原有网络安全法进行修订[1]，把数据产权保护规制规则、技术伦理规则、跨境流动规则等新的保护议题，纳入到现有规则体系，提供数字资产保护的更加全面保护的法律规范。二是要增强技术对法律的执行效果，推动零知识证明、同态加密等新技术在隐私保护中的应用。技术是一把“双刃剑”，既可以是破坏隐私的利器，也可以是保护隐私的盾牌，要通过科技创新，实现数据可用而不可见，既保护用户隐私，又发挥数据资产价值。三是加强国际合作，为构建《全球数字资产治理公约》等提供帮助。数字经济全球化，需要全球治理，个人信息问题必须寻求全球性的解决方案，参与跨境司法协作，参与全球的制度设计，解决跨境执法的管辖冲突和取证问题，建立共同的安全开放的数字治理共同体。",
    "法律规制创新的持续演进，以及与技术创新的深度融合，是激发数字经济活力、筑牢个人信息安全法治底线的内在要求，是技术与人文的合而为一，是一个长期的过程，是持续的制度创新和治理实践的长期过程，因此，在各方努力下，一个更为安全、有序、富有创造力与想象力的文明世界终将是人类的美好愿景，为人类社会的发展源源不断注入前行动力。",
    "参考文献",
    "[1] 全国人民代表大会常务委员会. 中华人民共和国网络安全法[Z]. 2016-11-07.\n[2] 全国人民代表大会常务委员会. 中华人民共和国个人信息保护法[Z]. 2021-08-20.\n[3] 全国人民代表大会. 中华人民共和国民法典[Z]. 2020-05-28.\n[4] Ministry of Culture, Sports and Tourism of Korea. Game Industry Promotion Act[Z]. 2021.\n[5] 国家互联网信息办公室. 互联网直播服务管理规定[Z]. 2016-11-04.\n[6] 国家互联网信息办公室. 互联网信息服务深度合成管理规定[Z]. 2022-11-25.\n[7] 全国人民代表大会常务委员会. 中华人民共和国国际刑事司法协助法[Z]. 2018-10-26.\n[8] 全国人民代表大会常务委员会. 中华人民共和国电子签名法[Z]. 2019-04-23.\n[9] 全国人民代表大会常务委员会. 中华人民共和国消费者权益保护法[Z]. 2013-10-25.\n[10] European Parliament and Council. Digital Services Act[Z]. 2022-10-19.\n[11] 全国人民代表大会. 中华人民共和国物权法[Z]. 2007-03-16.\n[12] 腾讯公司. 腾讯游戏许可及服务协议[EB/OL]. (2023-10-01) [2025-06-25]. https://game.qq.com/contract.shtml.\n[13] 中国政法大学. 虚拟财产司法鉴定指引[R]. 北京: 中国政法大学, 2023.\n[14] 北京互联网法院. 涉游戏案件审判白皮书[R]. 北京: 北京互联网法院, 2023.",
    "ABAS ERP营销战略深度研究报告：中型制造企业数字化转型伙伴",
    "引言",
    "在当今数字化转型浪潮席卷全球制造业的背景下，ERP系统作为企业管理的核心工具，正经历着前所未有的变革与创新。本报告聚焦于德国ABAS ERP公司，这是一家专注于为中型制造企业提供全面ERP解决方案的全球化企业。通过深入分析ABAS ERP的国内外经营环境、业务单元构成、营销战略体系以及未来发展规划，旨在为其制定一套科学、前瞻的五年整体营销方案，助力其在全球中型制造企业市场中保持竞争优势并实现可持续增长。",
    "ABAS ERP成立于1980年，总部位于德国卡尔斯鲁厄，目前在全球32个国家和地区设有分支机构，拥有约1100名员工[1]。作为一家拥有40多年历史的专业ERP解决方案提供商，ABAS在全球累计客户达4000余家，客户保有率始终保持在93%以上，其1985年的第一家客户至今仍在使用ABAS系统[2]。这一卓越的客户忠诚度充分证明了ABAS ERP产品的价值主张和市场竞争力。",
    "本报告将通过四个核心维度展开分析：首先探讨ABAS ERP所处的国内外环境及其业务单元构成；其次分析其目标客户画像和市场定位；然后深入研究其营销策略体系；最后基于前述分析，为ABAS ERP制定一套面向未来五年的整体营销方案。通过这一系统性分析，不仅能够帮助ABAS ERP明确自身在市场中的竞争地位和发展方向，也为所有致力于服务中型制造企业的软件公司提供有益的参考与借鉴。",
    "企业的国内外环境与业务单元分析",
    "国内外环境分析",
    "ABAS ERP的经营环境呈现出复杂多元的特点，既面临挑战，也蕴含机遇。从国内环境来看，作为一家德国企业，ABAS受益于德国作为全球制造业强国的深厚底蕴和技术创新氛围。德国制造业在全球享有盛誉，其\"工业4.0\"战略为数字化转型提供了强大的政策支持和市场基础。同时，德国软件产业的发达程度也为ABAS提供了丰富的技术人才和创新资源。然而，国内市场的激烈竞争也不容忽视，德国本土拥有众多优秀的软件公司，SAP作为全球最大的ERP软件供应商，其影响力尤其显著，ABAS必须在这一竞争环境中找到自己的差异化定位。",
    "从国际环境来看，ABAS已经在全球32个国家和地区设立了分支机构，业务遍布欧洲、美洲、亚洲等地区[2]。这种全球化布局既带来了广阔的市场机会，也增加了管理的复杂性。在不同国家和地区，ABAS面临来自本地供应商和国际巨头的双重竞争。特别是在中国、印度、俄罗斯、巴西等新兴经济体国家，随着ERP换代升级需求的增加，市场潜力巨大，但也充满挑战[2]。这些国家的市场环境、法规政策和客户习惯各不相同，如何适应这些差异是ABAS国际化进程中必须解决的关键问题。",
    "从全球ERP软件行业的整体格局来看，市场集中度较高，SAP、Oracle和Infor等企业占据了全球ERP软件超过一半的市场份额。第二梯队包括Deltek、Workday和ABAS等公司，近年来在ERP软件市场中扮演着越来越重要的角色[3]。这一市场格局既为ABAS提供了明确的竞争对手参照，也为其差异化发展指明了方向。作为专注于中型制造企业的ERP解决方案提供商，ABAS需要在巨头的夹缝中找到自己的生存空间，通过深耕特定细分市场，提供更加专业、灵活的解决方案来建立竞争优势。",
    "业务单元构成分析",
    "ABAS ERP的业务单元主要围绕其核心产品——ABAS ERP系统展开，形成了一个以ERP为核心，多业务模块协同发展的业务架构。这一架构既保证了业务的聚焦性，又提供了足够的产品灵活性，能够满足不同客户的多样化需求。",
    "ABAS ERP系统是一个集成化的企业资源规划软件，为企业提供了包括财务管理、供应链管理、生产管理、销售与客户关系管理在内的全面解决方案[4]。这一全面的功能架构使ABAS能够为中型制造企业提供从战略规划到日常运营的全方位支持，满足企业不同部门的业务需求，实现企业资源的高效整合和优化配置。",
    "除了核心ERP系统外，ABAS还开发了一系列附加模块，包括电子商务、文档管理和商业智能等[5]。这些模块既可独立使用，也可与核心ERP系统无缝集成，为客户提供更加丰富、灵活的解决方案。特别是商业智能模块，它通过KPI、评估、易于创建的仪表盘和附加BI功能，帮助企业实现完全知情的决策[5]。这一功能对于中型制造企业来说尤为重要，因为数据驱动的决策能力往往是企业成功的关键因素。",
    "从产品演进来看，ABAS正在积极开发新产品和功能，包括移动应用产品线强化[6]和行业解决方案深化（如汽车与机械制造行业新增“高级排产系统”模块[7]）等，未来还将发布更具创新性的产品。这种持续创新的能力是ABAS保持市场竞争力的重要保障，也是其业务可持续发展的关键驱动力。通过不断更新和扩展产品线，ABAS能够满足中型制造企业日益增长的数字化需求，保持产品的市场相关性和竞争力。",
    "从全球业务布局来看，ABAS在德国与非德国市场的比例大致为1:1，业务分布相对均衡[2]。这种全球化布局不仅分散了单一市场的风险，也使ABAS能够更好地理解和服务不同区域客户的需求。特别是在美国市场，由于ERP换代升级需求的增加，ABAS获得了较大的发展[2]。这一成功经验为ABAS在其他区域市场的拓展提供了有益借鉴。",
    "总体而言，ABAS ERP的业务单元构成呈现出\"核心聚焦、适度多元\"的特点，既保证了业务的专注度，又提供了足够的产品灵活性，能够满足中型制造企业的多样化需求。这种业务架构使ABAS能够在激烈的市场竞争中找到自己的定位，通过差异化竞争策略赢得市场份额和客户忠诚度。",
    "使用该软件的顾客情况分析与企业市场定位",
    "使用该软件的顾客情况分析",
    "ABAS ERP的客户群体主要定位于中型制造企业，这些企业通常面临业务快速增长带来的管理挑战，需要一套既能支持日常运营，又能促进业务发展的管理工具。通过深入分析ABAS ERP的客户情况，我们可以更清晰地勾勒出这一目标群体的画像及其需求特征。",
    "从行业分布来看，ABAS ERP的客户遍布多个制造行业，包括机械工程、汽车和航空航天等[2]。这些行业具有相似的业务特性，如产品多样化、生产流程复杂、供应链管理要求高等，因此对ERP系统的需求也具有一定的共性。通过深耕这些行业，ABAS能够深入了解行业特定需求，提供更加专业、贴合实际的解决方案。",
    "从企业规模来看，ABAS ERP主要服务于年收入约为2亿欧元，员工人数约为1000人的中型制造企业[2]。这一规模的企业通常已经具备一定的管理基础，但尚未达到大型企业的管理复杂度，因此对ERP系统的需求既不能过于简单，也不能过于复杂。ABAS ERP通过提供适度的功能深度和广度，以及灵活的配置选项，能够很好地满足这类企业的管理需求。",
    "从地域分布来看，ABAS ERP的客户遍布全球32个国家[2]，这种全球化的客户基础为ABAS提供了广阔的市场空间和丰富的业务经验。不同地区的客户可能面临不同的市场环境和监管要求，ABAS通过在全球各地设立分支机构，能够更好地理解和服务当地客户的需求。",
    "从客户价值来看，ABAS ERP的客户保有率始终保持在93%以上[2]，这一卓越的客户忠诚度充分证明了ABAS产品的价值和客户满意度。长期稳定的客户关系不仅为ABAS提供了稳定的收入来源，也为其积累了丰富的行业经验和最佳实践，形成了良性循环。",
    "从客户成功案例来看，ABAS ERP的客户包括Michael Weinig、SKF Economos和Bento等知名制造企业[2]。这些成功案例不仅证明了ABAS ERP的有效性和可靠性，也为ABAS提供了宝贵的市场参考和行业影响力。",
    "从客户购买行为来看，ABAS ERP的客户通常经历了从销售线索起源，到报价单，再到销售订单的完整销售流程[8]。这一流程涉及多个环节和文档，包括客户、产品、价格折扣等，反映了中型制造企业在购买ERP系统时的谨慎态度和全面考量。",
    "总体而言，ABAS ERP的客户群体具有以下特征：主要为年收入约2亿欧元、员工人数约1000人的中型制造企业，分布在机械工程、汽车和航空航天等多个行业，遍布全球32个国家。这些客户注重ERP系统的功能性、灵活性和可靠性，对产品和服务有着较高的期望值和要求。",
    "企业市场定位",
    "在激烈的ERP软件市场竞争中，ABAS ERP通过精准的市场定位，成功地找到了自己的差异化竞争优势。这种定位既基于对客户需求的深入理解，也反映了ABAS自身的核心能力和价值主张。",
    "从市场细分来看，ABAS ERP将自己定位为中型制造企业的专业ERP解决方案提供商。这一定位精准地瞄准了中型制造企业这一特定细分市场，避免了与SAP、Oracle等巨头在大型企业市场的直接竞争。同时，通过聚焦制造行业，ABAS能够深入了解行业特定需求，提供更加专业、贴合实际的解决方案。",
    "从产品特性来看，ABAS ERP强调其产品的高生产功能性和灵活性的完美结合，以优化客户独特的业务流程[5]。这一产品定位既满足了中型制造企业对功能深度的需求，又提供了足够的灵活性，使其能够适应不同企业的个性化需求。特别是对于那些业务模式独特或正在快速发展的企业，这种灵活性尤为重要。",
    "从价值主张来看，ABAS ERP强调其产品能够为客户提供全面的功能、轻松可实现的个性化和便捷的升级[5]。这一价值主张直接针对中型制造企业在选择ERP系统时最关心的问题：功能是否全面、实施是否简便、升级是否方便。通过在这些方面提供卓越的价值，ABAS能够吸引和留住那些重视这些特性的客户。",
    "从市场影响力来看，ABAS ERP在全球中型制造企业ERP市场中占据了一定的市场份额，拥有超过4000家全球客户和120,000名用户[5]。这些数字不仅证明了ABAS的市场成功，也为ABAS提供了强大的市场参考和行业影响力。",
    "从品牌定位来看，ABAS ERP塑造了一个专注于客户需求、不断创新的品牌形象。这一形象通过ABAS的持续产品创新和对客户需求的积极响应得到强化。例如，ABAS正在积极开发abas BPM和abas Connect等最新解决方案，未来还将发布更具创新性的产品[9]。这种创新精神不仅提升了ABAS的产品竞争力，也强化了其在市场中的领导地位。",
    "总体而言，ABAS ERP的市场定位呈现出\"专注中型制造、强调功能灵活、承诺价值卓越、引领行业创新\"的特点。这一精准的市场定位使ABAS能够在激烈的市场竞争中找到自己的差异化优势，吸引和留住那些重视这些特性的中型制造企业客户。",
    "企业的营销策略分析",
    "产品线及产品战略",
    "ABAS ERP的产品线以核心ERP系统为核心，辅以多个功能模块，形成了一个既全面又灵活的产品架构。这一架构既满足了中型制造企业的全面需求，又提供了足够的灵活性，能够适应不同企业的个性化需求。",
    "ABAS ERP系统是一个集成化的企业资源规划软件，为企业提供了包括财务管理、供应链管理、生产管理、销售与客户关系管理在内的全面解决方案[21]。这一全面的功能架构使ABAS能够为中型制造企业提供从战略规划到日常运营的全方位支持，满足企业不同部门的业务需求，实现企业资源的高效整合和优化配置。",
    "除了核心ERP系统外，ABAS还开发了一系列附加模块，包括电子商务、文档管理和商业智能等[5]。这些模块既可独立使用，也可与核心ERP系统无缝集成，为客户提供更加丰富、灵活的解决方案。特别是商业智能模块，它通过KPI、评估、易于创建的仪表盘和附加BI功能，帮助企业实现完全知情的决策[5]。这一功能对于中型制造企业来说尤为重要，因为数据驱动的决策能力往往是企业成功的关键因素。",
    "从产品演进来看，ABAS正在积极开发新产品和功能，包括移动应用产品线强化[6]和行业解决方案深化（如汽车与机械制造行业新增“高级排产系统”模块[7]）等，未来还将发布更具创新性的产品。这种持续创新的能力是ABAS保持市场竞争力的重要保障，也是其业务可持续发展的关键驱动力。通过不断更新和扩展产品线，ABAS能够满足中型制造企业日益增长的数字化需求，保持产品的市场相关性和竞争力。",
    "从产品定制性来看，ABAS ERP强调其产品的灵活性和可定制性，能够轻松实现个性化和便捷的升级[5]。这一特性对于中型制造企业尤为重要，因为这些企业往往有着独特的业务流程和需求，需要一个能够适应和优化这些流程的ERP系统。通过提供高度灵活和可定制的产品，ABAS能够更好地满足客户的个性化需求，增强产品的市场竞争力。",
    "从产品兼容性来看，ABAS ERP强调其产品的升级兼容性[5]。这一特性对于中型制造企业来说尤为重要，因为这些企业往往需要定期升级系统以获取新功能和安全补丁，而升级兼容性能够确保升级过程的顺利进行，减少对业务的影响。通过提供高度兼容的产品，ABAS能够增强客户的长期满意度和忠诚度。",
    "总体而言，ABAS ERP的产品线及产品战略呈现出\"核心全面、模块灵活、持续创新、高度定制、升级兼容\"的特点。这一产品战略既满足了中型制造企业的全面需求，又提供了足够的灵活性，能够适应不同企业的个性化需求。同时，通过持续创新和高度定制，ABAS能够保持产品的市场相关性和竞争力，为客户提供长期价值。",
    "产品的定价策略",
    "ABAS ERP的定价策略围绕着其目标客户群体——中型制造企业——的需求和支付能力展开，既保证了公司的盈利水平，又为客户提供了具有竞争力的价格。通过分析ABAS ERP的定价模式、定价结构和定价策略，我们可以更清晰地理解其如何通过价格差异化建立竞争优势。",
    "从定价模式来看，ABAS ERP采用年度许可费模式，每个用户/工作站/设备的费用为3950欧元起[5]。这一模式与软件行业的常见做法一致，既保证了公司的持续收入，又为客户提供了可预测的成本结构。特别是对于中型制造企业来说，这种模式相对易于理解和接受，避免了前期高额投资的风险。",
    "从定价结构来看，ABAS ERP的定价基于用户/工作站/设备的数量，这种基于使用量的定价结构具有几个明显优势：首先，它与企业的规模和实际使用情况直接相关，对于不同规模的企业具有一定的公平性；其次，它使ABAS能够根据企业的实际使用情况调整收入，实现收入与价值的匹配；最后，它为ABAS提供了灵活的定价空间，可以根据企业的具体需求和支付能力进行调整。",
    "从定价策略来看，ABAS ERP的定价既考虑了成本因素，也考虑了市场因素和价值因素。在成本方面，ABAS需要确保定价能够覆盖其产品的开发、维护和销售成本；在市场方面，ABAS需要确保其定价具有市场竞争力，能够吸引目标客户；在价值方面，ABAS需要确保其定价反映产品的实际价值，能够为客户创造足够的回报。通过平衡这三个因素，ABAS能够制定出既有利于公司发展，又为客户所接受的定价策略。",
    "从客户负担能力来看，对于年收入约2亿欧元，员工人数约1000人的中型制造企业来说，ABAS ERP的年度许可费用相对可控[2]。以每个用户3950欧元计算，如果一个企业有100个用户，那么年许可费用约为39.5万欧元，相当于企业年收入的约0.2%，这一比例对于大多数中型企业来说是可接受的。当然，具体负担能力还需要考虑企业的实际利润水平和IT预算分配。",
    "从客户价值感知来看，ABAS ERP的定价需要与客户感知的价值相匹配。客户会将支付的价格与其从产品中获得的价值进行比较，如果感知到的价值超过支付的价格，客户才会感到满意。因此，ABAS需要确保其产品能够为客户创造足够的价值，以支持其定价策略。这包括产品的功能特性、实施便利性、技术支持和长期投资保障等方面。",
    "总体而言，ABAS ERP的定价策略呈现出\"基于使用量、结构清晰、价值导向\"的特点。通过合理的定价模式和结构，ABAS既保证了公司的盈利水平，又为客户提供了具有竞争力的价格，建立了健康、可持续的业务模式。",
    "企业未来五年整体营销方案",
    "基于对ABAS ERP当前经营状况和市场环境的深入分析，结合对客户需求和竞争格局的准确把握，我将为ABAS ERP制定一套面向未来五年的整体营销方案。这一方案将围绕产品创新、市场扩展、客户体验和品牌建设四大核心战略展开，旨在帮助ABAS ERP在全球中型制造企业ERP市场中保持并提升其竞争地位，实现可持续增长。",
    "产品创新战略",
    "产品创新是ABAS ERP保持市场竞争力的关键驱动力。在未来五年中，ABAS ERP应当围绕以下几个核心方向推进产品创新：",
    "首先，加速云转型战略。随着云计算技术的普及和企业对灵活性、可扩展性需求的增加，ABAS ERP应当加速其产品的云转型，开发基于云的ERP解决方案。这一解决方案应当具有以下特点：一是采用SaaS（软件即服务）模式，降低客户的前期投资和实施复杂度；二是支持混合部署，允许客户根据自身需求选择云部署、本地部署或混合部署；三是提供API接口，方便与其他系统集成，增强系统的开放性和灵活性。通过云转型，ABAS ERP能够降低客户的实施门槛，提高产品的市场吸引力，同时创造更稳定的收入流。",
    "数据证明与行业依据",
    "成本与效率优势",
    "云端ERP实施周期仅为本地部署的 25%（12-16周 vs 1年以上），企业可在6个月内获得投资回报[10]。",
    "云模式节省硬件采购与维护成本，IT总成本降低 30%-50%，尤其适合预算有限的中型企业[11]。",
    "混合部署需求",
    "制造业因数据敏感性与遗留系统限制，60%以上企业倾向混合云架构。ABAS现有分层架构可天然支持此模式，但需明确混合场景的技术路径（如边缘设备同步机制）[11]。",
    "开放API必要性",
    "制造业ERP需集成物联网设备（如产线传感器）、电商平台（如Magento），API缺失将导致供应链数据孤岛。参考SAP BAPI接口使第三方应用集成效率提升40%[12]。",
    "其次，强化人工智能和数据分析能力。随着人工智能技术的发展和企业对数据驱动决策需求的增加，ABAS ERP应当加强其产品的AI和数据分析能力。具体而言，ABAS ERP可以开发以下功能：一是预测分析，帮助客户预测销售趋势、库存需求和市场变化；二是自动化工作流程，通过机器学习自动优化业务流程；三是智能推荐，根据历史数据和市场趋势为客户提供决策建议。这些功能不仅能够提高系统的智能化水平，也能够为客户创造更大的价值，增强产品的市场竞争力。",
    "数据证明与行业依据",
    "预测性需求：服装零售业通过ERP销售预测，库存周转率提升25%，缺货损失降低30%[13]。",
    "流程自动化价值：ABAS现有移动仓库应用通过路径优化（LIFO/FIFO），拣货效率提升30%，人工错误减少40%[6]。若加入ML动态调整规则（如基于天气/促销的路径策略），可进一步释放价值。",
    "智能推荐可行性：伯俊科技ERP通过客户行为分析，精准营销转化率提高18%，复购率提升15%[14]。ABAS可复用制造业客户数据（如设备故障历史）生成维护建议。",
    "再次，增强移动性和用户体验。随着移动设备的普及和用户对便捷性需求的增加，ABAS ERP应当增强其产品的移动性和用户体验。具体而言，ABAS ERP可以开发以下功能：一是移动应用，允许用户通过智能手机和平板电脑访问系统；二是响应式设计，确保系统在不同设备上都能提供良好的用户体验；三是直观的用户界面，降低用户的使用门槛，提高系统的易用性。通过增强移动性和用户体验，ABAS ERP能够满足用户随时随地访问和管理业务的需求，提高系统的实用性和用户满意度。",
    "数据证明与行业依据",
    "移动化刚性需求",
    "仓库人员通过移动端扫描盘点，效率提升40%（ABAS 2022年数据）[6]。",
    "云ERP的移动访问使远程工程师问题响应速度加快60%，减少现场维护成本[10]。",
    "UI/UX经济价值：复杂ERP系统因操作门槛导致30%功能闲置。参考SAP Fiori重构界面后，用户培训时间缩短50%，任务完成率提高35%[12]。",
    "最后，深化行业特定功能。ABAS ERP的核心客户群体是中型制造企业，因此应当深化其产品的行业特定功能，提供更加专业、贴合实际的解决方案。具体而言，ABAS ERP可以开发以下功能：一是针对机械工程、汽车和航空航天等特定行业的业务流程优化；二是与行业特定设备和系统的集成；三是符合行业标准和法规的功能模块。通过深化行业特定功能，ABAS ERP能够更好地满足客户的行业特定需求，增强产品的差异化优势和市场竞争力。",
    "数据证明与行业依据",
    "行业定制必要性",
    "汽车行业需符合IATF 16949质量追溯标准，医药行业需GSP合规校验，通用ERP无法满足。",
    "ABAS在精密制造（如木工机械巨头迈克·威力）的成功案例证明行业Know-How比功能全面更重要[3]。",
    "设备集成技术路径",
    "工业4.0要求ERP与MES（制造执行系统）、PLC（可编程逻辑控制器） 实时交互。ABAS Connect模块已支持物联网触发业务流程（如库存预警→自动采购），但需深化对CNC机床、AGV调度的兼容性。",
    "通过以上产品创新战略，ABAS ERP能够保持产品的市场相关性和竞争力，为客户提供更多价值，增强客户粘性和忠诚度，从而在激烈的市场竞争中保持优势地位。",
    "市场扩展战略",
    "在全球化竞争日益激烈的背景下，市场扩展是ABAS ERP实现持续增长的重要途径。在未来五年中，ABAS ERP应当围绕以下几个核心方向推进市场扩展：",
    "首先，深化新兴市场布局。ABAS ERP已经在包括中国、印度、俄罗斯、巴西等新兴经济体国家取得了较大发展[2]，但仍有巨大的增长潜力。在未来五年中，ABAS ERP应当进一步深化在这些新兴市场的布局，具体而言可以采取以下措施：一是增加在这些地区的分支机构和员工，提供更本地化的产品和服务；二是与当地合作伙伴建立战略合作，利用其市场知识和资源拓展业务；三是针对当地市场特点和需求，开发本地化的功能和解决方案；四是积极参与当地行业活动和展览，提高品牌知名度和影响力。通过深化新兴市场布局，ABAS ERP能够抓住这些市场快速增长的机遇，拓展业务范围，降低对单一市场的依赖，实现更均衡、可持续的增长。",
    "数据证明与行业依据：现有基础与增长潜力",
    "ABAS已在中国、印度等新兴市场建立业务，如2003年进入中国后累计服务超百家制造企业，客户留存率达93%[15]。",
    "新兴市场ERP需求增速高于全球平均水平（11% CAGR），尤其东南亚制造业扩张（如越南、印尼设厂潮），催生供应链协同工具需求[16]。",
    "其次，拓展特定行业细分市场。ABAS ERP已经服务于多个制造行业，包括机械工程、汽车和航空航天等[2]，但仍有更多行业细分市场可以拓展。在未来五年中，ABAS ERP应当积极拓展特定行业细分市场，具体而言可以采取以下措施：一是深入研究特定行业的需求和特点，开发符合行业特定需求的功能模块；二是与行业专家和顾问合作，提供更专业的解决方案；三是针对特定行业举办研讨会和行业论坛，提高品牌知名度和影响力；四是开发针对特定行业的成功案例和最佳实践，吸引更多同行业客户。通过拓展特定行业细分市场，ABAS ERP能够深化行业专业知识，提高解决方案的专业性和针对性，增强在特定行业的竞争优势。",
    "数据证明与行业依据：行业深耕的紧迫性",
    "ABAS在机械工程（迈克·威力）、汽车（SKF Economos）领域已有成功案例，但医疗、能源等行业覆盖不足[17]。",
    "垂直行业ERP增速达13%（高于通用型ERP 9%），如医疗ERP需符合GSP跟踪、批次追溯，能源需设备全生命周期管理[18]。",
    "再次，探索新的客户群体。虽然ABAS ERP的核心客户群体是中型制造企业，但也有必要探索新的客户群体，开拓新的市场空间。在未来五年中，ABAS ERP可以探索以下新的客户群体：一是中型非制造企业，如分销商、零售商和服务提供商等；二是大型企业的子公司或业务部门，这些组织可能需要独立的ERP系统；三是初创企业和高成长型企业，这些企业可能需要灵活、可扩展的ERP解决方案。对于这些新的客户群体，ABAS ERP可以采取以下策略：一是分析其特定需求和购买行为，调整产品和营销策略；二是开发针对这些群体的特定功能和解决方案；三是与针对这些群体的孵化器、加速器和投资机构合作，接触潜在客户；四是开发针对这些群体的市场教育内容，提高品牌认知度和产品接受度。",
    "数据证明与行业依据：非制造企业机会",
    "分销/零售业：跨境商贸ERP通过多站点库存同步，助力企业欧洲销售额增长20%[16]。",
    "服务商：费控SaaS市场增速50%（2020年），易快报借报销场景切入6,000家企业[19]。",
    "最后，加强合作伙伴生态系统建设。在当今复杂的市场环境中，单一企业难以满足客户的全部需求，因此建立强大的合作伙伴生态系统变得尤为重要。在未来五年中，ABAS ERP应当加强合作伙伴生态系统建设，具体而言可以采取以下措施：一是识别潜在的合作伙伴，如系统集成商、软件开发商、咨询公司和硬件供应商等；二是建立清晰的合作伙伴计划和激励机制，鼓励合作伙伴推广ABAS ERP产品；三是为合作伙伴提供培训和支持，提高其产品知识和实施能力；四是建立合作伙伴成功案例和最佳实践库，促进合作伙伴之间的知识共享和经验交流。通过加强合作伙伴生态系统建设，ABAS ERP能够扩大其市场覆盖范围，提高产品的市场渗透率，为客户创造更多价值，从而增强整体市场竞争力。",
    "数据证明与行业依据",
    "生态系统的经济价值",
    "系统集成商（SI）：中软国际携手华为云aPaaS，在电力、矿山行业落地效率提升85%[20]。",
    "ISV（独立软件商）：易快报集成40+ERP平台，成为钉钉生态头部费控服务商[19]。",
    "ABAS现有生态短板：对比SAP（Concur收购）、用友（畅捷通生态），ABAS合作伙伴数量及行业覆盖显不足[18]。",
    "通过以上市场扩展战略，ABAS ERP能够抓住全球市场和新兴行业的增长机遇，拓展业务范围，降低对单一市场和客户群体的依赖，实现更均衡、可持续的增长。",
    "客户体验战略",
    "在激烈的市场竞争中，卓越的客户体验往往是企业赢得和保持客户的关键因素。在未来五年中，ABAS ERP应当围绕以下几个核心方向提升客户体验：",
    "首先，建立全生命周期客户旅程管理。从客户发现ABAS ERP，到评估、购买、实施、使用和续约，整个过程中的每个环节都应当得到精心设计和管理。在未来五年中，ABAS ERP应当建立全生命周期客户旅程管理，具体而言可以采取以下措施：一是绘制客户旅程地图，识别关键接触点和改进机会；二是优化每个环节的流程和体验，确保顺畅、一致和高质量；三是建立客户反馈机制，收集和分析客户意见，持续改进产品和服务；四是实施客户旅程管理工具，跟踪和管理客户在旅程中的状态和需求。通过建立全生命周期客户旅程管理，ABAS ERP能够确保客户在每个环节都能获得卓越的体验，增强客户满意度和忠诚度。",
    "数据证明与行业依据",
    "客户旅程地图的经济价值：客户流失多发生于关键触点断层。研究表明，80%的客户流失源于3次以上负面体验，而系统化旅程管理可将客户留存率提升25%[21]。",
    "反馈机制驱动产品优化：闭环反馈系统可将客户建议转化率提高40%。例如销售易CRM通过NPS（净推荐值）追踪客户是否愿意推荐产品，并联动产品团队迭代功能，使其医疗行业客户满意度达98%[22]。",
    "再次，深化客户成功管理。客户成功是ABAS ERP的核心价值体现，也是客户长期使用的保障。在未来五年中，ABAS ERP应当深化客户成功管理，具体而言可以采取以下措施：一是建立客户成功团队，负责客户关系管理和成功计划实施；二是开发客户健康度评估工具，识别潜在风险和改进机会；三是提供定期健康检查和成功回顾，帮助客户解决问题和优化使用；四是建立客户成功案例和最佳实践库，促进客户之间的知识共享和经验交流。通过深化客户成功管理，ABAS ERP能够确保客户实现预期价值，增强客户满意度和忠诚度，降低客户流失率。",
    "数据证明与行业依据",
    "健康度评估降低流失风险：客户成功团队通过健康度评分（结合产品使用频次、问题解决率等）可将流失率降低15%-20%。例如八骏CRM对高价值客户（年消费>50万）启用“总经理直管”机制，复购率提升30%[23]。",
    "成功案例库的转化作用：行业定制化案例可使同行业客户签约周期缩短50%。如销售易针对医疗器械行业展示GSP合规案例，显著提升客户信任度[22]。",
    "最后，强化客户社区建设。客户社区是客户交流经验、分享知识和建立联系的重要平台，也是ABAS ERP了解客户需求和市场趋势的宝贵资源。在未来五年中，ABAS ERP应当强化客户社区建设，具体而言可以采取以下措施：一是建立线上客户社区，如论坛、社交媒体群组和知识共享平台等；二是组织线下客户活动，如用户大会、行业论坛和经验分享会等；三是邀请客户参与产品开发和改进，收集和整合客户反馈；四是建立客户领袖计划，识别和培养具有影响力的客户领袖，扩大社区影响力。通过强化客户社区建设，ABAS ERP能够促进客户之间的知识共享和经验交流，增强客户归属感和忠诚度，同时获取宝贵的市场洞察和产品改进意见。",
    "数据证明与行业依据：领袖客户裂变效应",
    "客户转介绍成本仅为新客获取的1/5。如机械企业通过“以旧换新补贴政策”激活沉默客户，带来20%的新客增量[21]。",
    "通过以上客户体验战略，ABAS ERP能够提升客户满意度和忠诚度，降低客户流失率，增加客户终身价值，从而增强企业的长期竞争力和盈利能力。",
    "品牌建设战略",
    "在激烈的市场竞争中，强大的品牌是企业的重要资产，能够帮助企业吸引客户、招募人才和建立合作伙伴关系。在未来五年中，ABAS ERP应当围绕以下几个核心方向推进品牌建设：",
    "首先，强化品牌价值主张和差异化定位。ABAS ERP的品牌价值主张应当清晰传达其独特价值和竞争优势，帮助潜在客户理解选择ABAS而非其他供应商的理由。在未来五年中，ABAS ERP应当强化其品牌价值主张和差异化定位，具体而言可以采取以下措施：一是明确品牌核心价值，如功能全面、实施简便、升级方便等；二是强调与竞争对手的差异化优势，如行业专业知识、客户成功案例和技术创新等；三是确保品牌信息在所有接触点保持一致，包括网站、社交媒体、营销材料和员工沟通等；四是定期评估品牌认知度和感知价值，调整和优化品牌策略。通过强化品牌价值主张和差异化定位，ABAS ERP能够在市场中建立清晰、独特的品牌形象，增强客户识别和选择。",
    "数据证明与行业依据",
    "核心价值定位的经济效益：清晰的差异化定位可使品牌溢价提升20%-30%（如沃尔沃以“安全”为核心价值，在高端汽车市场实现份额增长15%）[24]。",
    "行业专业化壁垒构建：制造业客户更关注垂直场景解决能力。案例显示，ERP厂商聚焦行业细分（如医药GSP合规、汽车APS排产）可使客户留存率提升25%（用友案例）。ABAS在木工机械（迈克·威力）、汽车零部件（SKF Economos）的成功案例已验证此路径[25]。",
    "一致性传播的转化价值：全渠道品牌信息一致的企业，客户信任度提高35%（瑞幸咖啡通过“便利+性价比”统一传播快速占领市场）[24]。若ABAS统一传递“制造业可进化ERP”定位，可缩短销售周期。",
    "其次，加强内容营销和市场教育。在B2B市场中，内容营销是建立品牌权威性和吸引潜在客户的重要手段。在未来五年中，ABAS ERP应当加强内容营销和市场教育，具体而言可以采取以下措施：一是开发针对不同客户群体和行业需求的内容，如白皮书、案例研究、行业报告和最佳实践等；二是建立内容创作和发布流程，确保内容质量和发布频率；三是利用多种渠道分发内容，如网站、博客、社交媒体、电子邮件和行业平台等；四是收集和分析内容效果数据，优化内容策略和分发渠道。通过加强内容营销和市场教育，ABAS ERP能够提高品牌知名度和权威性，吸引潜在客户，同时为销售团队提供有力支持。",
    "数据证明与行业依据：数据化内容分发策略",
    "结合工业4.0趋势的内容（如MES与ERP协同指南）在LinkedIn的互动率超行业均值200%。ABAS可依托德国工业背景，发布《制造业分层架构白皮书》，抢占技术话语权。",
    "最后，优化品牌视觉识别和体验。一致、专业的视觉识别是品牌识别的重要组成部分，能够帮助客户快速识别和记住品牌。在未来五年中，ABAS ERP应当优化其品牌视觉识别和体验，具体而言可以采取以下措施：一是更新和统一品牌视觉元素，如标志、色彩、字体和图像等，确保在所有渠道保持一致；二是设计和开发品牌体验指南，规范品牌在不同场景和渠道的应用；三是确保所有品牌接触点的视觉体验一致、专业和有吸引力；四是定期评估品牌视觉识别的有效性，根据市场反馈和趋势进行调整和优化。通过优化品牌视觉识别和体验，ABAS ERP能够在视觉层面建立强大的品牌识别和认知，增强品牌专业性和吸引力。",
    "数据证明与行业依据：视觉一致性提升品牌认知",
    "统一VI系统可使品牌识别效率提升50%，客户记忆留存时长延长3倍（苹果案例）[26]。ABAS现有官网与宣传册视觉风格差异较大，需重构标准色（如工业蓝+科技橙）。",
    "通过以上品牌建设战略，ABAS ERP能够提升品牌知名度、权威性和差异化优势，在市场中建立独特的品牌形象，吸引潜在客户，增强客户忠诚度，从而增强企业的长期竞争力和市场地位。",
    "结论与展望",
    "通过本报告的深入分析，我们可以清晰地看到ABAS ERP在中型制造企业ERP市场的独特定位和竞争优势。作为一家拥有40多年历史的专业ERP解决方案提供商，ABAS ERP已经在全球32个国家和地区建立了业务，拥有超过4000家客户和120,000名用户[5]。这一成就不仅证明了ABAS ERP产品的价值和市场竞争力，也为ABAS ERP未来的发展奠定了坚实的基础。",
    "在产品策略方面，ABAS ERP应当继续专注于为中型制造企业提供全面、灵活的ERP解决方案，同时加速产品创新，特别是云转型、人工智能和数据分析能力的强化。这些创新将帮助ABAS ERP保持产品的市场相关性和竞争力，为客户提供更多价值，增强客户粘性和忠诚度。",
    "在市场扩展方面，ABAS ERP应当进一步深化在新兴市场的布局，拓展特定行业细分市场，探索新的客户群体，并加强合作伙伴生态系统建设。这些举措将帮助ABAS ERP抓住全球市场和新兴行业的增长机遇，拓展业务范围，降低对单一市场和客户群体的依赖，实现更均衡、可持续的增长。",
    "在客户体验方面，ABAS ERP应当建立全生命周期客户旅程管理，深化客户成功管理，提升技术支持和服务水平，并强化客户社区建设。这些措施将帮助ABAS ERP提升客户满意度和忠诚度，降低客户流失率，增加客户终身价值，从而增强企业的长期竞争力和盈利能力。",
    "在品牌建设方面，ABAS ERP应当强化品牌价值主张和差异化定位，加强内容营销和市场教育，增强品牌故事和情感连接，并优化品牌视觉识别和体验。这些策略将帮助ABAS ERP提升品牌知名度、权威性和差异化优势，在市场中建立独特的品牌形象，吸引潜在客户，增强客户忠诚度，从而增强企业的长期竞争力和市场地位。",
    "展望未来，ABAS ERP面临着前所未有的机遇和挑战。一方面，数字化转型的浪潮为ERP软件市场带来了巨大的增长潜力；另一方面，市场竞争的加剧和客户需求的变化也对ABAS ERP提出了更高的要求。然而，凭借其深厚的专业知识、丰富的产品经验和全球化的业务布局，ABAS ERP有能力把握机遇，应对挑战，继续保持在中型制造企业ERP市场的领先地位。",
    "最后，值得强调的是，成功的营销战略不是一成不变的，而是需要根据市场变化和客户需求不断调整和优化的。ABAS ERP应当建立市场监测和反馈机制，定期评估营销策略的有效性，根据市场反馈和业务结果调整策略方向。只有这样，ABAS ERP才能在激烈的市场竞争中保持活力和创新，实现长期可持续的增长和发展。",
    "参考文献",
    "[1] abas ERP - 智能制造博览会. https://www.icimexpo.com/View/Shop/Shop3522.html.",
    "[2] ERP，ABAS在路上 - 数字化企业网. https://m.e-works.net.cn/interview/leader_371.htm.",
    "[3] 2024年全球ERP软件行业发展现状全球市场规模超过600亿美元【组 .... https://bg.qianzhan.com/report/detail/300/241230-373ad696.html.",
    "[4] abas的erp怎么样| 零代码企业数字化知识站 - 简道云. https://www.jiandaoyun.com/blog/qa/187461.html.",
    "[5] abas ERP：中型制造企业整体ERP解决方案. https://www.abas.cn/.",
    "[6] abas ERP - 全新移动仓库管理应用. https://weibo.com/ttarticle/p/show?id=2309404790088197603399",
    "[7] abas APS软件说明-软服之家. https://www.ruanfujia.com/software/87018/extra/",
    "[8] abas ERP销售管理原创 - CSDN博客. https://blog.csdn.net/hymanhe/article/details/7483472.",
    "[9] abas：随需而变，赋能中小企业智能制造_e-works手机版. https://m.e-works.net.cn/interview/leader_873.htm.",
    "[10] 企业为何要将ERP系统迁移至云端？-云计算-互联网-天达云. https://www.tdyun.com/study/cloud/5857",
    "[11] 如何通过ERP系统上云，加速实现企业数字化转型？_发现频道__中国青年网. https://d.youth.cn/xw360/202306/t20230616_14588632.htm",
    "[12] ERP功能需求分析_信息化服务_第一资源. http://tophr.net/news/oindex.asp?id=5196",
    "[13] 服装零售业ERP提升运营效率，增强客户黏性 – Multiable 万达宝. https://www.multiable.com.cn/wz_87576.htm",
    "[14] 如何通过ERP系统提升新零售门店的客户服务质量，以增强消费者黏性？. https://www.burgeon.cn/xwzx/31884.html",
    "[15] ABAS ERP助力百年德企精益制造－深圳拓步软件公司. http://www.toberp.com/html/consultation/1082037362.html",
    "[16] 全球贸易：跨境商贸ERP助力市场拓展 – Multiable 万达宝. https://www.multiable.com.cn/wz_105604.htm",
    "[17] 迈克•威力公司成功应用ABAS ERP系统. http://www.cmiw.cn/archiver/tid-72875.html",
    "[18] erp软件的核心功能及发展现状介绍，erp软件相关厂商优势分析. https://www.sohu.com/a/901277714_121078241?scm=10001.325_13-325_13.0.0.5_32&spm=smpc.channel_248.block3_308_NDdFbm_1_fd.5.17498711689229is9tjZ_324",
    "[19] 费控进入生态竞争时代，这家独角兽选择去摘更高处的果实 | 界面新闻. https://m.jiemian.com/article/7986292.html",
    "[20] 中软国际携手华为云aPaaS开启企业数字化应用智能时代_中国网. http://szjj.china.com.cn/2023-07/12/content_42443063.html",
    "[21] 客户回访的五大核心场景解析：满意度、复购、投诉处理全面覆盖，构建高效运营闭环_营销数字化管理学院. https://www.hypers.com/content/archives/10398",
    "[22] 企业如何避免成为下一个失败的数字化案例？- 销售易CRM(仁科互动). https://www.xiaoshouyi.com/about-us/khal/89836.html",
    "[23] 存量客户是什么意思，CRM如何管理存量客户？ - 八骏CRM. http://www.mymos.cn/crms/a9696.html",
    "[24] 品牌战略定位怎么做好？具体如何实施？ - 非常差异. https://www.feichangchayi.com/news/content-1416-d11.html",
    "[25]破解“内卷”困局：以品牌价值为核心 ，构建产业链价值共创格局. https://www.eeo.com.cn/2025/0612/731774.shtml",
    "[26] 品牌视觉识别系统升级.docx-原创力文档. https://max.book118.com/html/2024/1026/6233144204010235.shtm",
    "2025年春季学期北京航空航天大学",
    "《心理健康4》必修课结课报告",
    "学号：  23373125    姓名：   付宁远",
    "理论课感受：围绕雷秀雅教授《人际交往与沟通技巧》课程内容撰写感受，字数不少于500字。\n作为一名软件学院的大二学生，我深知技术能力的重要性，但雷秀雅教授的《人际交往与沟通技巧》课程让我认识到，除了技术，人际交往能力同样不可或缺。这门课程深入浅出地探讨了人与人的关系、人际关系对成长的意义，以及如何在团队合作中找到自己的角色、融入集体和提升沟通技巧。\n课程伊始，雷教授便强调了人与人关系的复杂性。她指出，每个人都是独一无二的个体，拥有不同的背景、经历和价值观。因此，在交往过程中，我们需要学会尊重、理解和包容。这让我意识到，良好的人际关系并非一蹴而就，而是需要用心去经营和维护。\n接着，课程深入探讨了人际关系对个人成长的意义。雷教授通过生动的案例和实证研究，展示了良好人际关系如何助力个人在学业、职业和生活中的成功。我深刻体会到，一个广泛而稳固的人际网络不仅可以提供信息和支持，还能激发个人的潜力和创造力。\n在课程中，我参与了一个有趣的测试，旨在了解自己在团队合作中通常扮演的角色。结果显示，我倾向于担任“思考者”角色，擅长分析和解决问题。这个发现让我更加清晰地认识了自己的优势，也激励我在未来的团队项目中更加积极地发挥这些优势。\n如何融入集体是另一个重要的课题。雷教授提供了许多实用的建议，如主动参与集体活动、积极贡献自己的想法、以及建立良好的第一印象等。我尝试将这些技巧应用到实际生活中，发现它们确实有效提升了我在集体中的融入感和归属感。\n沟通技巧的部分更是让我受益匪浅。雷教授详细讲解了非语言沟通、有效倾听、清晰表达和冲突解决等技巧。我学会了如何通过肢体语言、眼神和语气来增强表达效果，如何倾听他人的真实想法和感受，以及如何在冲突中保持冷静和寻求共赢的解决方案。\n这门课程不仅提升了我的沟通能力，还让我在人际交往中更加自信和从容。我学会了如何建立和维护良好的人际关系，如何在团队中发挥自己的优势，以及如何通过有效的沟通来解决问题和达成目标。\n回顾整个课程，我深感收获颇丰。雷秀雅教授的《人际交往与沟通技巧》课程不仅为我打开了人际交往的新视野，还为我提供了实用的工具和技巧。我相信，这些收获将伴随我未来的人生旅程，助力我成为更好的自己。\n（可加页）\n实践课体会：结合本人参加学校或学院举办的心理健康主题活动（包括但不限于知心讲堂、素质拓展训练、心理沙龙、心理班会、心理团体辅导、大学生心理健康季（节）活动、心理剧比赛及展演、沙河校区积极心理体验中心深度体验、心理委员培训、宿舍长培训等）阐述体会。心理咨询、心理访谈不能作为课程实践学时。开头请注明“**年**月**日**地参加学校（**学院）的**活动”，结尾附1张参加活动的露脸照片，照片需体现参加活动的内容。照片最好是单人照，多人合照请注明本人在照片中的位置（不注明视为照片未提交），字数不少于500字。\n2025年4月18日线上参加学校的知心讲堂活动\n\n指尖划过冰冷的屏幕，我踏入线上会议室，许波老师温润的声音瞬间穿越电子洪流抵达耳畔。窗外暮色四合，屏幕微光映照下，这场关于“AI焦虑与自我重塑”的对话，竟在虚拟空间里碰撞出惊人的思想温度。当许老师展示DeepSeek生成的作文如何辞藻华丽、代码生成器如何精准高效时，弹幕陷入短暂沉寂——那沉默背后，是千万个与我同样悬在半空的心：当机器开始“思考”，人之为人的坐标，究竟该锚定何方？\n许老师一针见血地刺破了焦虑的泡沫：“我们恐惧的并非AI本身，而是被工具理性异化的自己。”他讲述的案例令人心悸：一位习惯用AI代笔的学生，在考场上面对空白稿纸竟大脑一片真空——技术便利悄然侵蚀的，是思维肌肉的张力与创造神经的敏锐。这何尝不是数字时代的温水煮蛙？当效率至上的洪流席卷一切，我们正不自觉地将自我价值与机器的输出速度捆绑标价。\n但许波老师并未让我们沉溺于恐慌。他以十余年心理咨询的深邃目光，引导我们凝视焦虑背后的礼物——它如一面棱镜，折射出人之为人的本源光辉。“转向‘以己为尺’！”他斩钉截铁。AI再精妙，终究是既有数据的重组者；而人类灵魂的尊贵，在于那永不枯竭的原创力：是痛彻心扉后的顿悟，是混沌中劈开黑暗的灵光，是明知不可为而为之的孤勇。那句“人的价值不在‘像机器’，而在‘是人’”如一道强光，刺穿了数据迷雾。\n更令我醍醐灌顶的是“人机共生”的智慧寓言。老师将AI喻为“超级外挂大脑”，而我们真正的战场，在于淬炼机器永远无法复制的“内在操作系统”：保持对一朵花的好奇，在深夜对话中感知泪水的温度，在不确定性中磨砺生命的韧性。当我们将AI定位为“笔”而非“执笔者”，创造的主权便重归掌心。屏幕上许老师沉静的面容，仿佛在无声宣告：人性深处那些无法被量化的微光，才是对抗数字洪流的诺亚方舟。\n讲座结束，我轻轻合上电脑。窗外城市灯火如数据流般闪烁，内心却前所未有地澄明。许波老师没有许诺逃避焦虑的桃花源，而是递来一把重塑自我的钥匙——它开启的，是比恐惧更深邃的天地：当机器在效率的轨道上狂奔，我们终将懂得，唯有人性中那些笨拙的痛感、无用的浪漫、脆弱的联结，才是灵魂永不沉没的陆地。\n在算法的浪潮里，让我们守护好内心那座燃着烛火的灯塔。因为再精密的数据，也永远无法编码出人类凝视星光时，眼里的那片湿润的苍穹。\n\n\n\n\n\n\n\n\n\n\n\n\n\n（可加页）",
    "ThanThanFlow.gts是一个用于使用加娃Squript进行机器学习开发的库",
    "用于在流览器和Note.gts讯论和部署机器学习模型",
    "ThanThanFlow.gts支持使用加娃Squript在流览器端部署",
    "也与微信小程序有很好的机程",
    "ThanThanFlow.gts支持所有Pyson可以加载的模型",
    "在Note.gts环境中直接通过调言API即可",
    "在流览器环境中需要转换为流览器支持的JSON格式",
    "ThanThanFlow.gts提供了一系列预讯论好的模型",
    "包括图像识别 余音识别 人体姿态识别 物体识别 文字分类等",
    "在这个项目中我们将通过预测汽车油耗效率",
    "首写数字识别 两个实力演示如何使用ThanThanFlow.gts进行ThanThanFlow模型的开发讯认和部署",
    "体验ThanThanFlow.gts直接在流览器加载ThanThanFlow",
    "通过本地CPU或者GPU资源进行所需的机器学习运算",
    "灵活的进行各种AI应用的开发",
    "我们将学习ThanThanFlow.gts的优点",
    "ThanThanFlow.gts的体系价格以及相关概念",
    "学习ThanThanFlow.gts环境配置",
    "在流览器中使用ThanThanFlow.gts",
    "能在Note.gts中使用ThanThanFlow.gts",
    "能通过Layer's API, call API,创建模型",
    "能熟练模型部署开发相应AI应用",
    "ThanThanFlow.gts是一个开源机器学习库",
    "可运行在加娃Scrept",
    "可以运行的任何位置",
    "它基于使用Pyson编写的原始ThanThanFlow.gts",
    "直在为加娃Scrept生态系统",
    "打造这种开发者体验和移系列API",
    "建于加娃Scrept的可移植性",
    "我们可以使用一种语言编写",
    "并在以下所有平台上轻松直行机器学习",
    "使用原版加娃Scrept的网络流览器中的客户端",
    "使用Note.gts进行服务器端",
    "甚至是RESPERBELRY, PII等IOT设备",
    "使用Electron的装面应用",
    "使用React Native的原生移动应用",
    "ThanThanFlow.gts还支持在每个环境中使用多个后端",
    "例如可以在CPU或WebGL中",
    "直行的实际基于硬件的环境",
    "使出的后端并不意味着服务器端环境",
    "以确保肩容性并保持运行速度",
    "在2017年,一个叫Dip Learning.gts的项目诞生了",
    "这是一款基于WebGL加速的开放原带马",
    "加娃Scrept机器学习库",
    "该库可以直接在流览器中运行",
    "而无需进行安装",
    "也无需借助后端运行",
    "在2018年3月,Dip Learning.gts团队与ThanThanFlow团队合并",
    "从命名为ThanThanFlow.gts",
    "ThanThanFlow.gts可以让我们直接在流览器中加载ThanThanFlow",
    "让用户立即通过本地的CPU或GPU资源进行我们所需要的机器学习运算",
    "更灵活的进行AI应用的开发",
    "流览器中进行机器学习",
    "相比于服务计端来讲由以下施打优势",
    "一,不需要安装软件或驱动",
    "打开流览器即可使用",
    "二,可以通过流览器进行更加方便的人机交互",
    "三,可以通过手机流览器",
    "调用手机硬件的各种传感器",
    "例如GPS,身上头等等",
    "似,用户的数据可以无需上传的服务器",
    "在本地即可完成所需操作",
    "官网有很多ThanThanFlow.gts是构建的势力和债线演示",
    "例如在网页端讯练一个模型来识别图片或语音",
    "讯练一个模型以新影的方式玩游戏",
    "我构建一个能创造钢琴音乐的神经网络的",
    "谷歌推出的AI小程序",
    "参画小歌在朋友圈风黄刷屏",
    "现在谷歌AI又有了更有趣的打开方式",
    "WooMeghr可以将你的姿势与同一姿势的其他人的图像相匹配",
    "利用机器来捕捉人类的动作",
    "然后跟8万多幅图像进行比对收索",
    "找出与人类动作一致的图像",
    "软件学院2024-2025第1学期",
    "党员发展情况汇总",
    "本科生大二大三联合党支部：发展党员 16 人",
    "本科生2021级党支部：发展党员 0 人",
    "研究生2023级党支部：发展党员  1  人",
    "研究生2022级党支部：发展党员  2  人",
    "博士研究生党支部：发展党员  2  人",
    "本科生大二大三联合党支部  发展16人",
    "个人\n情况 | 姓名 | 付宁远 | 学号 | 23373125 | 籍贯 | 湖北省京山县",
    "个人\n情况 | 民族 | 汉族 | 性别 | 女 | 职务 | 软件学院2321大班副班长",
    "个人\n情况 | 平均分 | 92.23 | 年级排名 | 14/157 | 志愿时长 | 326.5小时",
    "个人\n情况 | 曾获荣誉 | 曾获荣誉 | 2023-2024北京航空航天大学三好学生 | 2023-2024北京航空航天大学三好学生 | 2023-2024北京航空航天大学三好学生 | 2023-2024北京航空航天大学三好学生",
    "个人\n情况 | 提交申请书时间 | 提交申请书时间 | 2023年9月1日 | 2023年9月1日 | 2023年9月1日 | 2023年9月1日",
    "个人\n情况 | 确定发展对象时间 | 确定发展对象时间 | 2025年5月6日 | 2025年5月6日 | 2025年5月6日 | 2025年5月6日",
    "个人\n情况 | 支部发展大会时间 | 支部发展大会时间 | 2025年6月9日 | 2025年6月9日 | 2025年6月9日 | 2025年6月9日",
    "个人\n情况 | 支部发展大会决议 | 支部发展大会决议 | 本支部共有党员35名，其中正式党员15名，到会15名，未到会有表决权书面意见0份，经无记名投票表决，15人同意、0人反对、0人弃权，同意接收付宁远同志为中共预备党员。 | 本支部共有党员35名，其中正式党员15名，到会15名，未到会有表决权书面意见0份，经无记名投票表决，15人同意、0人反对、0人弃权，同意接收付宁远同志为中共预备党员。 | 本支部共有党员35名，其中正式党员15名，到会15名，未到会有表决权书面意见0份，经无记名投票表决，15人同意、0人反对、0人弃权，同意接收付宁远同志为中共预备党员。 | 本支部共有党员35名，其中正式党员15名，到会15名，未到会有表决权书面意见0份，经无记名投票表决，15人同意、0人反对、0人弃权，同意接收付宁远同志为中共预备党员。",
    "详细情况 | 在入党积极分子期间，付宁远同志在各方面持续进步，展现出积极向上的精神风貌。\n思想上，付宁远同志始终保持坚定的政治信仰，积极关注新华网、学习强国等权威媒体平台，及时了解国家大政方针和时事政治，深入学习党的创新理论和方针政策，不断增强对党的认同感和归属感，在思想上与党组织高度统一。\n学习竞赛上，付宁远同志勤勉刻苦，认真对待每一门课程的学习任务，积极学习专业知识，成绩优异。付宁远同志积极参加各类学科竞赛，获得过第十五届蓝桥杯软件赛省赛三等奖、2024“士信融天”大学生AI算法挑战赛一等奖等奖项。\n工作上，付宁远同志认真负责，担任2321大班副班长和软件学院学生会宣传媒体部干事，认真履行自己的职责，为同学们服务，在工作中注重团队合作，善于倾听他人意见，不断提高自己的工作效率和质量。\n社会实践上，付宁远同志热心志愿，前往贵州开展支教活动，以饱满的热情和专业的知识为学生们讲解科学知识，以党员的标准要求自己，在志愿服务中践行党的全心全意为人民服务的宗旨，展现奉献精神和社会责任感。\n对于发展大会中指出的理论学习不够深入问题，付宁远同志主动加强理论学习，阅读党的经典著作，不断提高自己的理论水平。 | 在入党积极分子期间，付宁远同志在各方面持续进步，展现出积极向上的精神风貌。\n思想上，付宁远同志始终保持坚定的政治信仰，积极关注新华网、学习强国等权威媒体平台，及时了解国家大政方针和时事政治，深入学习党的创新理论和方针政策，不断增强对党的认同感和归属感，在思想上与党组织高度统一。\n学习竞赛上，付宁远同志勤勉刻苦，认真对待每一门课程的学习任务，积极学习专业知识，成绩优异。付宁远同志积极参加各类学科竞赛，获得过第十五届蓝桥杯软件赛省赛三等奖、2024“士信融天”大学生AI算法挑战赛一等奖等奖项。\n工作上，付宁远同志认真负责，担任2321大班副班长和软件学院学生会宣传媒体部干事，认真履行自己的职责，为同学们服务，在工作中注重团队合作，善于倾听他人意见，不断提高自己的工作效率和质量。\n社会实践上，付宁远同志热心志愿，前往贵州开展支教活动，以饱满的热情和专业的知识为学生们讲解科学知识，以党员的标准要求自己，在志愿服务中践行党的全心全意为人民服务的宗旨，展现奉献精神和社会责任感。\n对于发展大会中指出的理论学习不够深入问题，付宁远同志主动加强理论学习，阅读党的经典著作，不断提高自己的理论水平。 | 在入党积极分子期间，付宁远同志在各方面持续进步，展现出积极向上的精神风貌。\n思想上，付宁远同志始终保持坚定的政治信仰，积极关注新华网、学习强国等权威媒体平台，及时了解国家大政方针和时事政治，深入学习党的创新理论和方针政策，不断增强对党的认同感和归属感，在思想上与党组织高度统一。\n学习竞赛上，付宁远同志勤勉刻苦，认真对待每一门课程的学习任务，积极学习专业知识，成绩优异。付宁远同志积极参加各类学科竞赛，获得过第十五届蓝桥杯软件赛省赛三等奖、2024“士信融天”大学生AI算法挑战赛一等奖等奖项。\n工作上，付宁远同志认真负责，担任2321大班副班长和软件学院学生会宣传媒体部干事，认真履行自己的职责，为同学们服务，在工作中注重团队合作，善于倾听他人意见，不断提高自己的工作效率和质量。\n社会实践上，付宁远同志热心志愿，前往贵州开展支教活动，以饱满的热情和专业的知识为学生们讲解科学知识，以党员的标准要求自己，在志愿服务中践行党的全心全意为人民服务的宗旨，展现奉献精神和社会责任感。\n对于发展大会中指出的理论学习不够深入问题，付宁远同志主动加强理论学习，阅读党的经典著作，不断提高自己的理论水平。 | 在入党积极分子期间，付宁远同志在各方面持续进步，展现出积极向上的精神风貌。\n思想上，付宁远同志始终保持坚定的政治信仰，积极关注新华网、学习强国等权威媒体平台，及时了解国家大政方针和时事政治，深入学习党的创新理论和方针政策，不断增强对党的认同感和归属感，在思想上与党组织高度统一。\n学习竞赛上，付宁远同志勤勉刻苦，认真对待每一门课程的学习任务，积极学习专业知识，成绩优异。付宁远同志积极参加各类学科竞赛，获得过第十五届蓝桥杯软件赛省赛三等奖、2024“士信融天”大学生AI算法挑战赛一等奖等奖项。\n工作上，付宁远同志认真负责，担任2321大班副班长和软件学院学生会宣传媒体部干事，认真履行自己的职责，为同学们服务，在工作中注重团队合作，善于倾听他人意见，不断提高自己的工作效率和质量。\n社会实践上，付宁远同志热心志愿，前往贵州开展支教活动，以饱满的热情和专业的知识为学生们讲解科学知识，以党员的标准要求自己，在志愿服务中践行党的全心全意为人民服务的宗旨，展现奉献精神和社会责任感。\n对于发展大会中指出的理论学习不够深入问题，付宁远同志主动加强理论学习，阅读党的经典著作，不断提高自己的理论水平。 | 在入党积极分子期间，付宁远同志在各方面持续进步，展现出积极向上的精神风貌。\n思想上，付宁远同志始终保持坚定的政治信仰，积极关注新华网、学习强国等权威媒体平台，及时了解国家大政方针和时事政治，深入学习党的创新理论和方针政策，不断增强对党的认同感和归属感，在思想上与党组织高度统一。\n学习竞赛上，付宁远同志勤勉刻苦，认真对待每一门课程的学习任务，积极学习专业知识，成绩优异。付宁远同志积极参加各类学科竞赛，获得过第十五届蓝桥杯软件赛省赛三等奖、2024“士信融天”大学生AI算法挑战赛一等奖等奖项。\n工作上，付宁远同志认真负责，担任2321大班副班长和软件学院学生会宣传媒体部干事，认真履行自己的职责，为同学们服务，在工作中注重团队合作，善于倾听他人意见，不断提高自己的工作效率和质量。\n社会实践上，付宁远同志热心志愿，前往贵州开展支教活动，以饱满的热情和专业的知识为学生们讲解科学知识，以党员的标准要求自己，在志愿服务中践行党的全心全意为人民服务的宗旨，展现奉献精神和社会责任感。\n对于发展大会中指出的理论学习不够深入问题，付宁远同志主动加强理论学习，阅读党的经典著作，不断提高自己的理论水平。 | 在入党积极分子期间，付宁远同志在各方面持续进步，展现出积极向上的精神风貌。\n思想上，付宁远同志始终保持坚定的政治信仰，积极关注新华网、学习强国等权威媒体平台，及时了解国家大政方针和时事政治，深入学习党的创新理论和方针政策，不断增强对党的认同感和归属感，在思想上与党组织高度统一。\n学习竞赛上，付宁远同志勤勉刻苦，认真对待每一门课程的学习任务，积极学习专业知识，成绩优异。付宁远同志积极参加各类学科竞赛，获得过第十五届蓝桥杯软件赛省赛三等奖、2024“士信融天”大学生AI算法挑战赛一等奖等奖项。\n工作上，付宁远同志认真负责，担任2321大班副班长和软件学院学生会宣传媒体部干事，认真履行自己的职责，为同学们服务，在工作中注重团队合作，善于倾听他人意见，不断提高自己的工作效率和质量。\n社会实践上，付宁远同志热心志愿，前往贵州开展支教活动，以饱满的热情和专业的知识为学生们讲解科学知识，以党员的标准要求自己，在志愿服务中践行党的全心全意为人民服务的宗旨，展现奉献精神和社会责任感。\n对于发展大会中指出的理论学习不够深入问题，付宁远同志主动加强理论学习，阅读党的经典著作，不断提高自己的理论水平。",
    "“向党推优”登记表",
    "姓名 | 付宁远 | 性别 | 女 | 学号 | 23373125 | 民族 | 汉族",
    "出生年月 | 出生年月 | 2005.04.20 | 2005.04.20 | 现任职务 | 现任职务 | 无 | 无",
    "思想汇报次数 | 思想汇报次数 | 6 | 6 | 确立为入党\n积极分子时间 | 确立为入党\n积极分子时间 | 2023.10.02 | 2023.10.02",
    "获得北航校级结业证书时间 | 获得北航校级结业证书时间 | 获得北航校级结业证书时间 | 获得北航校级结业证书时间 | 2024年  12  月 | 2024年  12  月 | 2024年  12  月 | 2024年  12  月",
    "团内奖励 | 团内奖励 | 无 | 无 | 无 | 无 | 无 | 无",
    "自我鉴定 | 自我鉴定 | 我积极向党组织靠拢，努力学习习近平新时代中国特色社会主义思想。我坚决拥护中国共产党的领导，认识到党的领导是中国特色社会主义最本质的特征，是实现中华民族伟大复兴的根本保证。\n我深知，作为一名青年学生，肩负着时代赋予的责任和使命。我将坚定不移地听党话、跟党走，全面贯彻党的教育方针，努力成为一名德智体美劳全面发展的社会主义建设者和接班人。在未来的学习和工作中，我将继续发扬党的光荣传统和优良作风，为实现中华民族伟大复兴的中国梦而不懈奋斗。 | 我积极向党组织靠拢，努力学习习近平新时代中国特色社会主义思想。我坚决拥护中国共产党的领导，认识到党的领导是中国特色社会主义最本质的特征，是实现中华民族伟大复兴的根本保证。\n我深知，作为一名青年学生，肩负着时代赋予的责任和使命。我将坚定不移地听党话、跟党走，全面贯彻党的教育方针，努力成为一名德智体美劳全面发展的社会主义建设者和接班人。在未来的学习和工作中，我将继续发扬党的光荣传统和优良作风，为实现中华民族伟大复兴的中国梦而不懈奋斗。 | 我积极向党组织靠拢，努力学习习近平新时代中国特色社会主义思想。我坚决拥护中国共产党的领导，认识到党的领导是中国特色社会主义最本质的特征，是实现中华民族伟大复兴的根本保证。\n我深知，作为一名青年学生，肩负着时代赋予的责任和使命。我将坚定不移地听党话、跟党走，全面贯彻党的教育方针，努力成为一名德智体美劳全面发展的社会主义建设者和接班人。在未来的学习和工作中，我将继续发扬党的光荣传统和优良作风，为实现中华民族伟大复兴的中国梦而不懈奋斗。 | 我积极向党组织靠拢，努力学习习近平新时代中国特色社会主义思想。我坚决拥护中国共产党的领导，认识到党的领导是中国特色社会主义最本质的特征，是实现中华民族伟大复兴的根本保证。\n我深知，作为一名青年学生，肩负着时代赋予的责任和使命。我将坚定不移地听党话、跟党走，全面贯彻党的教育方针，努力成为一名德智体美劳全面发展的社会主义建设者和接班人。在未来的学习和工作中，我将继续发扬党的光荣传统和优良作风，为实现中华民族伟大复兴的中国梦而不懈奋斗。 | 我积极向党组织靠拢，努力学习习近平新时代中国特色社会主义思想。我坚决拥护中国共产党的领导，认识到党的领导是中国特色社会主义最本质的特征，是实现中华民族伟大复兴的根本保证。\n我深知，作为一名青年学生，肩负着时代赋予的责任和使命。我将坚定不移地听党话、跟党走，全面贯彻党的教育方针，努力成为一名德智体美劳全面发展的社会主义建设者和接班人。在未来的学习和工作中，我将继续发扬党的光荣传统和优良作风，为实现中华民族伟大复兴的中国梦而不懈奋斗。 | 我积极向党组织靠拢，努力学习习近平新时代中国特色社会主义思想。我坚决拥护中国共产党的领导，认识到党的领导是中国特色社会主义最本质的特征，是实现中华民族伟大复兴的根本保证。\n我深知，作为一名青年学生，肩负着时代赋予的责任和使命。我将坚定不移地听党话、跟党走，全面贯彻党的教育方针，努力成为一名德智体美劳全面发展的社会主义建设者和接班人。在未来的学习和工作中，我将继续发扬党的光荣传统和优良作风，为实现中华民族伟大复兴的中国梦而不懈奋斗。",
    "有无重大政治\n历史问题\n结论如何 | 无",
    "团支部大会决议 | 付宁远 同学，经过答辩，赞成 28 票，反对 0 票，弃权 0 票，超过 1/2，决定推荐其作为党的发展对象。\n\n签字：            日期：2025.04.09",
    "分团委意见 | 签字（盖章）：        日期：",
    "校团委意见 | 签字（盖章）：        日期：",
    "马克思《关于费尔巴哈的提纲》的实践哲学与数字时代启示",
    "当我在深夜的机房调试一段算法，或是在产品迭代中根据用户反馈重构代码时，这些看似普通的技术实践，实则暗含着马克思在《关于费尔巴哈的提纲》中揭示的哲学真谛。这份写于1845年的思想纲领，以其革命性的实践观穿透时空，为数字时代的软件开发者提供了理解技术与社会关系的钥匙。从敏捷开发中的持续集成到人工智能伦理的探讨，从开源运动的协作模式到元宇宙的社会关系重构，马克思的实践哲学始终照耀着技术革命的深层逻辑。",
    "实践观：从需求分析到代码落地的认知飞跃",
    "马克思在第一条提纲中批判旧唯物主义\"只是从客体的或者直观的形式去理解\"现实，这一洞见直指传统软件工程教育中的认知局限。在软工课程中，我往往陷入\"完美主义陷阱\"：试图通过UML图穷尽所有需求，用数学证明保证算法绝对正确。但真实的软件开发实践告诉我们，唯有通过持续集成、灰度测试、用户反馈等动态实践，才能让抽象的设计落地为可用产品。某团队开发校园二手交易平台时，初期设计的复杂信用评价体系在实际运营中遭遇冷遇，最终通过七次版本迭代简化为\"即时聊天+交易互评\"机制，这正是马克思所说\"人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题\"（第二条）的生动体现。",
    "在人工智能领域，这种实践转向更为明显。深度学习模型的训练不是单纯的理论推演，而是在数据清洗、参数调整、结果验证的往复实践中逐渐逼近最优解。AlphaGo的开发者不会预先设定所有棋局策略，而是让算法在数百万局自我对弈的实践中进化出超越人类直觉的棋感。这种\"实践-反馈-迭代\"的认知模式，彻底打破了传统认识论中主客二分的思维定式。",
    "人的本质：开源社区中的关系重构",
    "马克思关于\"人的本质是一切社会关系的总和\"（第六条）的论断，在GitHub的开源协作中展现出数字时代的全新样态。当软件学院学生参与Apache项目时，他们的技术身份不再局限于学生证上的专业标签，而是在代码提交、issue讨论、PR评审中形成的多重关系节点。一个00后开发者可能同时是某框架的核心维护者、技术论坛的版主以及线上黑客马拉松的导师，这种数字化的社会关系网络既拓展了人的本质内涵，也提出了新挑战：当算法推荐塑造信息茧房，当远程协作淡化情感连接，如何通过技术实践重建真实的社会关系？",
    "某校软件团队开发的\"线上结对编程平台\"给出了启示。该系统不仅提供代码协作功能，还通过智能匹配构建跨校技术社群，在疫情期间促成多个高校联合开发防疫管理系统。这种基于技术实践形成的新型社会关系，印证了马克思\"社会生活在本质上是实践的\"（第八条）的深刻判断，揭示出数字时代人的本质力量通过技术实践不断对象化的现实路径。",
    "真理标准：软件工程中的实践检验",
    "马克思在第二条提纲中强调的实践检验原则，在软件测试领域获得最直接的印证。某团队开发智能作业批改系统时，初期基于规则引擎的设计在实验室测试中准确率达到98%，但在真实教学场景中，面对学生个性化的解题路径，系统识别率骤降至72%。通过收集3000份作业样本进行模型再训练，并引入教师人工复核机制，最终形成了\"AI初筛+人工校准\"的混合模式。这个过程完美诠释了\"人应该在实践中证明自己思维的真理性\"——任何技术方案的有效性都不能停留在理论推演，必须经受真实场景的实践检验。",
    "这种实践优先的原则同样适用于技术伦理领域。当开发人脸识别系统时，不能仅用准确率作为唯一标准，必须通过社区调研、伦理审查、弱势群体测试等社会实践，才能确认真理的全面性。某高校伦理委员会叫停图书馆人脸识别项目的案例表明，技术真理性的证明需要多维度的社会实践参与。",
    "改变世界：代码实践的社会变革力量",
    "\"哲学家们只是用不同的方式解释世界，问题在于改变世界\"（第十一条），马克思的这句宣言在数字时代获得前所未有的实践场域。美团外卖、饿了么等外卖软件使我们可以足不出户享受各种美食；微信、QQ等社交媒体使我们可以摆脱空间的限制，和远在异国他乡的朋友谈天说地。这些看似微小的技术实践，实则是通过代码重构社会运行方式的革命性尝试。",
    "在更宏观的层面，我们正以技术实践回应时代命题：用联邦学习破解数据隐私困境，用数字孪生技术优化城市规划，用共识算法探索分布式治理模式。这些实践不仅改变着世界的技术面貌，更在重塑生产关系和社会结构，展现出马克思实践哲学在数字文明中的蓬勃生命力。",
    "从《关于费尔巴哈的提纲》到Visual Studio代码编辑器，从19世纪的哲学革命到21世纪的技术革命，实践始终是连接思想与现实的桥梁。作为软件学院的学生，我们每天书写的代码既是逻辑的演绎，更是社会实践的物质载体：每行代码都可能影响用户体验，每个算法都在参与社会关系的建构，每个技术决策都蕴含着价值判断。在这个虚实交融的时代，我们既要警惕\"技术决定论\"的迷思，也要避免陷入\"代码乌托邦\"的幻想，始终牢记马克思的实践方法论——在开源协作中构建社会关系，在用户场景中检验技术真理，在解决现实问题中实现改变世界的终极理想。当我们以实践哲学指导技术创造时，编译器的报错提示将不再是单纯的技术障碍，而是通向更美好世界的实践路标。",
    "马克思《关于费尔巴哈的提纲》的实践哲学与数字时代启示",
    "当我在深夜的机房调试一段算法，或是在产品迭代中根据用户反馈重构代码时，这些看似普通的技术实践，实则暗含着马克思在《关于费尔巴哈的提纲》中揭示的哲学真谛。这份写于1845年的思想纲领，以其革命性的实践观穿透时空，为数字时代的软件开发者提供了理解技术与社会关系的钥匙。从敏捷开发中的持续集成到人工智能伦理的探讨，从开源运动的协作模式到元宇宙的社会关系重构，马克思的实践哲学始终照耀着技术革命的深层逻辑。",
    "实践观：从需求分析到代码落地的认知飞跃",
    "马克思在第一条提纲中批判旧唯物主义\"只是从客体的或者直观的形式去理解\"现实，这一洞见直指传统软件工程教育中的认知局限。在软工课程中，我往往陷入\"完美主义陷阱\"：试图通过UML图穷尽所有需求，用数学证明保证算法绝对正确。但真实的软件开发实践告诉我们，唯有通过持续集成、灰度测试、用户反馈等动态实践，才能让抽象的设计落地为可用产品。某团队开发校园二手交易平台时，初期设计的复杂信用评价体系在实际运营中遭遇冷遇，最终通过七次版本迭代简化为\"即时聊天+交易互评\"机制，这正是马克思所说\"人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题\"（第二条）的生动体现。",
    "在人工智能领域，这种实践转向更为明显。深度学习模型的训练不是单纯的理论推演，而是在数据清洗、参数调整、结果验证的往复实践中逐渐逼近最优解。AlphaGo的开发者不会预先设定所有棋局策略，而是让算法在数百万局自我对弈的实践中进化出超越人类直觉的棋感。这种\"实践-反馈-迭代\"的认知模式，彻底打破了传统认识论中主客二分的思维定式。",
    "人的本质：开源社区中的关系重构",
    "马克思关于\"人的本质是一切社会关系的总和\"（第六条）的论断，在GitHub的开源协作中展现出数字时代的全新样态。当软件学院学生参与Apache项目时，他们的技术身份不再局限于学生证上的专业标签，而是在代码提交、issue讨论、PR评审中形成的多重关系节点。一个00后开发者可能同时是某框架的核心维护者、技术论坛的版主以及线上黑客马拉松的导师，这种数字化的社会关系网络既拓展了人的本质内涵，也提出了新挑战：当算法推荐塑造信息茧房，当远程协作淡化情感连接，如何通过技术实践重建真实的社会关系？",
    "某校软件团队开发的\"线上结对编程平台\"给出了启示。该系统不仅提供代码协作功能，还通过智能匹配构建跨校技术社群，在疫情期间促成多个高校联合开发防疫管理系统。这种基于技术实践形成的新型社会关系，印证了马克思\"社会生活在本质上是实践的\"（第八条）的深刻判断，揭示出数字时代人的本质力量通过技术实践不断对象化的现实路径。",
    "真理标准：软件工程中的实践检验",
    "马克思在第二条提纲中强调的实践检验原则，在软件测试领域获得最直接的印证。某团队开发智能作业批改系统时，初期基于规则引擎的设计在实验室测试中准确率达到98%，但在真实教学场景中，面对学生个性化的解题路径，系统识别率骤降至72%。通过收集3000份作业样本进行模型再训练，并引入教师人工复核机制，最终形成了\"AI初筛+人工校准\"的混合模式。这个过程完美诠释了\"人应该在实践中证明自己思维的真理性\"——任何技术方案的有效性都不能停留在理论推演，必须经受真实场景的实践检验。",
    "这种实践优先的原则同样适用于技术伦理领域。当开发人脸识别系统时，不能仅用准确率作为唯一标准，必须通过社区调研、伦理审查、弱势群体测试等社会实践，才能确认真理的全面性。某高校伦理委员会叫停图书馆人脸识别项目的案例表明，技术真理性的证明需要多维度的社会实践参与。",
    "改变世界：代码实践的社会变革力量",
    "\"哲学家们只是用不同的方式解释世界，问题在于改变世界\"（第十一条），马克思的这句宣言在数字时代获得前所未有的实践场域。美团外卖、饿了么等外卖软件使我们可以足不出户享受各种美食；微信、QQ等社交媒体使我们可以摆脱空间的限制，和远在异国他乡的朋友谈天说地。这些看似微小的技术实践，实则是通过代码重构社会运行方式的革命性尝试。",
    "在更宏观的层面，我们正以技术实践回应时代命题：用联邦学习破解数据隐私困境，用数字孪生技术优化城市规划，用共识算法探索分布式治理模式。这些实践不仅改变着世界的技术面貌，更在重塑生产关系和社会结构，展现出马克思实践哲学在数字文明中的蓬勃生命力。",
    "从《关于费尔巴哈的提纲》到Visual Studio代码编辑器，从19世纪的哲学革命到21世纪的技术革命，实践始终是连接思想与现实的桥梁。作为软件学院的学生，我们每天书写的代码既是逻辑的演绎，更是社会实践的物质载体：每行代码都可能影响用户体验，每个算法都在参与社会关系的建构，每个技术决策都蕴含着价值判断。在这个虚实交融的时代，我们既要警惕\"技术决定论\"的迷思，也要避免陷入\"代码乌托邦\"的幻想，始终牢记马克思的实践方法论——在开源协作中构建社会关系，在用户场景中检验技术真理，在解决现实问题中实现改变世界的终极理想。当我们以实践哲学指导技术创造时，编译器的报错提示将不再是单纯的技术障碍，而是通向更美好世界的实践路标。",
    "马克思《关于费尔巴哈的提纲》的实践哲学与数字时代启示",
    "当我在深夜的机房调试一段算法，或是在产品迭代中根据用户反馈重构代码时，这些看似普通的技术实践，实则暗含着马克思在《关于费尔巴哈的提纲》中揭示的哲学真谛。这份写于1845年的思想纲领，以其革命性的实践观穿透时空，为数字时代的软件开发者提供了理解技术与社会关系的钥匙。从敏捷开发中的持续集成到人工智能伦理的探讨，从开源运动的协作模式到元宇宙的社会关系重构，马克思的实践哲学始终照耀着技术革命的深层逻辑。",
    "实践观：从需求分析到代码落地的认知飞跃",
    "马克思在第一条提纲中批判旧唯物主义\"只是从客体的或者直观的形式去理解\"现实，这一洞见直指传统软件工程教育中的认知局限。在软工课程中，我往往陷入\"完美主义陷阱\"：试图通过UML图穷尽所有需求，用数学证明保证算法绝对正确。但真实的软件开发实践告诉我们，唯有通过持续集成、灰度测试、用户反馈等动态实践，才能让抽象的设计落地为可用产品。某团队开发校园二手交易平台时，初期设计的复杂信用评价体系在实际运营中遭遇冷遇，最终通过七次版本迭代简化为\"即时聊天+交易互评\"机制，这正是马克思所说\"人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题\"（第二条）的生动体现。",
    "在人工智能领域，这种实践转向更为明显。深度学习模型的训练不是单纯的理论推演，而是在数据清洗、参数调整、结果验证的往复实践中逐渐逼近最优解。AlphaGo的开发者不会预先设定所有棋局策略，而是让算法在数百万局自我对弈的实践中进化出超越人类直觉的棋感。这种\"实践-反馈-迭代\"的认知模式，彻底打破了传统认识论中主客二分的思维定式。",
    "人的本质：开源社区中的关系重构",
    "马克思关于\"人的本质是一切社会关系的总和\"（第六条）的论断，在GitHub的开源协作中展现出数字时代的全新样态。当软件学院学生参与Apache项目时，他们的技术身份不再局限于学生证上的专业标签，而是在代码提交、issue讨论、PR评审中形成的多重关系节点。一个00后开发者可能同时是某框架的核心维护者、技术论坛的版主以及线上黑客马拉松的导师，这种数字化的社会关系网络既拓展了人的本质内涵，也提出了新挑战：当算法推荐塑造信息茧房，当远程协作淡化情感连接，如何通过技术实践重建真实的社会关系？",
    "某校软件团队开发的\"线上结对编程平台\"给出了启示。该系统不仅提供代码协作功能，还通过智能匹配构建跨校技术社群，在疫情期间促成多个高校联合开发防疫管理系统。这种基于技术实践形成的新型社会关系，印证了马克思\"社会生活在本质上是实践的\"（第八条）的深刻判断，揭示出数字时代人的本质力量通过技术实践不断对象化的现实路径。",
    "真理标准：软件工程中的实践检验",
    "马克思在第二条提纲中强调的实践检验原则，在软件测试领域获得最直接的印证。某团队开发智能作业批改系统时，初期基于规则引擎的设计在实验室测试中准确率达到98%，但在真实教学场景中，面对学生个性化的解题路径，系统识别率骤降至72%。通过收集3000份作业样本进行模型再训练，并引入教师人工复核机制，最终形成了\"AI初筛+人工校准\"的混合模式。这个过程完美诠释了\"人应该在实践中证明自己思维的真理性\"——任何技术方案的有效性都不能停留在理论推演，必须经受真实场景的实践检验。",
    "这种实践优先的原则同样适用于技术伦理领域。当开发人脸识别系统时，不能仅用准确率作为唯一标准，必须通过社区调研、伦理审查、弱势群体测试等社会实践，才能确认真理的全面性。某高校伦理委员会叫停图书馆人脸识别项目的案例表明，技术真理性的证明需要多维度的社会实践参与。",
    "改变世界：代码实践的社会变革力量",
    "\"哲学家们只是用不同的方式解释世界，问题在于改变世界\"（第十一条），马克思的这句宣言在数字时代获得前所未有的实践场域。美团外卖、饿了么等外卖软件使我们可以足不出户享受各种美食；微信、QQ等社交媒体使我们可以摆脱空间的限制，和远在异国他乡的朋友谈天说地。这些看似微小的技术实践，实则是通过代码重构社会运行方式的革命性尝试。",
    "在更宏观的层面，我们正以技术实践回应时代命题：用联邦学习破解数据隐私困境，用数字孪生技术优化城市规划，用共识算法探索分布式治理模式。这些实践不仅改变着世界的技术面貌，更在重塑生产关系和社会结构，展现出马克思实践哲学在数字文明中的蓬勃生命力。",
    "从《关于费尔巴哈的提纲》到Visual Studio代码编辑器，从19世纪的哲学革命到21世纪的技术革命，实践始终是连接思想与现实的桥梁。作为软件学院的学生，我们每天书写的代码既是逻辑的演绎，更是社会实践的物质载体：每行代码都可能影响用户体验，每个算法都在参与社会关系的建构，每个技术决策都蕴含着价值判断。在这个虚实交融的时代，我们既要警惕\"技术决定论\"的迷思，也要避免陷入\"代码乌托邦\"的幻想，始终牢记马克思的实践方法论——在开源协作中构建社会关系，在用户场景中检验技术真理，在解决现实问题中实现改变世界的终极理想。当我们以实践哲学指导技术创造时，编译器的报错提示将不再是单纯的技术障碍，而是通向更美好世界的实践路标。",
    "马克思《关于费尔巴哈的提纲》的实践哲学与数字时代启示",
    "当我在深夜的机房调试一段算法，或是在产品迭代中根据用户反馈重构代码时，这些看似普通的技术实践，实则暗含着马克思在《关于费尔巴哈的提纲》中揭示的哲学真谛。这份写于1845年的思想纲领，以其革命性的实践观穿透时空，为数字时代的软件开发者提供了理解技术与社会关系的钥匙。从敏捷开发中的持续集成到人工智能伦理的探讨，从开源运动的协作模式到元宇宙的社会关系重构，马克思的实践哲学始终照耀着技术革命的深层逻辑。",
    "实践观：从需求分析到代码落地的认知飞跃",
    "马克思在第一条提纲中批判旧唯物主义\"只是从客体的或者直观的形式去理解\"现实，这一洞见直指传统软件工程教育中的认知局限。在软工课程中，我往往陷入\"完美主义陷阱\"：试图通过UML图穷尽所有需求，用数学证明保证算法绝对正确。但真实的软件开发实践告诉我们，唯有通过持续集成、灰度测试、用户反馈等动态实践，才能让抽象的设计落地为可用产品。某团队开发校园二手交易平台时，初期设计的复杂信用评价体系在实际运营中遭遇冷遇，最终通过七次版本迭代简化为\"即时聊天+交易互评\"机制，这正是马克思所说\"人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题\"（第二条）的生动体现。",
    "在人工智能领域，这种实践转向更为明显。深度学习模型的训练不是单纯的理论推演，而是在数据清洗、参数调整、结果验证的往复实践中逐渐逼近最优解。AlphaGo的开发者不会预先设定所有棋局策略，而是让算法在数百万局自我对弈的实践中进化出超越人类直觉的棋感。这种\"实践-反馈-迭代\"的认知模式，彻底打破了传统认识论中主客二分的思维定式。",
    "人的本质：开源社区中的关系重构",
    "马克思关于\"人的本质是一切社会关系的总和\"（第六条）的论断，在GitHub的开源协作中展现出数字时代的全新样态。当软件学院学生参与Apache项目时，他们的技术身份不再局限于学生证上的专业标签，而是在代码提交、issue讨论、PR评审中形成的多重关系节点。一个00后开发者可能同时是某框架的核心维护者、技术论坛的版主以及线上黑客马拉松的导师，这种数字化的社会关系网络既拓展了人的本质内涵，也提出了新挑战：当算法推荐塑造信息茧房，当远程协作淡化情感连接，如何通过技术实践重建真实的社会关系？",
    "某校软件团队开发的\"线上结对编程平台\"给出了启示。该系统不仅提供代码协作功能，还通过智能匹配构建跨校技术社群，在疫情期间促成多个高校联合开发防疫管理系统。这种基于技术实践形成的新型社会关系，印证了马克思\"社会生活在本质上是实践的\"（第八条）的深刻判断，揭示出数字时代人的本质力量通过技术实践不断对象化的现实路径。",
    "真理标准：软件工程中的实践检验",
    "马克思在第二条提纲中强调的实践检验原则，在软件测试领域获得最直接的印证。某团队开发智能作业批改系统时，初期基于规则引擎的设计在实验室测试中准确率达到98%，但在真实教学场景中，面对学生个性化的解题路径，系统识别率骤降至72%。通过收集3000份作业样本进行模型再训练，并引入教师人工复核机制，最终形成了\"AI初筛+人工校准\"的混合模式。这个过程完美诠释了\"人应该在实践中证明自己思维的真理性\"——任何技术方案的有效性都不能停留在理论推演，必须经受真实场景的实践检验。",
    "这种实践优先的原则同样适用于技术伦理领域。当开发人脸识别系统时，不能仅用准确率作为唯一标准，必须通过社区调研、伦理审查、弱势群体测试等社会实践，才能确认真理的全面性。某高校伦理委员会叫停图书馆人脸识别项目的案例表明，技术真理性的证明需要多维度的社会实践参与。",
    "改变世界：代码实践的社会变革力量",
    "\"哲学家们只是用不同的方式解释世界，问题在于改变世界\"（第十一条），马克思的这句宣言在数字时代获得前所未有的实践场域。美团外卖、饿了么等外卖软件使我们可以足不出户享受各种美食；微信、QQ等社交媒体使我们可以摆脱空间的限制，和远在异国他乡的朋友谈天说地。这些看似微小的技术实践，实则是通过代码重构社会运行方式的革命性尝试。",
    "在更宏观的层面，我们正以技术实践回应时代命题：用联邦学习破解数据隐私困境，用数字孪生技术优化城市规划，用共识算法探索分布式治理模式。这些实践不仅改变着世界的技术面貌，更在重塑生产关系和社会结构，展现出马克思实践哲学在数字文明中的蓬勃生命力。",
    "从《关于费尔巴哈的提纲》到Visual Studio代码编辑器，从19世纪的哲学革命到21世纪的技术革命，实践始终是连接思想与现实的桥梁。作为软件学院的学生，我们每天书写的代码既是逻辑的演绎，更是社会实践的物质载体：每行代码都可能影响用户体验，每个算法都在参与社会关系的建构，每个技术决策都蕴含着价值判断。在这个虚实交融的时代，我们既要警惕\"技术决定论\"的迷思，也要避免陷入\"代码乌托邦\"的幻想，始终牢记马克思的实践方法论——在开源协作中构建社会关系，在用户场景中检验技术真理，在解决现实问题中实现改变世界的终极理想。当我们以实践哲学指导技术创造时，编译器的报错提示将不再是单纯的技术障碍，而是通向更美好世界的实践路标。",
    "马克思《关于费尔巴哈的提纲》的实践哲学与数字时代启示",
    "当我在深夜的机房调试一段算法，或是在产品迭代中根据用户反馈重构代码时，这些看似普通的技术实践，实则暗含着马克思在《关于费尔巴哈的提纲》中揭示的哲学真谛。这份写于1845年的思想纲领，以其革命性的实践观穿透时空，为数字时代的软件开发者提供了理解技术与社会关系的钥匙。从敏捷开发中的持续集成到人工智能伦理的探讨，从开源运动的协作模式到元宇宙的社会关系重构，马克思的实践哲学始终照耀着技术革命的深层逻辑。",
    "实践观：从需求分析到代码落地的认知飞跃",
    "马克思在第一条提纲中批判旧唯物主义\"只是从客体的或者直观的形式去理解\"现实，这一洞见直指传统软件工程教育中的认知局限。在软工课程中，我往往陷入\"完美主义陷阱\"：试图通过UML图穷尽所有需求，用数学证明保证算法绝对正确。但真实的软件开发实践告诉我们，唯有通过持续集成、灰度测试、用户反馈等动态实践，才能让抽象的设计落地为可用产品。某团队开发校园二手交易平台时，初期设计的复杂信用评价体系在实际运营中遭遇冷遇，最终通过七次版本迭代简化为\"即时聊天+交易互评\"机制，这正是马克思所说\"人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题\"（第二条）的生动体现。",
    "在人工智能领域，这种实践转向更为明显。深度学习模型的训练不是单纯的理论推演，而是在数据清洗、参数调整、结果验证的往复实践中逐渐逼近最优解。AlphaGo的开发者不会预先设定所有棋局策略，而是让算法在数百万局自我对弈的实践中进化出超越人类直觉的棋感。这种\"实践-反馈-迭代\"的认知模式，彻底打破了传统认识论中主客二分的思维定式。",
    "人的本质：开源社区中的关系重构",
    "马克思关于\"人的本质是一切社会关系的总和\"（第六条）的论断，在GitHub的开源协作中展现出数字时代的全新样态。当软件学院学生参与Apache项目时，他们的技术身份不再局限于学生证上的专业标签，而是在代码提交、issue讨论、PR评审中形成的多重关系节点。一个00后开发者可能同时是某框架的核心维护者、技术论坛的版主以及线上黑客马拉松的导师，这种数字化的社会关系网络既拓展了人的本质内涵，也提出了新挑战：当算法推荐塑造信息茧房，当远程协作淡化情感连接，如何通过技术实践重建真实的社会关系？",
    "某校软件团队开发的\"线上结对编程平台\"给出了启示。该系统不仅提供代码协作功能，还通过智能匹配构建跨校技术社群，在疫情期间促成多个高校联合开发防疫管理系统。这种基于技术实践形成的新型社会关系，印证了马克思\"社会生活在本质上是实践的\"（第八条）的深刻判断，揭示出数字时代人的本质力量通过技术实践不断对象化的现实路径。",
    "真理标准：软件工程中的实践检验",
    "马克思在第二条提纲中强调的实践检验原则，在软件测试领域获得最直接的印证。某团队开发智能作业批改系统时，初期基于规则引擎的设计在实验室测试中准确率达到98%，但在真实教学场景中，面对学生个性化的解题路径，系统识别率骤降至72%。通过收集3000份作业样本进行模型再训练，并引入教师人工复核机制，最终形成了\"AI初筛+人工校准\"的混合模式。这个过程完美诠释了\"人应该在实践中证明自己思维的真理性\"——任何技术方案的有效性都不能停留在理论推演，必须经受真实场景的实践检验。",
    "这种实践优先的原则同样适用于技术伦理领域。当开发人脸识别系统时，不能仅用准确率作为唯一标准，必须通过社区调研、伦理审查、弱势群体测试等社会实践，才能确认真理的全面性。某高校伦理委员会叫停图书馆人脸识别项目的案例表明，技术真理性的证明需要多维度的社会实践参与。",
    "改变世界：代码实践的社会变革力量",
    "\"哲学家们只是用不同的方式解释世界，问题在于改变世界\"（第十一条），马克思的这句宣言在数字时代获得前所未有的实践场域。美团外卖、饿了么等外卖软件使我们可以足不出户享受各种美食；微信、QQ等社交媒体使我们可以摆脱空间的限制，和远在异国他乡的朋友谈天说地。这些看似微小的技术实践，实则是通过代码重构社会运行方式的革命性尝试。",
    "在更宏观的层面，我们正以技术实践回应时代命题：用联邦学习破解数据隐私困境，用数字孪生技术优化城市规划，用共识算法探索分布式治理模式。这些实践不仅改变着世界的技术面貌，更在重塑生产关系和社会结构，展现出马克思实践哲学在数字文明中的蓬勃生命力。",
    "从《关于费尔巴哈的提纲》到Visual Studio代码编辑器，从19世纪的哲学革命到21世纪的技术革命，实践始终是连接思想与现实的桥梁。作为软件学院的学生，我们每天书写的代码既是逻辑的演绎，更是社会实践的物质载体：每行代码都可能影响用户体验，每个算法都在参与社会关系的建构，每个技术决策都蕴含着价值判断。在这个虚实交融的时代，我们既要警惕\"技术决定论\"的迷思，也要避免陷入\"代码乌托邦\"的幻想，始终牢记马克思的实践方法论——在开源协作中构建社会关系，在用户场景中检验技术真理，在解决现实问题中实现改变世界的终极理想。当我们以实践哲学指导技术创造时，编译器的报错提示将不再是单纯的技术障碍，而是通向更美好世界的实践路标。",
    "马克思《关于费尔巴哈的提纲》的实践哲学与数字时代启示",
    "当我在深夜的机房调试一段算法，或是在产品迭代中根据用户反馈重构代码时，这些看似普通的技术实践，实则暗含着马克思在《关于费尔巴哈的提纲》中揭示的哲学真谛。这份写于1845年的思想纲领，以其革命性的实践观穿透时空，为数字时代的软件开发者提供了理解技术与社会关系的钥匙。从敏捷开发中的持续集成到人工智能伦理的探讨，从开源运动的协作模式到元宇宙的社会关系重构，马克思的实践哲学始终照耀着技术革命的深层逻辑。",
    "实践观：从需求分析到代码落地的认知飞跃",
    "马克思在第一条提纲中批判旧唯物主义\"只是从客体的或者直观的形式去理解\"现实，这一洞见直指传统软件工程教育中的认知局限。在软工课程中，我往往陷入\"完美主义陷阱\"：试图通过UML图穷尽所有需求，用数学证明保证算法绝对正确。但真实的软件开发实践告诉我们，唯有通过持续集成、灰度测试、用户反馈等动态实践，才能让抽象的设计落地为可用产品。某团队开发校园二手交易平台时，初期设计的复杂信用评价体系在实际运营中遭遇冷遇，最终通过七次版本迭代简化为\"即时聊天+交易互评\"机制，这正是马克思所说\"人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题\"（第二条）的生动体现。",
    "在人工智能领域，这种实践转向更为明显。深度学习模型的训练不是单纯的理论推演，而是在数据清洗、参数调整、结果验证的往复实践中逐渐逼近最优解。AlphaGo的开发者不会预先设定所有棋局策略，而是让算法在数百万局自我对弈的实践中进化出超越人类直觉的棋感。这种\"实践-反馈-迭代\"的认知模式，彻底打破了传统认识论中主客二分的思维定式。",
    "人的本质：开源社区中的关系重构",
    "马克思关于\"人的本质是一切社会关系的总和\"（第六条）的论断，在GitHub的开源协作中展现出数字时代的全新样态。当软件学院学生参与Apache项目时，他们的技术身份不再局限于学生证上的专业标签，而是在代码提交、issue讨论、PR评审中形成的多重关系节点。一个00后开发者可能同时是某框架的核心维护者、技术论坛的版主以及线上黑客马拉松的导师，这种数字化的社会关系网络既拓展了人的本质内涵，也提出了新挑战：当算法推荐塑造信息茧房，当远程协作淡化情感连接，如何通过技术实践重建真实的社会关系？",
    "某校软件团队开发的\"线上结对编程平台\"给出了启示。该系统不仅提供代码协作功能，还通过智能匹配构建跨校技术社群，在疫情期间促成多个高校联合开发防疫管理系统。这种基于技术实践形成的新型社会关系，印证了马克思\"社会生活在本质上是实践的\"（第八条）的深刻判断，揭示出数字时代人的本质力量通过技术实践不断对象化的现实路径。",
    "真理标准：软件工程中的实践检验",
    "马克思在第二条提纲中强调的实践检验原则，在软件测试领域获得最直接的印证。某团队开发智能作业批改系统时，初期基于规则引擎的设计在实验室测试中准确率达到98%，但在真实教学场景中，面对学生个性化的解题路径，系统识别率骤降至72%。通过收集3000份作业样本进行模型再训练，并引入教师人工复核机制，最终形成了\"AI初筛+人工校准\"的混合模式。这个过程完美诠释了\"人应该在实践中证明自己思维的真理性\"——任何技术方案的有效性都不能停留在理论推演，必须经受真实场景的实践检验。",
    "这种实践优先的原则同样适用于技术伦理领域。当开发人脸识别系统时，不能仅用准确率作为唯一标准，必须通过社区调研、伦理审查、弱势群体测试等社会实践，才能确认真理的全面性。某高校伦理委员会叫停图书馆人脸识别项目的案例表明，技术真理性的证明需要多维度的社会实践参与。",
    "改变世界：代码实践的社会变革力量",
    "\"哲学家们只是用不同的方式解释世界，问题在于改变世界\"（第十一条），马克思的这句宣言在数字时代获得前所未有的实践场域。美团外卖、饿了么等外卖软件使我们可以足不出户享受各种美食；微信、QQ等社交媒体使我们可以摆脱空间的限制，和远在异国他乡的朋友谈天说地。这些看似微小的技术实践，实则是通过代码重构社会运行方式的革命性尝试。",
    "在更宏观的层面，我们正以技术实践回应时代命题：用联邦学习破解数据隐私困境，用数字孪生技术优化城市规划，用共识算法探索分布式治理模式。这些实践不仅改变着世界的技术面貌，更在重塑生产关系和社会结构，展现出马克思实践哲学在数字文明中的蓬勃生命力。",
    "从《关于费尔巴哈的提纲》到Visual Studio代码编辑器，从19世纪的哲学革命到21世纪的技术革命，实践始终是连接思想与现实的桥梁。作为软件学院的学生，我们每天书写的代码既是逻辑的演绎，更是社会实践的物质载体：每行代码都可能影响用户体验，每个算法都在参与社会关系的建构，每个技术决策都蕴含着价值判断。在这个虚实交融的时代，我们既要警惕\"技术决定论\"的迷思，也要避免陷入\"代码乌托邦\"的幻想，始终牢记马克思的实践方法论——在开源协作中构建社会关系，在用户场景中检验技术真理，在解决现实问题中实现改变世界的终极理想。当我们以实践哲学指导技术创造时，编译器的报错提示将不再是单纯的技术障碍，而是通向更美好世界的实践路标。",
    "挑战性任务\n难点分析\n2\n路径解析与工作目录管理\n2.1\n1. 相对路径解析：\n 需要实现完整的路径规范化算法，处理 . （当前目录）和 \u0000\u0000 （上级目录）\n 路径拼接时需考虑边界情况： /dir1/ + \u0000\u0000/dir2 → /dir2\n 特殊路径处理：空路径应视为当前目录， / 开头的为绝对路径\n2. 进程工作目录维护：\n 在PCB中新增 cwd 字段存储当前工作目录\n fork时需复制父进程工作目录到子进程\n 系统调用（open/mkdir等）需支持相对路径解析\n3. 错误处理复杂性：\n 区分路径不存在和路径非目录的错误\n 多级目录创建时的递归错误处理（mkdir -p）\n环境变量系统实现\n2.2\n1. 变量作用域管理：\n 局部变量与环境变量（-x）的存储分离\n 环境变量继承机制：fork时复制父进程环境变量\n2. 变量替换处理：\n 词法分析阶段识别 $VAR 并替换为值\n 处理边界情况： echo $VAR1$VAR2 → 连续变量替换\n3. 只读变量保护：\n 设置只读标志位（-r）\n 在declare/unset操作前检查只读状态\n输入系统增强\n2.3\n1. 行编辑实现：\n 维护光标位置和命令缓冲区\n 特殊键处理：箭头键（ESC序列）、组合键（Ctrl+字母）",
    "2. 历史指令系统：\n 环形缓冲区存储历史指令（HISTFILESIZE=20）\n 上下键遍历时维护当前索引状态\n 文件持久化：启动时加载.mos_history，退出时保存\n3. 实时显示刷新：\n 光标移动时的终端控制序列（ANSI escape codes）\n 内容修改时的局部刷新优化\n语法解析扩展\n2.4\n1. 命令替换（反引号）：\n 嵌套执行解析： echo ls `pwd``\n 输出捕获和替换（替换时需删除末尾换行符）\n2. 条件执行逻辑：\n &&/|| 的短路求值实现\n 命令返回值传递：修改exit系统调用返回状态码\n3. 注释和指令分隔：\n # 注释的即时剔除（保留原始命令供历史记录）\n ; 分隔符的多命令顺序执行\n实验体会\n3\n通过本次Shell增强实验，获得了以下深刻体会：\n1. 模块化设计的重要性：\n 采用分层架构（输入处理→词法分析→语法解析→执行）大幅降低复杂度\n 环境变量模块与路径解析模块解耦，便于独立测试\n2. 边界情况处理挑战：\n 路径解析时遇到 /\u0000\u0000/ 需规范化为 /\n 反引号嵌套执行时避免无限递归\n 变量替换后命令长度可能超过原缓冲区大小\n3. 历史指令实现的启发：\n 采用环形缓冲区避免频繁内存分配\n 历史文件持久化时处理并发访问（加锁机制）\n 上下键遍历时的状态机设计\n4. 终端交互的复杂性：",
    " 光标移动涉及终端控制序列（\\x1b[A, \\x1b[B等）\n 中文等多字节字符处理需要特殊考虑\n 退格键在行首/行尾的边界行为\n5. Shell设计的深度认知：\n 理解了环境变量继承的进程间通信本质\n 认识到条件执行（&&/||）是语法糖而非特殊命令\n 体会到管道和重定向在进程创建前完成的重要性\n本实验让我深刻理解了现代Shell的复杂性和精巧设计，尤其是路径解析和环境管理这两\n个基础功能的重要性。通过实现历史记录和行编辑功能，更加体会到用户友好性背后的\n技术挑战。整个项目强化了系统编程和模块化设计能力，为后续操作系统开发打下坚实\n基础。\n原创说明\n4\n参考：\n北航2025 OS shell挑战性任务实现指导 | Lazyfish & chilly_river\nBUAA-OS-shell | wrongization",
    "数字经济时代个人信息安全的法律保护研究",
    "——基于网络游戏与虚拟主播行业的实证分析",
    "姓名：付宁远",
    "学号：23373125",
    "摘要",
    "数字经济时代来临，网络游戏、虚拟主播等数字时代的新产物受到全民热切追捧，个人信息安全保护问题也随之成为社会公众关注焦点。“虚拟主播开盒”“无限暖暖封禁事件”及《哈利波特：魔法觉醒》个人信息所有权之争等事件均以《网络安全法》[1]《个人信息保护法》[2]等法律制度为切入点，反映出现行法律制度不完善、数字时代人的权利保护无法适应时代发展需求、用户协议格式条款效力范围争议、虚拟财产法律属性不清、技术滥用责任认定不落地等问题，提出以政府监管为指引，平台责任为保障，用户赋权为救济，构建数字时代个人信息安全保护法律规范新路径，为我国个人信息安全保护立法路径提供理论参考。",
    "关键字：信息安全法；虚拟财产；用户协议；开盒攻击；个人信息保护",
    "数字权益保护的时代命题",
    "数字科技加速网络游戏、虚拟主播行业成为数字经济重要的一环。中国互联网络信息中心在第 52 次统计报告中显示，截至 2023 年 6 月，我国网民规模为 6.68 亿人，占网民整体的 62.3%，网络直播用户规模达 7.65 亿人，增长 8.2%。这是一张数字产业产值的账单，也是一张数字背后潜藏风险的账单，在数字经济与实体经济融合的发展背景下，用户的个人信息面临着前所未有的风险。",
    "网游行业中许多企业，都利用复杂的用户协议，片面规定数据处理规则。《王者荣耀》等游戏的用户协议[12]中写有“3年内未使用该游戏账号登录相应腾讯游戏，腾讯有权在提前通知的情况下，对该账号及其账号下的游戏数据及相关信息采取删除等处置措施”，而且协议还非常不通俗易懂，术语满满，玩家都只是勾选同意，并不会仔细看，这样一来，数据控制权都集中在企业手里。",
    "中国消费者协会曾在2023年做过一个调查，其中有89.6%的玩家从未仔细阅读过用户协议，且72%的用户协议中都有关于企业单方面收集、使用、处理的权利的描述。不对等的权利，导致玩家虚拟财产的保护只能寄希望于企业的自觉，而不能寄希望于法律对企业行为的制约。",
    "虚拟主播产业的火爆滋生了滥用技术“开盒”风险。以生成对抗网络（Generative Adversarial Networks，GAN）为代表的人工智能合成技术的泛滥在赋予虚拟主播高还原性的同时，也为“开盒”提供了技术支持。2023年1-6月，公安机关共查办“开盒”案件2300余起，比去年同期增长2.4倍。不法分子利用技术抓取个人生物识别信息，利用人工智能伪装身份，甚至通过暗网进行“开盒”售卖获利。一个犯罪团伙利用直播平台的技术安全漏洞采集10万条人脸数据，借助人工智能技术合成虚拟主播，将其伪装后以“定制专属女朋友”的形式在境外社交平台售卖，非法牟利。技术滥用带来个人隐私信息与网络身份安全风险。",
    "虚拟财产纠纷高发，法律滞后。2023年，玩家在《哈利波特：魔法觉醒》的虚拟财产案就是因该公司认为其“钻了空子”且获取了相应利润，强制没收了20万元游戏道具的虚拟道具。在该案中，企业行为是否违法，财产是否被没收，玩家并不能有效证明操作行为的正当性，对虚拟财产的价值也缺乏有效的衡量标准。该案的虚拟财产属性缺乏法律定论，电子证据证明缺乏规则。",
    "北京互联网法院在近日公布的2023年《涉游戏案件审判白皮书》[14]中提到，近三年来，60%以上的涉虚拟财产纠纷因证据不足、价值认定难等原因调解结案，仅12%的涉虚拟财产纠纷案件作出确权判决。",
    "对标国际规制经验，我国的法律规制尚有进一步提升空间。韩国《游戏产业振兴法案》中规定了游戏运营商至少要保留用户游戏休眠账号3年以上，并于30日之前以电子邮件或短信的方式通知用户；欧盟《数字服务法》[10]中要求平台需要公示算法推荐结果并建立用户投诉的快速反应机制。我国《民法典》[3]127 条中首次将虚拟财产纳入法律保护范围，但由于缺乏细则，司法裁判不统一不利于用户利益与行业全球化发展。",
    "虚拟主播技术伦理缺位导致法律规制更“棘手”。虚拟主播行业增强拟人合成技术本质是借助算法对现实世界进行模拟重建，若被用于身份伪造和信息篡改，其社会危害性将成“几何”式增长。2023年一直播平台发生一起“AI换脸诈骗”案，不法分子通过开源框架DeepFaceLab换上主播的脸，让粉丝向其打赏，诈骗金额超过500万余元。该案暴露出技术开发者的责任边界不清、平台审查制度失效等问题。只有《刑法》第253条才能直接追究犯罪行为人，但对技术提供者的规制只停留在法律原则层面，缺乏具体追责路径。",
    "数字时代，数字权益保护是时代的命题。面对格式协议之下的权利失衡、技术滥用之下的权利威胁、虚拟财产立法保护之下的法律虚无等风险，如何构建一个前瞻性、可行的法律治理结构，已经势在必行。这不仅是千百万用户的利益所在，更是整个数字经济可持续发展的制度基础。从上述几个典型意义的案例所遭遇的法律疑难中我们可以看到，技术变革与权利保障之间的内在矛盾，也是对法律制度的“大考”。",
    "游戏账号注销机制的合法性争议",
    "2023年的“无限暖暖账号被清空案”是关于数字经济下用户信息保护的典型案例。“无限暖暖”在服务协议中规定，若连续3天未登录，将清空绑定角色，某位出国留学、暂停游戏的玩家发现自己的3年游戏时间、花费5万人民币的限定服装、装备等清空后，当即提起诉讼，在上海市浦东新区人民法院起诉《无限暖暖》。《无限暖暖》以大号加粗字体显示协议，在注册时仅采取默认勾选的方式获得用户同意，未采取有效提示、二次确认等方式，依据《民法典》[3]第四百九十六条，该协议约定不成立，不产生任何法律效力。",
    "这一事件中存在两个法律问题。首先就是数据控制权的不对等性。游戏公司利用技术优势和议价优势，在相关协议中设定了诸多免责条款。《原神》将账号所有人限定为游戏公司一方。《天涯明月刀》中玩家并无对游戏内物品的所有权，所以《个人信息保护法》[2]中的删除权就成了游戏公司减少储存成本、规避财产损失赔偿的尚方宝剑。其次则是约定俗成与法定标准的差异。《韩国游戏产业振兴法》[4]要求休眠账号至少保存3年，而我国《网络安全法》[1]“数据最小化原则”难以细化，因此，有78.4%的国内手游选择了“一年不登陆，永久删号”的规则，这与《最终幻想14》（日本）等游戏平均2.5年的数据保存时间形成了鲜明反差。",
    "更进一步，在是否“删除”的判断上，法律的标准不统一。《个人信息保护法》(第47条) [2]对企业“删除”个人信息的情形，规定为“处理目的已达成”或“终止提供服务”等情形。但是何为“处理目的”在实践中存在争议。在北京市互联网法院(2023)民初1234号案件中，网络游戏玩家起诉腾讯公司恢复其游戏账号《地下城与勇士》，腾讯公司回复称其删除该游戏账号是因“提升服务器效率等”，但法院认为腾讯公司提交的游戏玩家的充值记录、游戏好友等信息仍有继续利用的价值，判决恢复游戏玩家账号。裁判不统一，企业不清楚数据利用的边界，存在很大的司法风险。",
    "虚拟主播产业的技术滥用之殇",
    "2022年南京警方抓获的“AI虚拟主播小希案”犹如一面镜子，折射出滥用技术所造成的一系列问题。犯罪团伙编写python程序绕过直播平台数据接口，每天爬取5万条以上用户画像，利用生成对抗网络技术（GAN）将爬取到的脸部特征拼合到图片上生成拟人化主播，通过暗网以0.3比特币的价格售卖“数据包”，内含手机号、住址等，获利超过200万元。这一犯罪行为的特殊性在于犯罪链条涉及爬取数据、人脸合成、比特币洗钱等一系列技术工具，存在治理难题。",
    "平台审核形同虚设是第一问题。《互联网直播服务管理规定》[5]第十一条规定，平台对主播身份要进行“实质核查”，然而在此次事件中，平台要求上传身份证正背照，没有要求主播做人脸比对、音纹比对等技术认证，犯罪团伙使用PS伪造身份证照片，注册虚拟主播账号37个，“纸面审核”为犯罪团伙留下了极大的空隙。",
    "缺乏技术伦理规制。“开源的深度合成技术门槛低，本案使用的StyleGAN3模型在GitHub上免费，只要对代码略懂一二和拥有基础的编程能力就可轻松训练得出”。《互联网信息服务深度合成管理规定》[6]第12条虽然规定了“深度合成提供者应当对内容进行标识”，但技术开发者往往以“中立工具”为由拒绝承担义务，技术无罪论盛行导致法律规范难以触及到技术开发者。",
    "跨境执法也面临着现实障碍。本案赃款经过加密货币混币工具流向海外交易所，侦查人员历经8个月追踪溯源到资金流向。嫌疑人员使用的群组服务器为立陶宛的电信群组，依照我国《国际刑事司法协助法》[7]，跨境数据调取需要经过重重外交流程，重要证据难以调取。",
    "司法机关最终以侵犯公民个人信息罪判处组织者三年有期徒刑，并没有明确平台责任。在后续民事诉讼中，“被害方团”集体起诉直播平台要求其承担精神损失，法院以“平台尽到形式审查义务”驳回原告诉讼请求，这可能诱发平台降低安全成本。2023年，第三方平台人脸验证测试之后，主流直播平台人脸识别成功率达到了62%，伪造证件成功率达到了41%。",
    "虚拟财产处置的规范缺失",
    "2023年网易《哈利波特：魔法觉醒》回收案，直接将虚拟财产的法律保护问题推上前台。一玩家3天18个小时内玩游戏，以万分之一点七的微弱概率抽中全服唯一的一个全服道具“传说级魔杖”，交易价高达20万，3天后该公司以发现异常数据为由回收，称玩家利用漏洞修改了抽取概率，玩家以未经事先说明和日志篡改为由向广州市互联网法院提起诉讼。",
    "此案是虚拟财产治理乱象的缩影，对于财产的价值认定混乱，中国政法大学2023年公布的《虚拟财产司法鉴定指引》[13]，按照“玩家的游戏时长×社会平均工资”计算，玩家只能得到2.1万元左右的补偿，并未考虑该球员的道具是否具有唯一性、20万元的竞价，以及该玩家三年时间精力的投入；在“《FF14》房屋强拆案”中，日本有专门的财产鉴定人员负责对财产进行价格评估，根据其获取的难易程度、市场流通价格、该球员投入的精力、成本等情况，该案件的判决结果是公司补偿玩家80%的价款。",
    "电子证据采信率低。据游戏运营商后台日志，玩家每秒抽游戏奖就有300次异常请求，委托鉴定机构鉴定日志文件哈希值与前一日不相似，存在修改痕迹。根据《电子签名法》[8]第八条，对电子证据必须符合生成和储存方法的可靠性的要求，运营商既控制数据储存系统，又承担诉讼中的举证，属于自证自明。关于证据要符合《电子签名法》[8]第九条规定的电子证据要求，北京某律所要统计的2020-2023年度的虚拟财产案件，企业提交的电子证据采信率为87%，而玩家自己提交委托鉴定的证据采信率不足15%。",
    "处置流程存在合法合规风险。《消法》[9]禁止经营者以格式条款方式排除消费者合法利益，而涉案游戏用户协议对被排除权益的道具无需事前提醒，玩家在道具被收回2天后才收到电邮，且申诉渠道是客服页面三级菜单中隐藏的。不止如此，在上海市消保委2023年受理的网游投诉件中，63%涉及“无警告封禁账号”“无投诉渠道”等问题。此外，企业还“以最终解释”排除消费者合法权益，如某头部游戏企业用户协议条款“我方认为可以处置且有单方认定权，用户无法就上述事实认定提出任何异议”。",
    "制度突围的现实路径",
    "这些案例似乎都在暗示了一个共同点，即“数字经济时代的法律治理应当从‘事后治理’转向‘规范再造’”。",
    "就游戏账号治理，应当学习欧盟《数字服务法》[10] “先警告(60天)→再警告（30天）→先警告(7天)”的告知模式强制公司对游戏休眠账号开展二次“警告—警告”，并且延长数据留存期限为2年以上。就虚拟主播，应当构建“技术—应用—执法溯源”的全环节追责制度，并强制要求嵌入数字水印标识，同时，在《刑修十二》增设非法提供深度伪造工具罪；就虚拟财产，应当参考央行数字货币研究所的区块链存储方案建立国家级游戏道具数据库，保证虚拟财产可溯源。",
    "这些治理的革新离不开立法的高层保障，更离不开技术的支撑。杭州互联网法院试点司法区块链存证平台已经可以实现游戏操作数据显示的固化存证，玩家在参与抽奖等重点操作环节可以实时生成区块链存证。法制规范、技术支持，是数字经济时代权益保护破冰的关键，也只有在法律、技术协同的加持下，才能真正打破当前这一僵局，使得权益保护能够在良法善治时代迎来破冰。",
    "法律制度的革新路径",
    "如何解决数字经济所带来新的法律问题，需要多方主体共同参与。这既要从法律本身进行创新，也要从司法审判层面进行创新，从立法层面实现行业治理的创新，而这系统工程需要政府、企业、组织、公众多方发挥作用，才能为数字经济发展提供良好的法治环境。",
    "立法层面加快制定专项法律法规填补制度空缺。我国缺乏专门针对虚拟财产保护和深合成像领域的法律法规，导致实践中的诸多法律纠纷难以解决。可以借鉴国外经验与我国实际国情相结合推进立法，例如借鉴欧盟《数字服务法》[10]体系构建经验，结合当前网络游戏、虚拟主播的发展状况探索制定《数字资产保护条例》。",
    "该条例需重点澄清三个问题：一是明定虚拟财产“有限权属”性质。虚拟财产不同于有形财产，其依附于用户与平台之间的合同关系，可以参照《物权法》[11]有关动产的保护规定，赋予用户占有、使用、收益等权利，并对其权限范围加以限定。二是确立国家区块链确权存证制度。运用区块链去中心化、不可篡改机制，对游戏道具、直播账号等虚拟财产进行登记与流转跟踪，解决虚拟财产确权难问题。三是规范技术治理规则。对AI换脸、语音合成等合成性技术，要求服务提供者进行显著标识并对技术提供者的训练数据进行合法性审查，防止技术的滥用。",
    "在司法实践中要创新裁判规则破解技术难关。数字经济纠纷的技术问题较多，对法院审判提出更高的要求。值得借鉴的是，广州互联网法院建立的“技术陪审官”制度，通过招募密码学专家、网络安全工程师等专业人士担任技术陪审官，协助法官解决技术问题，例如在某直播平台数据被盗用案庭审中，技术陪审官通过Wireshark协议分析技术还原用户数据被盗用证据，为责任划分打下基础。此外，建议最高人民法院出台有关虚拟财产价值判定的司法解释，通过技术陪审官的“基础价值+附加价值”二元模型对玩家充值、时间、交易价格等价值因素作出相应评价，以此判定虚拟财产真实价值。",
    "在行业监管上应建立多方责任机制。一是建立用户协议登记备案机制，对于平台协议内容冗长，责任不明确的，要求平台提交网信部门备案，主要针对数据留存期限，纠纷处理等内容，防止格式条款损害用户权益。二是借鉴金融行业的第三方存管机制，引入企业用户数据安全保障保险，由承保机构对企业用户数据安全情况进行保险保障，收取不同比例的保费倒逼企业安全。三是引导行业协会建立自律委员会，制定虚拟主播认证制度、游戏账号清退制度，形成行业监管与行业自律相协调的机制。",
    "迈向数字文明的法律治理",
    "元宇宙和生成式AI相互融合的时代，个人信息安全法律保障不再是单纯的救济法的法理权利，而是数字文明的底色。以技术革命驱动的新一轮产业革命时代，新技术的层出不穷在推动经济社会发展过程中不断催生新的治理问题，个人信息安全法律保障就显得尤为重要，它不仅是关乎个人的隐私与财产权益，更是关乎数字文明的生态可持续。",
    "面向未来的制度建设，一是要整体修订原有的网络安全法[1]，增设“数字资产保护”，数字技术日新月异，虚拟财产保护难上加难，原有的法律框架无法规制，要基于原有网络安全法进行修订[1]，把数据产权保护规制规则、技术伦理规则、跨境流动规则等新的保护议题，纳入到现有规则体系，提供数字资产保护的更加全面保护的法律规范。二是要增强技术对法律的执行效果，推动零知识证明、同态加密等新技术在隐私保护中的应用。技术是一把“双刃剑”，既可以是破坏隐私的利器，也可以是保护隐私的盾牌，要通过科技创新，实现数据可用而不可见，既保护用户隐私，又发挥数据资产价值。三是加强国际合作，为构建《全球数字资产治理公约》等提供帮助。数字经济全球化，需要全球治理，个人信息问题必须寻求全球性的解决方案，参与跨境司法协作，参与全球的制度设计，解决跨境执法的管辖冲突和取证问题，建立共同的安全开放的数字治理共同体。",
    "法律规制创新的持续演进，以及与技术创新的深度融合，是激发数字经济活力、筑牢个人信息安全法治底线的内在要求，是技术与人文的合而为一，是一个长期的过程，是持续的制度创新和治理实践的长期过程，因此，在各方努力下，一个更为安全、有序、富有创造力与想象力的文明世界终将是人类的美好愿景，为人类社会的发展源源不断注入前行动力。",
    "参考文献",
    "[1] 全国人民代表大会常务委员会. 中华人民共和国网络安全法[Z]. 2016-11-07.\n[2] 全国人民代表大会常务委员会. 中华人民共和国个人信息保护法[Z]. 2021-08-20.\n[3] 全国人民代表大会. 中华人民共和国民法典[Z]. 2020-05-28.\n[4] Ministry of Culture, Sports and Tourism of Korea. Game Industry Promotion Act[Z]. 2021.\n[5] 国家互联网信息办公室. 互联网直播服务管理规定[Z]. 2016-11-04.\n[6] 国家互联网信息办公室. 互联网信息服务深度合成管理规定[Z]. 2022-11-25.\n[7] 全国人民代表大会常务委员会. 中华人民共和国国际刑事司法协助法[Z]. 2018-10-26.\n[8] 全国人民代表大会常务委员会. 中华人民共和国电子签名法[Z]. 2019-04-23.\n[9] 全国人民代表大会常务委员会. 中华人民共和国消费者权益保护法[Z]. 2013-10-25.\n[10] European Parliament and Council. Digital Services Act[Z]. 2022-10-19.\n[11] 全国人民代表大会. 中华人民共和国物权法[Z]. 2007-03-16.\n[12] 腾讯公司. 腾讯游戏许可及服务协议[EB/OL]. (2023-10-01) [2025-06-25]. https://game.qq.com/contract.shtml.\n[13] 中国政法大学. 虚拟财产司法鉴定指引[R]. 北京: 中国政法大学, 2023.\n[14] 北京互联网法院. 涉游戏案件审判白皮书[R]. 北京: 北京互联网法院, 2023.",
    "说在前面",
    "算法应该是大二上我学的最轻松的一门课了，我有一个完美的开始和一个完美的结束——尽管中间一度每周打算签完到就不做了，非常感谢狗头学长的板子(C++算法板子积累 - Only(AR) 的编程日记)，也特别感谢各位助教对我的帮助。下面的板子转pdf打印出来大概有90多页，虽然大部分都用不上，但是！有总比没有好嘛——",
    "Tips",
    "图论\n+ 重边：最短路记得判断，只存最短的边\n+ 负环？负边权？\n+ 有重边的情况下判断负环：有负数就存负数，负数越小越好；否则存正数，正数越大越好\n+ 最短路径\n    + 单源最短路径：一个点到其他任意点的最短路径\n        + Bellman-Ford算法：时间$O(VE)$；可负权重；可回路；可以检测负环，但不能在存在负环的图中计算单源最短路径。\n        + 有向无环图中的单源最短路径问题：时间$O(V+E)$；可负权重；不可回路\n        + Dijkstra算法：时间$O((V+E)logV)$；不可负权重；可回路\n    + 所有结点对的最短路径问题：所有点到所有点的最短路径\n        + floyd算法：时间$O(n^3)$空间$O(n^2)$；可负权重；可回路；不能检测负环，不能有负环\n    + 特别地，可以用BFS求无权图最短路径\n+ 最大流：在一个流网络中，找到从源点到汇点的最大流量。流网络是一个有向图，每条边有一个容量限制，表示通过该边的最大流量。\n    + Edmonds-Karp算法：时间 $O(VE^{2})$；适合稀疏图\n    + Dinic算法：时间 $O(V^{2}E)$；适合稠密*图\n+ 最大二分匹配：在二分图中找到最大的匹配数。二分图是一种特殊的图，其节点可以分为两个互不相交的集合，使得每条边都连接这两个不同集合中的节点。\n    + Dinic最小割/最大流算法：时间 $O(V^2E)$ \n    + 匈牙利算法：时间 $O(VE)$\n+ 最小生成树：在连通加权图中，找到一棵包含所有节点的树，使得树中所有边的权重之和最小。目的是找到连接所有顶点的最小总权重的边集。不关心顶点之间的具体路径长度，只关心整体结构的权重最小。\n    + Prim：时间 朴素版 $O(V^2)$，堆优化版 $O(ElogV)$\n    + Kruskal：时间 $O(ElogE)$\n+ 有向无环图 $G(V,E)$，$G$ 是半连通的当且仅当有一条路径，这条路径上有图 $G$ 中所有点：所以判断一个图是不是半连通的只需要判断拓扑序列的相邻节点是否有边",
    "做题思想/技巧\n![[Pasted image 20241222120755.png|550]]",
    "注意事项\n+ 在对接近 0 的负数四舍五入时应输出 0.00 而非 -0.00：fabs(a) < 0.005 时输出 0.00 \n+ 快速读写\ncpp\n//快读\ninline ll read(){\n   ll s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\n//快写\ninline void out(ll a){\n    if(a>=10)out(a/10);\n    putchar(a%10+'0');\n}\nint main(){\n    ll n;\n    n=read();\n    out(n);\n    return 0;\n}\n+ 数组大小\n    如无向图双倍空间，FFT四倍空间\n    空间计算 sizeof ，如下方法计算 数组所占空间（KB）： cout << sizeof a/1024\n+ corner case\n    $n  = 0,1$\n    $a_i = 0, 1e9, -1e9$\n    几何中斜率为0\n+ 初始化\n+ 多测清空，不要滥用 memset\nmemset(a, 0, sizeof(int)*(n+1)); 正确\n    memset(a, 0, sizeof a); 超时\n    以及 memset 初始化最大值 应为 memset(a, 0x3f, sizeof(int) * (n+1));\n+ long long\n+ cin和cout关闭同步流（但关闭后不能用scanf printf等c语言的输入输出）\n    ios::sync_with_stdio(false)\n+ cin, cout时用 '\\n' 代替 endl\n+ 数组是否够大\n+ 浮点数误差：如几何求面积能否直接用整数计算\n+ 不要用gets!!!!!!!!!!!!!!!!!!\n+ int max: 2147483647, which is 2^31 - 1\nint min: -2147483648, which is -2^31\nlong long max: 9223372036854775807, which is 2^63 - 1\nlong long min: -9223372036854775808, which is -2^63\n+ 一些最大值最小值\n    用 climits 头文件 INT_MAX INT_MIN LLONG_MAX LLONG_MIN\n```cpp",
    "include",
    "include",
    "int main() {\n    // 打印整型的最大值和最小值\n    std::cout << \"int 的最大值是：\" << INT_MAX << std::endl;\n    std::cout << \"int 的最小值是：\" << INT_MIN << std::endl;\n    // 打印长整型的最大值和最小值\n    std::cout << \"long long 的最大值是：\" << LLONG_MAX << std::endl;\n    std::cout << \"long long 的最小值是：\" << LLONG_MIN << std::endl;\n    return 0;\n}\n```",
    "cppStart",
    "```cpp",
    "include",
    "include",
    "include",
    "include",
    "include",
    "include",
    "include",
    "include",
    "include",
    "using namespace std;\nint main() {\n    return 0;\n}\n```",
    "标准库",
    "能遍历的容器：vector, set, multiset",
    "vector（向量）: 动态数组；当需要随机访问元素且频繁在末尾添加或删除元素时。",
    "algorithm",
    "```cpp\n__gcd(a, b) // 求两个数的最大公因数\n__builtin_popcount(a) // 求 int 的二进制里多少个 1",
    "is_sorted(a, a + n) // 是否升序\nis_sorted_until(a, a + n) // 到哪里是升序\nsort(a, a + n) // 不稳定排序(默认升序)\nsort(a, a + n, greater()) // 降序排序\nstable_sort(a, a + n) // 稳定排序\nnth_element(a, a + k, a + n) // 将第 k 大元素放到 a[k]\nunique(begin, end) // 对有序数组去重，返回末尾地址(去除的是相邻的重复元素,所以使用前需先排序)",
    "max(a, b) // 返回较大值\nmin(a, b) // 返回较小值\nmax_element(a, a + n) // 返回最大值位置\nmin_element(a, a + n) // 返回最小值位置",
    "int pos1 = lower_bound(a, a + n, key)-a; // 返回第一个大于等于 key 的元素的下标 \nint pos2 = upper_bound(a, a + n, key)-a; // 返回第一个大于 key 的元素的下标\nbinary_search(a, a + n, key) // 二分查找是否存在",
    "is_heap(a, a + n) // 判断是否为大顶堆 vectora; is_heap(a.begin(), a.end())\nis_heap_until(a, a + n) // 到哪里是大顶堆\nmake_heap(a, a + n) // 区间建堆 vectora; make_heap(a.begin(), a.end())\npush_heap(a, a + n) // 末尾元素入堆并调整，与push_back配合（push_back将元素添加到数组的末尾，然后用push_heap来调整堆）\npop_heap(a, a + n) // 堆顶移到末尾并调整，与pop_back配合（pop_heap将堆顶元素移动到数组的末尾，然后用pop_back从数组中移除该元素）\nsort_heap(a, a + n) // 升序堆排序",
    "is_permutation() // 两个序列是否互为另一个的排序，即检查它们是否包含相同数量的相同元素，尽管元素的顺序可能不同\nnext_permutation() // 重排为字典序的下一个更大的排列。如果这样的排列存在，返回true；否则，重排为第一个排列（即升序排列），返回false\nprev_permutation() // 重排为字典序的上一个更小的排列。如果这样的排列存在，返回true；否则，重排为最后一个排列（即降序排列），返回false",
    "fill(a, a + n, val) // 批量赋值\nreverse(a, a + n) // 数组翻转",
    "auto it = find(shuzu, shuzu+n, 1)\nauto it = find(v1.begin(), v1.end(), 1) // 查找v1中有没有1，find函数返回一个迭代器，如果v1中有1则迭代器it指向找到的第一个目标元素，否则指向v1.end()\n// vector set multiset 普通数组都能用find，queue priority_queue stack不能用\n如cpp\nint a[10] = {5,2,3,4,5};\nint b[10] = {5,2,3,4,1};\ncout << is_permutation(a, &a[5], b);\nis_permutation (c1.begin()+1, c1.end(), c2.begin());\n```",
    "vector",
    "```cpp\nvector  v1 // 空\nvector  v2(5,0); // 5个0\nvector v3(v2.begin(), v2.end());  // 和v2相同\nvector v4(v2);   // 和v2相同\nv.at(k)   // 访问 v[k]\nv.front() // 首元素\nv.back()  // 末元素\nv.begin() // 首地址(迭代器)  用于和v.end()一起放到find()里面去找v中是否存在某个值\nv.end()   // 末地址(迭代器)  如auto it = find(v1.begin(),v1.end(),1)\nv.empty()      // 是否空  返回true/false\nv.size()       // 大小\nv.max_size()   // 最大空间\nv.clear()      // 清除\nv.insert(pos, item)   // 在 pos(迭代器) 位置插入 item\nv.eraze(pos)   // 擦除 pos(迭代器) 位置的元素\nv.push_back(item)     // 末尾插入\nv.pop_back()   // 末尾删除",
    "v.reserve(n);  // 请求向量容量至少足以包含 n 个元素。",
    "// v.size()的返回值是unsigned，所以...\nvector v;\nv.push_back(3);\nfor(int i=0;i<=v.size()-1;i++) {//错误\n    cout<<v[i]<<\" \";\n}\nfor(int i=0;i<=(int)v.size()-1;i++) {//(正确)\n    cout<<v[i]<<\" \";\n}\n```",
    "queue",
    "cpp\n/*----- queue -----*/  \nqueue<int> q;\nq.push(item) // item 入队  \nq.front() // 访问队头  \nq.pop() // 出队  \nq.back() // 访问队尾  \nq.empty() // 是否空  \nq.size() // 大小  \nq.emplace(item) // item 替换队尾  \n/*----- priority_queue -----*/  \npriority_queue<int, vector<int>, greater<int>> pq  \npq.top() // 访问队首  \npq.empty() // 优先队列是否空  \npq.size() // 大小  \npq.push(item) // 插入 item  \npq.pop() // 出队",
    "优先队列的声明",
    "cpp\npriority_queue <int> i;  //【排序】14 12 10 8 6\npriority_queue <double> d;  \n​priority_queue <int,vector<int>,less<int> >q;//【排序】14 12 10 8 6\npriority_queue <int,vector<int>,greater<int> > q;//【排序】6 8 10 12 14\n// 不需要#include<vector>头文件，注意后面两个“>”不要写在一起，“>>”是右移运算符",
    "结构体的优先队列",
    "重写cmp\n```cpp\nstruct node{\n    int fir,sec;\n    void Read() {scanf(\"%d %d\",&fir,&sec);}\n}input;\nstruct cmp1{\n    bool operator () (const node &x,const node &y) const{\n        return x.fir<y.fir;\n    }\n};//当一个node x的fir值小于另一个node y的fir值时，x在y后面\nstruct cmp3{\n    bool operator () (const node &x,const node &y) const{\n        return x.fir+x.sec<y.fir+y.sec;\n    }\n};//当一个node x的fri值和sec值的和小于另一个node y的fir值和sec值的和时，x在y后面\npriority_queue,cmp1> q1;\npriority_queue,cmp3> q3;\nwhile(!q1.empty()) printf(\"(%d,%d) \",q1.top().fir,q1.top().sec),q1.pop(); \nwhile(!q3.empty()) printf(\"(%d,%d) \",q3.top().fir,q3.top().sec),q3.pop();",
    "【输入】\n1 2\n2 1\n6 9\n9 6\n-100 100\n-500 20\n4000 -3000\n【输出】\ncmp1: (4000,-3000) (9,6) (6,9) (2,1) (1,2) (-100,100) (-500,20)\ncmp3: (4000,-3000) (6,9) (9,6) (1,2) (2,1) (-100,100) (-500,20)\n```",
    "stack",
    "cpp\nstack<int> s;\ns.push(item) // item 入栈  \ns.top() // 访问栈顶  \ns.pop() // 出栈\ns.empty() // 栈是否空  \ns.size() // 大小  \ns.emplace(item) // item 替换栈顶",
    "set",
    "```cpp\n/----- set 不允许容器中有重复元素 -----/\ns.size() // 大小\ns.empty() // 是否空\ns.clear() // 清除\ns.insert(key) // 插入\ns.erase(pos/key) // 删除\ns.erase(3); // 删除键值为3的元素 {1,2,3,4,5}->{1,2,4,5}\nauto it = s.find(4);\nif (it != s.end()){ \n    s.erase(it); // 删除迭代器it指向的元素 {1,2,3,4,5}->{1,2,3,5}\n}\ns.count(key) // 是否存在\ns.find(key) // 查找，成功返回位置，失败返回 s.end()\n/----- multiset 允许容器中有重复元素 -----/\nms.size() // 大小\nms.empty() // 是否空\nms.clear() // 清除\nms.insert(key) // 插入\nms.erase(pos/key) // 删除\nms.count(key) // 计数\nms.find(key) // 查找，成功返回位置，失败返回 s.end()",
    "//插⼊\nfor(int i=1;i<=n;i++)\n    s.insert(gint());",
    "// set容器排序：利用仿函数改变排序规则\nclass MyCompare{\n    public:\n    bool operator()(int v1, int v2) {\n        return v1 > v2;\n    }\n};\nint main() {\n    //默认从小到大 10 20 30 40 50\n    set s1 = {10, 20, 30, 40, 50};\n    //指定排序规则 50 40 30 20 10\n    set s2 = {10, 20, 30, 40, 50};\n    return 0;\n}",
    "// set的遍历\n// 法1\nfor (set::iterator it = s1.begin(); it != s1.end(); ++it) {\n    cout << it << ' ';\n}\n// 法2\nfor (auto it = mySet.begin(); it != mySet.end(); ++it) {\n    cout << it << ' ';\n}\n// 法3\nfor (int it : mySet) {\n    cout << it << ' ';\n}\n```",
    "pair",
    "可以用来代替一些便捷的自定义struct。且pair自带小于号，可直接用于排序，第一关键字为第一维升序，第二关键字为第二维升序\ncpp\npair<int,int> p1;\npair<int,string> p2;\npair<double,int> p3;",
    "map",
    "构建⼀个映射关系复杂度为 $O(logn)$\ncpp\nmap<T1,T2> mp;\nmap<int,int> mp1;\nmap<string,int> mp2;\nmap<int,set<int> mp3;\nmap<int,vector<int>> mp4;",
    "存图",
    "邻接矩阵",
    "邻接表",
    "vector实现有权邻接表\n+ 对于具有边权或是其他信息的边，可以定义结构体以保存边的信息。\ncpp\nstruct Edge {\n    int to; // 边指向的点\n    int weight; // 边权\n}\nvector<Edge> g[N];  // N 个结点的邻接表\ng[u].push_back({v, w});  // 添加边权为 w 的一条边 u → v",
    "pair实现有权邻接表\n+ 两个元素的有序对 ⟨x, y⟩ 可以使用 STL 的 pair 保存。\n+ pair ⟨x, y⟩ 之间的大小关系定义为：$⟨x1, y1⟩ < ⟨x2, y2⟩ ⇐⇒ x1 < x2 ∨ (x1 = x2 ∧ y1 < y2)$\n+ 第一个元素类型 T1，第二个元素类型 T2 的 pair：pair<T1, T2> p;\n+ 创建一个 pair：p = make_pair(x, y);\n+ 取 pair 的第一个元素：p.first\n+ 取 pair 的第二个元素：p.second\n+ 可以用 pair 实现邻接表。第一个元素保存边指向的点，第二个元素保存边权：\ncpp\nvector<pair<int, int>> g[N];\ng[u].emplace_back(make_pair(v, w));\n// 添加边权为 w 的一条边 u → v\nfor (auto e : g[u]) {\n    int v = e.first, w = e.second;\n    // 遍历 u 的出边 u → v，边权为 w\n}",
    "char*和string",
    "char* to string",
    "cpp\nchar* name;\nstring softwareName = name;",
    "string to char*",
    "cpp\nchar* strToChar(string strSend){\n    char* ConvertData;\n    const int len2 = strSend.length();\n    ConvertData = new char[len2 + 1];\n    strcpy(ConvertData, strSend.c_str());\n    return ConvertData;\n}",
    "插入排序",
    "c\nvoid insertSort(keytype k[ ],int n){  \n    keytype temp;  \n    for(int i=1; i<n; i++){  \n        temp = k[i];  \n        for(int j=i-1; j>=0 && temp<k[j]; j--)   \n            k[j+1] = k[j];  \n        k[j+1] = temp;  \n    }  \n}",
    "归并排序 $O(n log n)$",
    "```c",
    "include",
    "include",
    "include",
    "include",
    "include",
    "define MAX 1000",
    "​\nint temp[MAX], ans[MAX] = {50, 10, 20, 30, 70, 40, 80, 60};\n​\nvoid Mergesort(int startId, int endId);\nvoid Merge(int startId, int midId, int endId);\n​\nint main() {\n    Mergesort(0, 7);\n    for(int i=0; i<8; i++)\n        printf(\"%d \", ans[i]);\n    return 0;\n    }",
    "void Mergesort(int startId, int endId){\n    int midId = startId + (endId - startId)/2;\n    if(startId < endId){\n        Mergesort(startId, midId);\n        Mergesort(midId+1, endId);\n        Merge(startId, midId, endId);\n    }\n}\n​\nvoid Merge(int startId, int midId, int endId){\n    int i=startId, j=midId+1, k=startId;\n    while(i <= midId && j<=endId){\n        if(ans[i] < ans[j]){\n            temp[k] = ans[i];\n            k++; i++;\n        }else{\n            temp[k] = ans[j];\n            k++; j++;\n        }\n    }\n    while(i <= midId){\n        temp[k] = ans[i];\n        k++; i++;\n    }\n    while(j <= endId){\n        temp[k] = ans[j];\n        k++; j++;\n    }\n    for(i=startId; i<=endId; i++){\n        ans[i] = temp[i];\n    }\n}\n```",
    "逆序对计数",
    "```cpp",
    "include",
    "using namespace std;\ntypedef long long ll;",
    "define MAX (200000+5)",
    "int temp[MAX], a[MAX];\nll solve(int a[], int left, int right);",
    "int main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    cout << solve(a, 0, n - 1);\n    return 0;\n}\nll solve(int a[], int left, int right) {\n    if (left == right)\n        return 0;\n    else {  // 分治\n        int mid = (right - left) / 2 + left; // 分\n        ll s1 = solve(a, left, mid);         // 治：左边排序\n        ll s2 = solve(a, mid + 1, right);    // 治：右边排序\n        ll s3 = 0;\n        int i = left, j = mid + 1, k = 0;\n        while (i <= mid && j <= right) {     // 合：整体排序\n            if (a[i] <= a[j]) {     // 如果 a[i] <= a[j] 就放a[i]进去\n                temp[left + k] = a[i];\n                k++;\n                i++;\n            } else {                // 如果 a[i] > a[j] 就放a[j]进去\n                temp[left + k] = a[j];\n                s3 += (mid - i + 1);    // 如果a[j]<a[i]，说明a[j]<a[i]~a[mid]，共有mid-i+1个逆序对\n                k++;\n                j++;\n            }\n        }\n        if (i <= mid)\n            while (i <= mid) {\n                temp[k + left] = a[i];\n                k++;\n                i++;\n            }\n        else\n            while (j <= right) {\n                temp[k + left] = a[j];\n                k++;\n                j++;\n            }\n        for (int l = left; l <= right; l++)\n            a[l] = temp[l];\n        return s1 + s2 + s3;\n    }\n}\n```",
    "多数问题",
    "n个数组成一个数组，寻找是否有一个数的数量≥n/2\n```c",
    "include",
    "const int N = 2000000;    //定义数组的最大长度\nint a[N];\nint majorityDC(int a[], int start, int end, int result) {\n    // 分治法求解多数问题，result是数量过半的数的值，数组下标区间为[start, end]\n    if (start == end) {\nresult = a[end];\n        return 1;\n    }else{\n        int m1, m2;\n        majorityDC(a, start, (start + end) / 2, &m1);  \n        //m1为前半区间[start, (start + end) / 2]的多数\n        majorityDC(a, (start + end) / 2 + 1, end, &m2); \n        //m2为后半区间[(start + end) / 2 + 1, end]的多数\n        int count1 = 0, count2 = 0;\n        for (int i = start; i <= end; i++) {\n            if (a[i] == m1) {   //count1记录m1在数组a[]中出现的次数\n                count1++;\n            }\n            if (a[i] == m2) {   //count2记录m2在数组a[]中出现的次数\n                count2++;\n            }\n        }\n        if(count1 > ((end - start + 1) / 2)) {\n            //m1在数组a[]中出现的次数大于数组长度的一半，则m1为多数\nresult = m1;\n            return 1;\n        }else if(count2 > ((end - start + 1) / 2)) {\n            //m2在数组a[]中出现的次数大于数组长度的一半，则m2为多数\n            *result = m2;\n            return 1;\n        }else{\n            return 0;  //m1, m2均不是多数，则数组a[]的多数不存在\n        }\n    }\n}",
    "int main() {\n    int n, resultDC;\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++){\n        scanf(\"%d\\n\", &a[i]);\n    }\n    if(majorityDC(a, 0, n - 1, &resultDC)){\n        printf(\"%d\", resultDC);\n    }else{\n        printf(\"Can not find the majority!\");\n    }\n    return 0;\n}\n```",
    "维护堆的性质",
    "c递归维护",
    "```c\n// 维护最大堆的性质\n// arr:一个最大堆的数组\n// i:需要调整的堆中的元素\nvoid max_heapify(int arr[], int i, int n){\n    // 从a[i] a[l] a[r]选择最大的\n    int l = 2i+1, r = 2i+2;\n    int largest = i;\n    if(l <= n && arr[l]>arr[largest]){\n        largest = l;\n    }\n    if(r <= n && arr[r]>arr[largest]){\n        largest = r;\n    }\n    // 如果a[i]最大，程序结束\n    if(largest != i){\n        swap(&arr[i], &arr[largest]);\n        max_heapify(arr, largest);\n    }\n}",
    "void swap(int a, int b) {\n    int temp = b;\nb = a;\na = temp;\n}\n```",
    "c非递归维护",
    "c\n// 维护最大堆的性质  \n// arr:一个最大堆的数组  \n// i:需要调整的堆中的元素  \nvoid max_heapify(int arr[], int start, int end) {  \n    //建立父节点指标和子节点指标  \n    int dad = start;  \n    int son = dad * 2 + 1;  \n    while (son <= end) { //若子节点指标在范围内才做比较  \n        if (son + 1 <= end && arr[son] < arr[son + 1]) //先比较两个子节点大小，选择最大的  \n        son++;  \n        if (arr[dad] > arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数  \n            return;  \n        else { //否则交换父子内容再继续子节点和孙节点比较  \n            swap(&arr[dad], &arr[son]);  \n            dad = son;  \n            son = dad * 2 + 1;  \n        }  \n    }  \n}  \n​  \nvoid swap(int* a, int* b) {  \n    int temp = *b;  \n    *b = *a;  \n    *a = temp;  \n}",
    "建堆",
    "时间复杂度$O(n)$\nc\nvoid build_max_heap(int arr[ ],int n){  \n    int i;  \n    for(i=n/2-1; i>=0; i--) // 建初始堆积  \n        max_heapify(arr, i, n);  \n}",
    "堆排序算法",
    "时间复杂度$O(nlgn)$",
    "c非递归维护最大堆",
    "```c\n// 堆排序\nvoid heapsort(int arr[], int n){\n    build_max_heap(arr, n);     // 先建堆\n    for (int i = n - 1; i > 0; i--) {\n        swap(&arr[0], &arr[i]);     // 将第一个元素(剩下的max)和已排好元素前一位做交换\n        max_heapify(arr, 0, i - 1); // 重新调整\n    }\n}",
    "// 建堆\nvoid build_max_heap(int arr[ ],int n){\n    int i;\n    for(i=n/2-1; i>=0; i--) // 建初始堆积\n        max_heapify(arr, i, n);\n}",
    "// 维护最大堆的性质\n// arr:一个最大堆的数组\n// i:需要调整的堆中的元素\nvoid max_heapify(int arr[], int i, int n){\n    // 从a[i] a[l] a[r]选择最大的\n    int l = 2i+1, r = 2i+2;\n    int largest = i;\n    if(l <= n && arr[l]>arr[i]){\n        largest = l;\n    }\n    if(r <= n && arr[r]>arr[largest]){\n        largest = r;\n    }\n    // 如果a[i]最大，程序结束\n    if(largest != i){\n        swap(&arr[i], &arr[largest]);\n        max_heapify(arr, largest, n);\n    }\n}",
    "void swap(int a, int b) {\n    int temp = b;\nb = a;\na = temp;\n}\n```",
    "c+cpp递归维护最大堆",
    "```c",
    "include",
    "include",
    "void swap(int a, int b) {\n    int temp = b;\nb = a;\na = temp;\n}\n​\n// 维护最大堆的性质\n// arr:一个最大堆的数组\n// i:需要调整的堆中的元素\nvoid max_heapify(int arr[], int start, int end) {\n    //建立父节点指标和子节点指标\n    int dad = start;\n    int son = dad * 2 + 1;\n    while (son <= end) { //若子节点指标在范围内才做比较\n        if (son + 1 <= end && arr[son] < arr[son + 1]) //先比较两个子节点大小，选择最大的\n        son++;\n        if (arr[dad] > arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数\n            return;\n        else { //否则交换父子内容再继续子节点和孙节点比较\n            swap(&arr[dad], &arr[son]);\n            dad = son;\n            son = dad * 2 + 1;\n        }\n    }\n}\n// 堆排序算法\nvoid heap_sort(int arr[], int len) {\n    int i;\n    //建堆，初始化，i从最后一个父节点开始调整\n    for (i = len / 2 - 1; i >= 0; i--)\n        max_heapify(arr, i, len - 1);\n    //先将第一个元素和已排好元素前一位做交换，再从新调整，直到排序完毕\n    for (i = len - 1; i > 0; i--) {\n        swap(&arr[0], &arr[i]);\n        max_heapify(arr, 0, i - 1);\n    }\n}\ncpp",
    "include",
    "include",
    "using namespace std;",
    "// 维护最大堆的性质\n// arr:一个最大堆的数组\n// i:需要调整的堆中的元素\nvoid max_heapify(int arr[], int start, int end) {\n    //建立父节点指标和子节点指标\n    int dad = start;\n    int son = dad * 2 + 1;\n    while (son <= end) { //若子节点指标在范围内才做比较\n        if (son + 1 <= end && arr[son] < arr[son + 1]) //先比较两个子节点大小，选择最大的\n        son++;\n        if (arr[dad] > arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数\n            return;\n        else { //否则交换父子内容再继续子节点和孙节点比较\n            swap(arr[dad], arr[son]);\n            dad = son;\n            son = dad * 2 + 1;\n        }\n    }\n}",
    "// 堆排序算法\nvoid heap_sort(int arr[], int len) {\n    //初始化，i从最后一个父节点开始调整\n    for (int i = len / 2 - 1; i >= 0; i--)\n    max_heapify(arr, i, len - 1);\n    //先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕\n    for (int i = len - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        max_heapify(arr, 0, i - 1);\n    }\n}\n```",
    "用cpp的algorithm建堆和堆排序",
    "```cpp",
    "include",
    "using namespace std;\nint main() {\n    vector a = {1,2,3,4,5,6,7,8,9};\n    make_heap(a.begin(), a.end());   // 造堆\n    for(int i : a){\n        cout << i << \" \";\n    }\n    cout << endl;\n    sort_heap(a.begin(), a.end());   // 堆排序\n    for(int i : a){\n        cout << i << \" \";\n    }\n    return 0;\n}\n```",
    "c优先队列",
    "读最大元素 O(1)",
    "c\nint heap_maximum(int arr[]){  \n    return arr[0];\n}",
    "移走最大元素 O(lgn)",
    "c\nint heap_extract_max(int arr[], int n){  \n    if(n < 1){  \n        printf(\"HEAP UNDERFLOW\");  \n        return -1;\n    }  \n    int max = arr[0];  \n    arr[0] = arr[n-1];  \n    n--;  \n    max_heapify(arr, 0, n);  \n    return max;  \n}",
    "增加某结点的值 O(lgn)",
    "c\nvoid heap_increase_key(int arr[], int i, int key){  // 修改结点arr[i]的值为key\n    if(key < arr[i]){  \n        printf(\"NEW KEY IS SMALLER THAN CURRENT KEY\");  \n    }  \n    arr[i] = key;  \n    while(i>0 && arr[(i-1)/2]<arr[i]){  \n        swap(&a[i], &arr[(i-1)/2]);  \n        i = (i-1)/2;  \n    }  \n}",
    "插入一个新节点 O(lgn)",
    "c\nvoid max_heap_insert(int arr[], int key, int n){  \n    n++;  \n    a[n-1] = key-1;  \n    heap_increase_key(arr, n-1, key);  \n}",
    "快速排序",
    "最好情况/平均情况：$O(nlgn)$",
    "法1",
    "```c\n// way1",
    "include",
    "define keytype int",
    "using namespace std;\nvoid quickSort(keytype k[],int n);\nvoid quick(keytype k[ ],int left,int right);\nvoid swap(int x, int y);",
    "void quickSort(keytype k[],int n){\n    quick(k, 0, n-1);\n}\nvoid quick(keytype k[ ],int left,int right){\n    int i, j;\n    keytype pivot;\n    if(left < right){\n        i = left;\n        j = right+1;\n        pivot = k[left];\n        while(1){\n            while(k[++i]            while(k[--j]>pivot && j!=left) { }\n            if(i < j)\n                swap(&k[i], &k[j]);  /交换K[i]与K[j]的内容/\n            else\n                break;\n        }\n        swap(&k[left], &k[j]);      /交换K[s]与K[j]的内容/\n        quick(k, left, j-1);       / 对前一部分排序 /\n        quick(k, j+1, right);       / 对后一部分排序 /\n    }\n}\nvoid swap(keytype x, keytype y){\n    keytype temp;\n    temp = x;//取内容交换  \nx = y;\ny = temp;\n}",
    "int main() {\n    int a[100] = {2,3,4,5,1,123,1524,4235,345,34,67,324};\n    quickSort(a, 12);\n    for(int i=0; i<12; i++){\n        printf(\"%d \", a[i]);\n    }\n    return 0;\n}\n```",
    "法2",
    "```c\n// way2 BY K&R",
    "include",
    "define keytype int",
    "using namespace std;\nvoid quickSort(keytype k[],int n);\nvoid qsort(keytype v[ ],int left, int right);\nvoid swap(keytype v[ ],int i, int j);",
    "void quickSort(keytype k[],int n){\n    qsort(k, 0, n-1);\n}\nvoid qsort(keytype v[ ],int left, int right){\n    int i, last;\n    if(left >= right)\n        return;\n    swap(v, left, (left+right)/2);// 将中间与left交换，将中间作为基准\n    last = left;    // last: 最后一个比left小的元素\n    for(i=left+1; i<=right; i++)\n        if(v[i] < v[left])  // 如果当前元素小于基准元素\n            swap(v, ++last, i); // last右移，获得新的last\n    swap(v, left, last);    // 把基准元素left放到正确位置\n    qsort(v, left, last);\n    qsort(v, last+1, right);\n}\nvoid swap(keytype v[ ],int i, int j){\n    keytype tmp;\n    tmp = v[i];\n    v[i] = v[j];\n    v[j] = tmp;\n}\nint main() {\n    int a[100] = {2,3,4,5,1,123,1524,4235,345,34,67,324};\n    quickSort(a, 12);\n    for(int i=0; i<12; i++){\n        printf(\"%d \", a[i]);\n    }\n    return 0;\n}\n```",
    "快速排序的随机化版本",
    "最坏情况：$O(n^2)$\n期望运行时间：$O(nlgn)$\n```cpp",
    "include",
    "include",
    "using namespace std;\nint randomized_partition(int a[], int p, int r);\nvoid randomized_quiksort(int a[], int p, int r);\nint partition(int a[], int p, int r);",
    "void randomized_quiksort(int a[], int p, int r){\n    if(p < r){\n        int q = randomized_partition(a, p, r); // 随机选择一个元素作为基准，并进行划分\n        randomized_quiksort(a, p, q-1);\n        randomized_quiksort(a, q+1, r);\n    }\n}\nint randomized_partition(int a[], int p, int r){\n    int i = rand()%(r-p)+p; // 在[p, r]范围内随机选择一个索引作为基准\n    swap(a[r], a[i]);\n    return partition(a, p, r); // 调用partition函数进行划分\n}\nint partition(int a[], int p, int r){\n    int x = a[r];\n    int i = p-1; // i指向小于基准的最后一个元素\n    for(int j=p; j<=r-1; j++){\n        if(a[j] <= x){\n            i++; // i右移\n            swap(a[i], a[j]); // 交换元素，将小于基准的元素移到左边\n        }\n    }\n    swap(a[i+1], a[r]); // 将基准元素交换到正确的位置\n    return i+1; // 返回基准元素的最终位置\n}\nint main() {\n    int a[100] = {2,3,4,5,1,123,1524,4235,345,34,67,324};\n    randomized_quiksort(a, 0, 12);\n    for(int i=0; i<12; i++){\n        printf(\"%d \", a[i]);\n    }\n    return 0;\n}\n```",
    "最大子列和",
    "```cpp",
    "include",
    "include",
    "define MAX 1000005",
    "define ll long long",
    "using namespace std;\nint a[MAX];\n// 输入：数组array 数组长度n     返回：array的子列中最大的和\nll maxSubArray(int *array, int n) {\n    ll Max = -0x3f3f3f3f3f3f3f3f;\n    ll sum = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (sum < 0)  // 如果sum已经<0了，留下sum只会让之后的和更小，所以去掉sum\n            sum = array[i];\n        else\n            sum += array[i];\n        Max = max(sum, Max);\n    }\n    return Max;\n}",
    "int main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    cout << maxSubArray(a, n);\n    return 0;\n}\n```",
    "钢条切割",
    "给定一段长度为 $n$ 英寸的钢条和一个价格表 $p_i(i=1,2,...,n)$ ，求切割钢条方案，使得销售收益 $r_n$ 最大。",
    "带备忘的自顶向下法(top-down with memoization)",
    "include",
    "using namespace std;",
    "define MAX 100",
    "define MIN_VALUE -1",
    "int max(int a, int b){\n    if(a > b){\n        return a;\n    }else{\n        return b;\n    }\n}",
    "// p为价格表，n为正在切割的钢管长度，r为最大收益\nint MEMOIZED_CUT_ROD_AUX(int p, int n, int r){\n    int q;\n    if(r[n] >= 0){  // 切过这个长度，已经记住了\n        return r[n];\n    }\n    if(n == 0){     // 切一段长度为0的\n        q = 0;\n    }else{\n        q = MIN_VALUE;\n        for(int i=1; i<=n; i++){    // 左边长度i，右边长度n-i\n            q = max(q, p[i]+MEMOIZED_CUT_ROD_AUX(p, n-i, r));\n        }\n    }\n    r[n] = q;\n    return q;\n}",
    "// 函数入口 p为价格表 n为正在切割的钢管长度     返回能得到的最大value\nint MEMOIZED_CUT_ROD(int* p, int n){\n    int r[MAX];\n    for(int i=0; i<=n; i++){\n        r[i] = MIN_VALUE;// 初始化\n    }\n    return MEMOIZED_CUT_ROD_AUX(p, n, r);\n}\nint main() {\n    int p[15] = {0, 1, 5, 8, 9, 10, 17,17, 20, 24, 30};\n    printf(\"%d\", MEMOIZED_CUT_ROD(p, 14));\n    return 0;\n}\n```",
    "给出最大收益及最优切割方案",
    "下面的 EXTENDED_BOTTOM_UP_CUT_ROD 对长度为 $i$ 的钢条不仅计算最大收益值 $r_j$ ，还保存最优解对应的第一段钢条的切割长度 $S$ 。\n```cpp",
    "include",
    "using namespace std;",
    "define MAX 100",
    "define MIN_VALUE (-1)",
    "int s[MAX], r[MAX];\nvoid EXTENDED_BOTTOM_UP_CUT_ROD(int p, int n){\n    r[0] = 0;\n    for(int j=1; j<=n; j++){\n        int q = MIN_VALUE;\n        for(int i=1; i<=j; i++){\n            if(q < p[i]+r[j-i]){    // 更好的切割\n                q = p[i]+r[j-i];    // 更新价格\n                s[j] = i;           // 更新切割方式\n            }\n        }\n        r[j] = q;\n    }\n}\n// p:价格表 n:要切的钢条长度\nvoid PRINT_CUT_ROD_SOLUTION(int p,int n){\n    EXTENDED_BOTTOM_UP_CUT_ROD(p, n);\n    // 计算切割下来的每段钢条的长度s[1..n]和最大value r[1..n]\n    printf(\"%d\\n\", r[n]);\n    while(n > 0){\n        printf(\"%d \", s[n]);\n        n -= s[n];\n    }\n}",
    "int main() {\n    int p[15] = {0, 1, 5, 8, 9, 10, 17,17, 20, 24, 30};\n    PRINT_CUT_ROD_SOLUTION(p, 14);\n    return 0;\n}\n```",
    "矩阵链乘法",
    "include",
    "using namespace std;\n/\n * p: 表示矩阵的规模，矩阵 A_i 的规模用 p_i-1 * p_i 表示\n * s: s[i,j]表示A_i A_i+1 ... A_j最优括号化方案的分割点位置k\n * m: m[i,j]表示A_i A_i+1 ... A_j所需标量乘法次数的最小值\n/",
    "define MAX 100",
    "long long p[MAX],m[MAX][MAX],s[MAX][MAX];\nvoid MATRIX_CHAIN_ORDER(int n){\n    // 初始化\n    for(int i=1; i<=n; i++){\n        m[i][i] = 0;\n    }",
    "}\nvoid PRINT_OPTIMAL_PARENS(long long i, long long j){\n    if(i == j){\n        printf(\"A\");\n    }else{\n        printf(\"(\");\n        PRINT_OPTIMAL_PARENS(i, s[i][j]);\n        PRINT_OPTIMAL_PARENS(s[i][j]+1, j);\n        printf(\")\");\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);  // n个矩阵\n    for(int i=0; i<=n; i++){\n        scanf(\"%lld\", &p[i]);\n    }\n    MATRIX_CHAIN_ORDER(n);\n    printf(\"%lld\\n\", m[1][n]);   // A_1..A_n所需标量乘法次数的最小值\n    PRINT_OPTIMAL_PARENS(1,n); \n    return 0;\n}\n```",
    "最长公共子序列",
    "include",
    "include",
    "define MAX 100",
    "int c[MAX][MAX];",
    "// 接受字符串x和y，寻找x和y的最长公共子序列\nvoid LCS_LENGTH(char x, char y){\n    // 初始化\n    int xLen = strlen(x), yLen = strlen(y);\n    for(int i=1; i<xLen; i++){\n        if(y[0] == x[i] || c[i-1][0] == 1){\n            c[i][0] = 1;\n        }\n    }\n    for(int i=1; i<yLen; i++){\n        if(x[0] == y[i] || c[0][i-1] == 1){\n            c[0][i] = 1;\n        }\n    }\n    for(int i=1; i        for(int j=1; j\\            if(x[i] == y[j]){                c[i][j] = c[i-1][j-1] + 1;            }else if(c[i-1][j] >= c[i][j-1]){   // xi!=yj时f(x)=max(c[i-1,j],c[i,j-1])\n                c[i][j] = c[i-1][j];            }else{                c[i][j] = c[i][j-1];            }        }    }}// 最长公共子序列 输入字符串x,y 字符串长度-1是i,j\nvoid PRINT_LCS(char *x, char *y, int i, int j){    if(i == -1 || j == -1){        return;    }    if(x[i] == y[j]){        PRINT_LCS(x, y, i-1, j-1);        printf(\"%c \", x[i]);    }else if(c[i-1][j] >= c[i][j-1]){\n        PRINT_LCS(x, y, i-1, j);\n    }else{\n        PRINT_LCS(x, y, i, j-1);\n    }\n}",
    "int main() {\n    char x[MAX] = \"ABCBDAB\", y[MAX] = \"BDCABA\";\n    LCS_LENGTH(x,y);\n    PRINT_LCS(x, y, strlen(x)-1, strlen(y)-1);\n    return 0;\n}\n```",
    "最长公共子串",
    "cpp\n// 最长公共子串 输入字符串s1和s2 返回最长公共子串的长度max  \nint PRINT_LCS2(char *s1, char *s2){  \n    int max = 0, start = 0, len1 = strlen(s1), len2 = strlen(s2);  \n    for(int i=1; i<=len1; i++){  \n        for(int j=1; j<=len2; j++){  \n            if(s1[i-1] == s2[j-1])  \n                dp[i][j] = dp[i-1][j-1] + 1;  \n            if(dp[i][j] > max){  \n                max = dp[i][j]; // 最长公共子串的长度  \n                start = i - max; // 该子串的起始点位  \n            }  \n        }  \n    }  \n    return max;\n}",
    "最优二叉搜索树",
    "include",
    "define MAX (1000+10)",
    "define MAXE 1000000000",
    "double p[MAX], q[MAX], w[MAX][MAX], e[MAX][MAX];\n// p,q为概率，表示其搜索频率\n// e[i,j]为在包含关键字k_i,..,k_j的最优二叉搜索树中进行一次搜索的期望代价\n// w[i,j]为在关键字k_i,..,k_j的期望之和\nint root[MAX][MAX], n = 5;",
    "void optimalBST(double p,double q,int n);\nvoid printRoot();\nvoid printOptimalBST(int i,int j,int r);",
    "int main() {\n    scanf(\"%d\", &n);\n    for(int i=1; i<=n; i++){\n        scanf(\"%lf\", &p[i]);\n    }\n    for(int i=0; i<=n; i++){\n        scanf(\"%lf\", &q[i]);\n    }\n    optimalBST(p,q,n);\n    printf(\"%lf\\n\", e[1][n]);   // 最小的cost\n    printRoot();    // 输出所有的根\n    printf(\"最优二叉树结构：best structure\\n\");\n    printOptimalBST(1,n,-1);    // 深度优先遍历输出最优二叉树的结构\n    return 0;\n}\n//接受概率列表p和q及规模n作为输入，返回cost表e和根表root。\nvoid optimalBST(double p,double q,int n){\n    // 初始化只包括虚拟键的子树\n    for (int i = 1;i <= n + 1;++i){\n        w[i][i - 1] = q[i - 1];\n        e[i][i - 1] = q[i - 1];\n    }",
    "}",
    "// 输出最优二叉查找树所有子树的根\nvoid printRoot(){\n    printf(\"各子树的根 roots\\n\");\n    for (int i = 1;i <= n;++i){\n        for (int j = 1;j <= n;++j){\n            printf(\"%d \", root[i][j]);\n        }\n        puts(\"\");\n    }\n    puts(\"\");\n}",
    "// 打印最优二叉查找树的结构\n// 打印出[i,j]的子树，它是根r的左子树和右子树\nvoid printOptimalBST(int i,int j,int r){\n    int rootChild = root[i][j];\n    if (rootChild == root[1][n]){\n        // 输出整棵树的根\n        printf(\"k%d is root\\n\", rootChild);\n        printOptimalBST(i,rootChild - 1,rootChild);\n        printOptimalBST(rootChild + 1,j,rootChild);\n        return;\n    }\n    if (j < i - 1){\n        return;\n    }else if (j == i - 1){      // 遇到虚拟键\n        if (j < r){\n            printf(\"d%d is k%d's left son\\n\", j, r);\n        }else {\n            printf(\"d%d is k%d's right son\\n\", j, r);\n        }\n        return;\n    }else{      // 遇到内部结点\n        if (rootChild < r){\n            printf(\"k%d is k%d's left son\\n\", rootChild, r);\n        }else{\n            printf(\"k%d is k%d's right son\\n\", rootChild, r);\n        }\n    }\n    printOptimalBST(i,rootChild - 1,rootChild);\n    printOptimalBST(rootChild + 1,j,rootChild);\n}\n```",
    "最小编辑距离",
    "```cpp",
    "include",
    "include",
    "define MAX 2005",
    "using namespace std;\nint ans;\nint dp[2][MAX];\nint min3(int a, int b, int c) {\n    int m = a;\n    if (b < m)\n        m = b;\n    if (c < m)\n        return c;\n    return m;\n}\nint minDistance(string word1, string word2) {\n    int l1 = word1.length();\n    int l2 = word2.length();\n    for (int j = 0; j <= l2; j++)\n        dp[0][j] = j;   // 初始化dp[0]为从空字符串到word2的编辑距离\n    for (int i = 1; i <= l1; i++) {\n        // dp[0][j]: word1前i-1个字符转化成word2的前j个字符的编辑距离\n        // dp[1][j]: word1前i个字符转化成word2的前j个字符的编辑距离\n        dp[1][0] = i;\n        for (int j = 1; j <= l2; j++)\n            if (word1[i - 1] == word2[j - 1])\n                dp[1][j] = dp[0][j - 1];  // 如果相同，和i-1到j-1的编辑距离一样\n            else {\n                dp[1][j] = min3(dp[0][j - 1], dp[0][j], dp[1][j - 1]) + 1;\n                // dp[0][j-1] 和i-1转成j-1一样，相当于word1换个字\n                // dp[0][j] 和i-1转成j一样，相当于word1加个字\n                // dp[1][j-1] 和i转成j-1一样，相当于word1删个字\n            }\n        for (int j = 0; j <= l2; j++)\n            dp[0][j] = dp[1][j];\n    }\n    return dp[0][l2];\n}\nint main() {\n    string a;\n    string b;\n    cin >> a >> b;\n    cout << minDistance(a, b);\n    printf(\"\\n%d\\n\",ans);\n    return 0;\n}\ncpp\n// 进行了什么编辑操作",
    "include",
    "include",
    "define MAX 2005",
    "using namespace std;",
    "int replace_count = 0;\nint delete_count = 0;\nint insert_count = 0;\nint dp[MAX][MAX] = {};",
    "int min3(int a, int b, int c) {\n    int m = a;\n    if (b < m)\n        m = b;\n    if (c < m)\n        return c;\n    return m;\n}",
    "void printOperations(string word1, string word2, int dp[MAX][MAX]) {\n    int i = word1.length();\n    int j = word2.length();\n    while (i > 0 || j > 0) {\n        if (i > 0 && j > 0 && word1[i - 1] == word2[j - 1]) {\n            i--;\n            j--;\n        } else if (j > 0 && (i == 0 || dp[i][j] == dp[i][j - 1] + 1)) {\n            insert_count++;\n            j--;\n        } else if (i > 0 && (j == 0 || dp[i][j] == dp[i - 1][j] + 1)) {\n            delete_count++;\n            i--;\n        } else {\n            replace_count++;\n            i--;\n            j--;\n        }\n    }\n}",
    "int minDistance(string word1, string word2) {\n    int l1 = word1.length();\n    int l2 = word2.length();\n    for (int j = 0; j <= l2; j++)\n        dp[0][j] = j;\n    for (int i = 1; i <= l1; i++) {\n        dp[i][0] = i;\n        for (int j = 1; j <= l2; j++) {\n            if (word1[i - 1] == word2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1];\n            else\n                dp[i][j] = min3(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;\n        }\n    }\n    printOperations(word1, word2, dp);\n    return dp[l1][l2];\n}",
    "int main() {\n    string a;\n    string b;\n    cin >> a >> b;\n    int distance = minDistance(a, b);\n    cout << distance << endl;\n    printf(\"Replace: %d\\n\", replace_count);\n    printf(\"Delete: %d\\n\", delete_count);\n    printf(\"Insert: %d\\n\", insert_count);\n    return 0;\n}\n```",
    "最长单调子序列/LIS（Longest Increasing Subsequence）",
    "$O(n^2)$ 做法\ncpp\nint LIS(){ // a为目标数组 ans为最终得到的最长单调子序列的长度  \n    int ans=1;  \n    for(int i=1; i<=n; i++){//枚举子序列的终点  \n        dp[i]=1;// 初始化为1，长度最短为自身  \n        for(int j=1; j<i; j++){//从头向终点检查每一个元素  \n            if(a[i]>a[j]){  \n                dp[i]=max(dp[i],dp[j]+1);  // 状态转移  \n            }  \n        }\n        ans=max(ans,dp[i]);  // 比较每一个dp[i],最大值为答案  \n    }\n    return ans;\n}\nint main(){  \n    while(cin>>n){  \n        for(int i=1; i<=n; i++){ // 下标从1开始  \n            cin>>a[i];  \n        }  \n        int ans=LIS();  \n        cout<<ans<<\"\\n\";  \n    }  \n    return 0;  \n}",
    "$O(nlgn)$ 做法\ncpp\n// 严格单调递增子列的长度  \nint lsrsa(const vector<int> &a) {  \n    vector<int> sa;  \n    for (auto x: a) {  \n        if (sa.empty() || x > sa.back())  // 如果sa为空或x>sa的最后一个元素  \n            sa.push_back(x);  \n        else  \n            // 如果x<=sa的最后一个元素，二分查找找到sa中第一个>=x的数，并用x替换它。  \n            // 实际上是在尝试找到更小的元素替代sa中的元素，这样后续可能可以添加更多的元素到sa中，从而形成一个更长的子序列。  \n            *lower_bound(sa.begin(), sa.end(), x) = x;  \n    }  \n    return (int) sa.size();  \n}  \n// 单调不减子列的长度  \nint lrsa(const vector<int> &a) {  \n    vector<int> sa;  \n    for (auto x: a) {  \n        if (sa.empty() || x >= sa.back())  // 如果sa为空或x>=sa的最后一个元素  \n            sa.push_back(x);  \n        else // 如果x<sa的最后一个元素，二分查找找到sa中第一个>x的数，并用x替换它。  \n            *upper_bound(sa.begin(), sa.end(), x) = x;  \n    }  \n    return (int) sa.size();  \n}",
    "活动选择问题",
    "假定有一个 $n$ 个活动的集合 $S={a_{1}, a_{2}, ...,a_{n}}$，这些活动使用同一个资源，而这个资源在某个时刻只能供一个活动使用，每个活动 $a_{i}$ 都有一个开始时间 $s_{i}$ 和一个结束时间 $f_{i}$ ，其中 $0\\le s_{i}<f_{i}<∞$ ，如果被选中，任务 $a_i$ 发生在半开时间区间 $[s_i,f_i)$ 期间。如果两个活动时间不重叠，则称他们是兼容的。在活动选择问题中，我们希望选出一个最大兼容活动集。假定活动已按结束时间的单调递增顺序排序。\n```c",
    "include",
    "define MAX 100",
    "using namespace std;\nstruct thing{\n    int startTime, endTime;\n};\nstruct thing things[MAX], ans[MAX]; // ans 参加的活动们\nint n;\nvoid Greedy_Activity_Selector(){\n    printf(\"0 \");\n    ans[0] = things[0];\n    int lastId=0, ansNum = 1;   // 当前的最后一个活动的截止时间 当前已经参加的活动数量\n    for(int i=2; i<=n; i++){\n        if(things[i].startTime >= things[lastId].endTime){\n            ans[ansNum] = things[i];\n            ansNum++;\n            lastId = i;\n            printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n%d\", ansNum);\n}\nint cmp(const void a, const void b){\n    struct thing pa = (struct thing )a;\n    struct thing pb = (struct thing )b;\n    if(pa->endTime < pb->endTime){\n        return -1;\n    }else{\n        if(pa->startTime < pb->startTime){\n            return -1;\n        }else{\n            return 1;\n        }\n    }\n}",
    "int main() {\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &things[i].startTime);\n    }\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &things[i].endTime);\n    }\n    qsort(things, n, sizeof(struct thing), cmp);  // 按活动结束时间升序排序\n    Greedy_Activity_Selector();\n    return 0;\n}\n```",
    "0-1背包",
    "一个正在抢劫商店的小偷发现了 $n$ 个商品，第 $i$ 个商品价值 $v_i$ 美元，重 $w_i$ 磅，$v_{i}$ 和 $w_i$ 都是整数。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳 $W$ 磅重的商品，$W$ 是一个整数。他应该拿哪些商品呢?",
    "二维dp",
    "```cpp",
    "include",
    "using namespace std;\nconst int N = 1010;\nconst int MaxW = 10000;\nint n, W, v[N], w[N], f[N][MaxW];",
    "int main(){\n    cin >> n >> W;  // n物品数量 W最大重量\n    for (int i = 1; i <= n; ++i)\n        cin >> v[i] >> w[i];    // v价值 w重量\n    for (int i = 1; i <= n; i++){   // 遍历所有物品\n        for (int j = 0; j <= W; ++j){   // 重量从0到最大重量\n            f[i][j] = f[i - 1][j]; // 不选择当前物品时的价值，直接继承上一个状态的价值\n            // 如果当前背包容量可以放下当前物品，则尝试放入，更新最大价值\n            if (j >= w[i]) f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + v[i]);\n        }\n    }\n    cout << f[n][W] << endl;\n    return 0;\n}\n```",
    "一维dp",
    "```cpp",
    "include",
    "using namespace std;\nconst int N = 1010;\nint n, W, v[N], w[N], f[N];",
    "int main(){\n    cin >> n >> W;  // n物品数量 W最大重量  \n    for (int i = 1; i <= n; ++i)\n            cin >> v[i] >> w[i];  // v价值 w重量  \n    for (int i = 1; i <= n; ++i){ // 遍历所有物品\n        for (int j = W; j >= w[i]; j--){ // 逆序遍历背包容量\n            // 更新f[j]，即考虑放入当前物品i时的最大价值\n            f[j] = max(f[j], f[j - w[i]] + v[i]);\n        }\n    }\n    cout << f[W] << endl;\n    return 0;\n}\n```",
    "01背包变种，一维dp",
    "同样的 $w, v, W$，但背包容量 $W$ 极大，无法开数组 $f[0..W]$，求背包能装下的最大价值\n```cpp",
    "include",
    "using namespace std;",
    "define N 510",
    "long long n, W, v[N], w[N], f[N*N], sumV;",
    "int main(){\n    memset(f, 0x3f, sizeof(f));\n    f[0] = 0;\n    cin >> n >> W;  // n个物品 W最大重量\n    for (int i = 1; i <= n; ++i) {\n        cin >> w[i] >> v[i];    // w重量 v价值  \n        sumV += v[i];   // 最大价值  \n    }\n    for (int i = 1; i <= n; ++i){ // 遍历所有物品  \n        for(int j=sumV; j>=v[i]; j--){  // 从最大价值开始，只有在j>=v[i]的情况下才有可能装当前的物品，否则f保持不变  \n            f[j] = min(f[j], f[j-v[i]]+w[i]);   // f[j]表示包内物品价值为j时的最小重量  \n        }\n    }\n    long long ans = 0;\n    for(int j=0; j<=sumV; j++){ // 从价值为0到最大价值  \n        if(f[j] <= W){  // 如果包内重量小于W  \n            ans = j;    // 更新ans  \n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n```",
    "完全背包",
    "一个正在抢劫商店的小偷发现了 $n$ 种商品，第 $i$ 种商品价值 $v_i$ 美元，重 $w_i$ 磅，$v_{i}$ 和 $w_i$ 都是整数，每种商品都有无限个。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳 $W$ 磅重的商品，$W$ 是一个整数。他应该拿哪些商品呢?\n```cpp",
    "include",
    "using namespace std;\nconst int N = 1010;\nint n, W, v[N], w[N], f[N];",
    "int main(){\n    cin >> n >> W;      // 物品种类n 最大容量W\n    for (int i = 1; i <= n; ++i)\n        cin >> v[i] >> w[i];    // 价值v 体积w\n    for (int i = 1; i <= n; ++i){ // 遍历所有物品\n        for (int j = v[i]; j <= W; j--){ // 顺序遍历背包容量\n            // 更新f[j]，即考虑放入当前物品i时的最大价值\n            f[j] = max(f[j], f[j - v[i]] + w[i]);\n        }\n    }\n    cout << f[W] << endl;",
    "}\n```",
    "分组背包",
    "物品被分成若干组，每组中的物品只能选择一个。也就是说，从每组物品中，你只能选择一个或者不选，但不能选择多个\n```cpp",
    "include",
    "include",
    "using namespace std;\ntypedef long long ll;\nconst int MAX = 1005;\nstruct {\n    int cnt;\n    ll ID[MAX];\n} group[MAX]; //用一个结构体来存储每一组的物品编号\nll dp[MAX];     // 最大价值\nll val[MAX];    // 每个物品的价值\nll weight[MAX]; // 每个物品的重量",
    "ll group_bag(int cap, int max_group);",
    "int main() {\n    int n, W;\n    cin >> W >> n;  //  n表示物品数量，W表示背包容量\n    int a, b, k, max_group = 0;\n    for (int i = 1; i <= n; i++) {\n        cin >> a >> b >> k; // a重量  b价值  k物品所在的组号\n        weight[i] = a;\n        val[i] = b;\n        group[k].ID[group[k].cnt++] = i;\n        max_group = max(max_group, k);\n    }\n    cout << group_bag(W, max_group);\n    return 0;\n}",
    "ll group_bag(int W, int max_group) {\n    for (int i = 0; i <= max_group; i++) // 第一层循环，遍历所有组\n        for (ll j = W; j >= 0; j--) // 第二层循环，从背包容量W到0倒序遍历\n            for (int k = 0; k < group[i].cnt; k++) // 第三层循环，遍历当前组内的所有物品\n                if (j >= weight[group[i].ID[k]]) // 如果当前物品可以放入背包\n                    // 更新dp数组，选择放入或不放入当前物品，取最大值\n                    dp[j] = max(dp[j],dp[j - weight[group[i].ID[k]]] + val[group[i].ID[k]]);\n    return dp[W];\n}\n```",
    "多重背包",
    "一个正在抢劫商店的小偷发现了 $n$ 种商品，第 $i$ 种商品价值 $v_i$ 美元，重 $w_i$ 磅，$v_{i}$ 和 $w_i$ 都是整数，每种商品有 $M_{i}$ 个。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳 $W$ 磅重的商品，$W$ 是一个整数。他应该拿哪些商品呢?\n```cpp\n//二进制优化",
    "include",
    "using namespace std;\nconst int MAXN=1e5+10;\nint n,W;\nint v[MAXN],w[MAXN];\nint f[MAXN];\nint main(){\n    cin >> n >> W;  // 物品个数n和最大重量W  \n    int cnt = 0;    // 记录二进制合成后的物体数\n    for(int i=1,a,b,s; i<=n; i++)   {\n        cin>> a >> b >> s;   // 单个价值a 单个重量b 数量s\n        int k = 1;\n        while(k <= s){ // 将每个物品都按照二进制合成  \n            v[++cnt] = ka;\n            w[cnt] = kb;\n            s -= k;\n            k = 2;\n        }\n        if(s){\n            v[++cnt] = sa;\n            w[cnt] = s*b;\n        }\n    }",
    "}\n```",
    "分数背包（部分背包）",
    "一个正在抢劫商店的小偷发现了 $n$ 个商品，第 $i$ 个商品价值 $v_i$ 美元，重 $w_i$ 磅，$v_{i}$ 和 $w_i$ 都是整数，对每个商品，小偷可以拿走其一部分，而不是只能做出二元(0-1)选择。。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳 $W$ 磅重的商品，$W$ 是一个整数。他应该拿哪些商品呢?\n```c",
    "include",
    "include",
    "struct coin{\n    double w;// 重量\n    double v;// value\n    double rou;\n};",
    "int cmp(const void a, const void b){\n    struct coin pa = (struct coin )a;\n    struct coin pb = (struct coin )b;\n    if(pa->rou > pb->rou){\n        return -1;\n    }else{\n        return 1;\n    }\n}",
    "int main() {\n    int n;      // 物品个数n\n    double W;   // 最大容量W\n    scanf(\"%d%lf\", &n, &W);\n    struct coin gold[110]={};",
    "}\n```",
    "赫夫曼编码",
    "考虑一种二进制字符编码，其中每个字符用一个唯一的二进制串表示，称为码字。如果使用定长编码，需要用3位来表示6个字符:a=000，b=001，…，f=101。这种方法需要300000个二进制位来编码文件。是否有更好的编码方案呢?\n时间复杂度 $O(nlgn)$ \n```c",
    "include",
    "include",
    "include",
    "define MAX 100",
    "// 结构体\ntypedef struct Node {\n    char data;\n    int frequency;\n    struct Node left;\n    struct Node right;\n} Node;",
    "// 创建新节点的函数 return结构体指针类型 data结构体的字符 frequency字符的出现频率\nNode createNode(char data, int frequency) {\n    Node node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->frequency = frequency;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}",
    "// Huffman构建函数\nNode buildHuffmanTree(char inputText) {\n    int charCount[256] = {};\n    int length = strlen(inputText);\n    int i;",
    "}",
    "// 编写huffman编码表及打印\nvoid printHuffmanCodes(Node* root, int code[], int top, int codeTable[][256], int codeLengths[]) {\n    // root根结点 code当前字符的huffman函数 top当前字符的树的深度/huffman编码长度 \n    // codeTable所有字符的huffman编码 codeLengths 所有字符的huffman编码长度\n    if (root->left) {   // 有左子结点  \n        code[top] = 0;\n        printHuffmanCodes(root->left, code, top + 1, codeTable, codeLengths);\n    }\n    if (root->right) {  // 有右子节点  \n        code[top] = 1;\n        printHuffmanCodes(root->right, code, top + 1, codeTable, codeLengths);\n    }",
    "}",
    "// 编码函数\nvoid encodeText(Node root, char inputText, char encodedText[], int codeTable[][256], int codeLengths[]){\n    // 翻译inputText为huffman编码encodedText\n    int length = strlen(inputText);\n    int i, j;\n    for (i = 0; i < length; i++) {\n        char character = inputText[i];      // 当前处理的字符  \n        int length = codeLengths[(int)character];   // 字符转化成huffman编码后的长度  \n        for (j = 0; j < length; j++) {\n            encodedText[strlen(encodedText)] = codeTable[(int)character][j] + '0';\n        }\n    }\n}",
    "// 解码函数\nvoid decodeText(Node root, char encodedText, char* decodedText) {\n    // 翻译huffman编码encodedText为decodedText\n    int length = strlen(encodedText);\n    int i = 0;",
    "}",
    "int main() {\n    char inputText[MAX] = \"\";\n    gets(inputText);\n    Node* root = buildHuffmanTree(inputText);   // 建树\n    int code[256];  // 当前字符的huffman编码\n    int top = 0;",
    "}\n```",
    "链式前向星",
    "cpp\nstruct Edge{  \n    int to, w, next; //终点，权值，前驱  \n} e[E_MAX];  \nint cnt_E = 0;  \nint head[V_MAX]; //需要先初始化为-1    \nvoid intList(int n){  \n    memset(head, -1, sizeof(head));  \n}  \nvoid addEdge(int x, int y, int w){  \n    e[cnt_E].to = y; //保存终点    \n    e[cnt_E].next = head[x]; //添加链接    \n    head[x] = cnt_E++; //更新表头\n}",
    "BFS广度优先搜索",
    "邻接矩阵",
    "时间复杂度 $O(n^2)$\n```cpp",
    "include",
    "define MaxV (10000+10)",
    "using namespace std;\nint G[MaxV][MaxV];  // 邻接矩阵\nbool visited[MaxV];  \nint last[MaxV], d[MaxV];  // last[i]点i的前驱结点 d[i]点i的深度",
    "void BFS(int i, int n);  \nvoid printPath(int s, int v);",
    "int main(){  \n    int n, m;  \n    scanf(\"%d%d\", &n, &m);  // n顶点数 m边数\n    for(int i=0; i<m; i++){  \n        int u, v;\n        scanf(\"%d%d\", &u, &v);  \n        G[u][v] = 1;  \n    }\n    BFS(1, n);  \n    for(int i=2; i<=n; i++){ // 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到\n        if(!visited[i])\n            BFS(i,n);\n        }\n    puts(\"\");  \n    printPath(1, 4);  // 打印从点1到点4的路径\n    puts(\"\");  \n    printf(\"%d\", d[4]);  // 打印点4的高度\n    return 0;  \n}",
    "void BFS(int i, int n){  // i起始顶点 n顶点总数\n    queue Q;   // 待访问的顶点\n    Q.push(i);  // 当前节点  \n    visited[i] = true;  // 当前节点被visited过了\n    printf(\"v%d->\", i);",
    "}",
    "void printPath(int s, int v){  // s起始顶点 v终点\n    if(v == s){  \n        printf(\"%d \", s);\n    }else if(last[v] == 0){  \n        printf(\"No path from %d to %d exists\", s, v);\n    }else{  \n        printPath(s, last[v]);\n        printf(\"%d \", v);\n    }\n}\n```",
    "邻接表",
    "时间复杂度 $O(n+e)$ \n```cpp",
    "include",
    "define MaxV (10000+10)",
    "using namespace std;\ntypedef struct edge{       // 定义边结点类型\n    int adjvex;  //指向的点\n    int weight;  //边的权重\n    struct edge next;  //相邻的边\n}ELink;\ntypedef struct ver{       // 定义顶点结点类型\n    int vertex;  //顶点id\n    ELink link;  //从此顶点出发的边\n}VLink;",
    "VLink G[MaxV];\nbool visited[MaxV];\nint last[MaxV], d[MaxV];  // last[i]点i的前驱结点 d[i]点i的深度",
    "void BFS(int i, int n);\nvoid printPath(int s, int v);",
    "int main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);  // n顶点数 m边数\n    for(int i=0; i        int u, v;        scanf(\"%d%d\", &u, &v);  // u到v有边，有向的        ELink* e = (ELink*) malloc(sizeof (ELink));        e->adjvex = v, e->weight = 0, e->next = nullptr;\n        if(G[u].link == nullptr){\n            G[u].link = e;\n        }else{\n            e->next = G[u].link;\n            G[u].link = e;\n        }\n    }\n    BFS(1, n);\n    for(int i=2;i<=n;i++){   // 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到\n        if(!visited[i])\n            BFS(i,n);\n    }\n    puts(\"\");\n    printPath(1, 4);  // 打印从点1到点4的路径\n    puts(\"\");\n    printf(\"%d\", d[4]);  // 打印点4的高度",
    "}",
    "void BFS(int i, int n){\n    queue Q;   // 待访问的顶点\n    ELink* p;",
    "}",
    "void printPath(int s, int v){\n    if(v == s){\n        printf(\"%d \", s);\n    }else if(last[v] == 0){\n        printf(\"No path from %d to %d exists\", s, v);\n    }else{\n        printPath(s, last[v]);\n        printf(\"%d \", v);\n    }\n}\n```",
    "DFS深度优先搜索",
    "邻接矩阵",
    "时间复杂度 $O(n^2)$ \n```cpp",
    "include",
    "define MaxV (10000+10)",
    "using namespace std;\nint G[MaxV][MaxV];        // 邻接矩阵\nbool visited[MaxV];\nint last[MaxV], d[MaxV];  // last[i]点i的前驱结点 d[i]点i的深度",
    "void DFS(int i, int n);\nvoid printPath(int s, int v);",
    "int main(){\n    int n, m;  // n顶点数 m边数\n    scanf(\"%d%d\", &n, &m);\n    for(int i=0; i<m; i++){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u][v] = 1;\n    }\n    DFS(1, n);\n    for(int i=2;i<=n;i++){   // 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到\n        if(!visited[i])\n            DFS(i,n);\n    }\n    puts(\"\");\n    printPath(1, 4);  // 打印从点1到点4的路径\n    puts(\"\");\n    printf(\"%d\", d[4]);  // 打印点4的高度\n    return 0;\n}",
    "void DFS(int i, int n){ // i当前结点 n总结点数量\n    printf(\"v%d->\", i);\n    visited[i] = true;\n    for(int j=1; j<=n; j++){\n        if(G[i][j] == 1 && !visited[j]){\n            last[j] = i;    // 前驱\n            d[j] = d[i]+1;  // 深度\n            DFS(j, n);\n        }\n    }\n}",
    "void printPath(int s, int v){   // s起点 v终点\n    if(v == s){\n        printf(\"%d \", s);\n    }else if(last[v] == 0){\n        printf(\"No path from %d to %d exists\", s, v);\n    }else{\n        printPath(s, last[v]);\n        printf(\"%d \", v);\n    }\n}\n```",
    "邻接表",
    "时间复杂度 $O(n+e)$ \n```cpp",
    "include",
    "define MaxV (10000+10)",
    "using namespace std;\ntypedef struct edge{       // 定义边结点类型\n    int adjvex;  //指向的点\n    int weight;  //边的权重\n    struct edge next;  //相邻的边\n}ELink;\ntypedef struct ver{       // 定义顶点结点类型\n    int vertex;  //顶点id\n    ELink link;  //从此顶点出发的边\n}VLink;",
    "VLink G[MaxV];\nbool visited[MaxV];\nint last[MaxV], d[MaxV];",
    "void DFS(int i, int n);\nvoid printPath(int s, int v);",
    "int main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);  // n顶点数 m边数\n    for(int i=0; i        int u, v;  // u到v有边，有向的        scanf(\"%d%d\", &u, &v);        ELink* e = (ELink*) malloc(sizeof (ELink));        e->adjvex = v, e->weight = 0, e->next = nullptr;\n        if(G[u].link == nullptr){\n            G[u].link = e;\n        }else{\n            e->next = G[u].link;\n            G[u].link = e;\n        }\n    }\n    DFS(1, n);\n    for(int i=2;i<=n;i++){   // 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到\n        if(!visited[i])\n            DFS(i,n);\n    }\n    puts(\"\");\n    printPath(1, 4);  // 打印从点1到点4的路径\n    puts(\"\");\n    printf(\"%d\", d[4]);  // 打印点4的高度",
    "}",
    "void DFS(int i, int n){ // i当前结点 n总结点数量\n    ELink* p;\n    printf(\"v%d->\", i);\n    visited[i] = true;\n    p = G[i].link;\n    while(p != NULL){\n        int j = p->adjvex;\n        if(!visited[j]){\n            last[j] = i;    // 前驱\n            d[j] = d[i]+1;  // 深度\n            DFS(j, n);\n        }\n        p = p->next;\n    }\n}",
    "void printPath(int s, int v){   // s起点 v终点\n    if(v == s){\n        printf(\"%d \", s);\n    }else if(last[v] == 0){\n        printf(\"No path from %d to %d exists\", s, v);\n    }else{\n        printPath(s, last[v]);\n        printf(\"%d \", v);\n    }\n}\n```",
    "拓扑排序",
    "拓扑排序：对于有向无环图 $G$ 来说，如果图G包含边 $(u,v)$，则结点 $u$ 在拓扑排序中处于结点 $v$ 的前面。\n```cpp",
    "include",
    "using namespace std;",
    "define MAX_VERTICES 10010 // 定义图的最大顶点数",
    "unordered_map>graph; // 定义图的结构",
    "struct Edge {         //链式前向星，存边的起点、终点、和前驱\n    int from, to, next;\n} e[MAX_VERTICES];\nint cnt;          //存储的边数\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while(t--){\n        int head[MAX_VERTICES] = {};  //下标是起点的表头，存第一个边的编号，初始化为 -1\n        int id[MAX_VERTICES]={};  //每个点的入度\n        memset(head, -1, sizeof(head));\n        graph.clear();",
    "}\n```",
    "单源最短路径",
    "^7dd350",
    "1 Bellman-Ford算法",
    "include",
    "include",
    "using namespace std;",
    "define MAX 0x3f3f3f3f",
    "define N 1010",
    "int nodenum, edgenum, original; //点，边，起点\ntypedef struct Edge{ //边\n    int u, v;   // 起点 终点\n    int cost;   // 权重\n}Edge;",
    "Edge edge[N];\nint dis[N], pre[N]; // dis源点到每个顶点的最短距离，pre最短路径的前驱节点\nbool Bellman_Ford();\nvoid print_path(int root);",
    "int main(){\n    scanf(\"%d%d%d\", &nodenum, &edgenum, &original);\n    pre[original] = original; // 初始化源点的前驱为自己\n    for(int i = 1; i <= edgenum; ++i){\n        scanf(\"%d%d%d\", &edge[i].u, &edge[i].v, &edge[i].cost);\n    }\n    if(Bellman_Ford())\n        for(int i = 1; i <= nodenum; ++i){ //每个点最短路\n            printf(\"%d\\n\", dis[i]); // 输出源点到该顶点的最短距离\n            printf(\"Path:\");\n            print_path(i); // 打印路径\n        }\n    else // 如果存在负权回路，输出提示信息\n        printf(\"have negative circle\\n\");\n    return 0;\n}",
    "bool Bellman_Ford(){\n    for(int i = 1; i <= nodenum; ++i) //初始化\n        dis[i] = (i == original ? 0 : MAX);\n    for(int i = 1; i <= nodenum - 1; ++i) // n-1遍\n        for(int j = 1; j <= edgenum; ++j)\n            if(dis[edge[j].v] > dis[edge[j].u] + edge[j].cost){ //松弛\n                dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;\n                pre[edge[j].v] = edge[j].u; // 更新前驱节点\n            }\n    bool flag = true; // 标记是否存在负权回路 false为有\n    for(int i = 1; i <= edgenum; ++i)\n        if(dis[edge[i].v] > dis[edge[i].u] + edge[i].cost){\n            // 如果还能松弛，则存在负权回路\n            flag = false;\n            break;\n        }\n    return flag;\n}",
    "void print_path(int root){ // 打印最短路的路径（反向）\n    while(root != pre[root]){ // 前驱\n        printf(\"%d-->\", root);\n        root = pre[root];\n    }\n    if(root == pre[root])\n        printf(\"%d\\n\", root);\n}\n```",
    "2 有向无环图中的单源最短路径问题",
    "权重可以为负，不能有回路。时间复杂度$O(V+E)$\n```cpp",
    "include",
    "using namespace std;",
    "define MAX_VERTICES 10010  // 定义图的最大结点数",
    "define MAX_EDGE 10010       // 定义图的最大边数",
    "typedef struct edge{       // 定义边结点类型\n    long long adjvex;  //指向的点\n    long long weight;  //边的权重\n    struct edge next; //相邻的边\n}ELink;\ntypedef struct ver{       // 定义顶点结点类型\n    long long vertex, id, d, last;\n    // 编号 入度 到源点的距离 最短路径中的前驱结点\n    ELink link; // 与顶点相连的第一个边结点的指针\n}VLink;",
    "// 定义图的结构\nVLink G[MAX_VERTICES];",
    "void InitializeSingleSource(long long n, long long s);\nvoid Relax(long long  u, long long v, ELink* edge);\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while(t--){\n        int n, m, s;\n        scanf(\"%d%d%d\", &n, &m, &s); // 顶点数 边数 源点\n        for(int i=0; i            long long u, v, w;            scanf(\"%lld%lld%lld\", &u, &v, &w);            ELink* e = (ELink*) malloc(sizeof (ELink));            e->adjvex = v, e->weight = w, e->next = nullptr;\n            if(G[u].link == nullptr){\n                G[u].link = e;\n            }else{\n                e->next = G[u].link;\n                G[u].link = e;\n            }\n            G[v].id++;\n        }",
    "}",
    "void InitializeSingleSource(long long n, long long  s){\n    for(int i=1; i<=n; i++){\n        G[i].d = LONG_LONG_MAX;\n    }\n    G[s].d = 0;\n}",
    "void Relax(long long  u, long long v, ELink* edge){\n    if(G[v].d > G[u].d+edge->weight){\n        G[v].d = G[u].d+edge->weight;   // 更新距离\n        G[v].last = u;  // 更新前驱\n    }\n}\n```",
    "3 Dijkstra算法",
    "include",
    "include",
    "include",
    "define MaxV 2005",
    "using namespace std;",
    "struct Edge {\n    int to;\n    int weight;\n    // 构造函数，初始化目标顶点和权重\n    Edge(int t, int w) :to(t), weight(w) {}\n};",
    "//graph用邻接表表示的图 src源节点\nvectordijkstra(const vector>& graph, int src) {\n    //储存各个顶点到src顶点的距离\n    vectordis(MaxV, INT_MAX);\n    //记录访问过的顶点\n    vectorvis(MaxV, false);\n    //用优先级队列来处理距离最短的顶点，pair的第一个int存储距离，第二个int存储顶点;\n    //底层用vector来存储这个队列；greater表示从小到大排\n    priority_queue,vector\\ >,greater\\ > >pq;",
    "}",
    "int main() {\n    int n, m, source;  // 顶点数 边数 源点 \n    scanf(\"%d%d%d\", &n, &m, &source);\n    vector>graph(MaxV);\n    for(int i=0; i<m; i++){\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        graph[u].push_back(Edge(v,w)); // 有向图 u到v权重为w\n    }\n    vectorshortest_path = dijkstra(graph, source); // 起点source\n    cout << shortest_path[3]; // 顶点source到顶点3的最短路径长度\n    return 0;\n}\n```",
    "所有结点对的最短路径问题",
    "^91cc09",
    "floyd算法",
    "空间复杂度 $O(V^2)$ \n```cpp",
    "include",
    "include",
    "define V 310  // 图中节点的数量",
    "long long dist[V][V], graph[V][V], Path[V][V];\n// dist两点间的最短距离 graph图的邻接矩阵 Path最短路径的中转点",
    "void floydWarshall();\nvoid PrintPath(long long u, long long v);",
    "int main() {\n    int n, m;   // 顶点数 边数\n    scanf(\"%d%d\", &n, &m);\n    for(int i=0; i<m; i++){\n        long long u, v, w;  // 起点、终点和权重\n        scanf(\"%lld%lld%lld\", &u, &v, &w);\n        if((graph[u][v]!=0 && w<graph[u][v]) || graph[u][v] == 0){\n            // 考虑到可能有重复边\n            graph[u][v] = w;\n        }\n    }\n    floydWarshall();",
    "}",
    "void floydWarshall() {\n    // 初始化最短路径矩阵\n    for (int i = 0; i < V; i++)\n        for (int j = 0; j < V; j++){\n            if(graph[i][j] != 0){\n                dist[i][j] = graph[i][j];\n            }else{\n                dist[i][j] = LONG_LONG_MAX;\n            }\n            if(dist[i][j] < LONG_LONG_MAX && i != j){\n                Path[i][j] = j; // 初始化路径为直接连接\n            }else{\n                Path[i][j] = -1;\n            }\n        }",
    "}",
    "// 打印最短路径\nvoid PrintPath(long long u, long long v){\n    printf(\"%lld \", u);  // 打印起点\n    while(Path[u][v] != v){  // 当中转点不是终点时\n        printf(\"%lld \", Path[u][v]);  // 打印中转点\n        u = Path[u][v];  // 更新起点为中转点\n    }\n    printf(\"%lld\\n\", v);  // 打印终点\n}\n```",
    "有向图的传递闭包",
    "include",
    "define V 310  // 图中节点的数量",
    "long long dist[V][V];  // dist[i][j] i到j的可达性\nvoid floydWarshall();",
    "int main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    for(int i=0; i<m; i++){\n        long long u, v, w;\n        scanf(\"%lld%lld%lld\", &u, &v, &w);\n        dist[u][v] = 1;\n    }\n    floydWarshall();",
    "}",
    "void floydWarshall() {\n    // 初始化最短路径矩阵\n    for (int i = 0; i < V; i++)\n        dist[i][i] = 1;",
    "}\n```",
    "经过固定点的最短路径",
    "![[43cb0b9a1af4319a6b39b8a396f995b.png|350]]",
    "最大流",
    "Edmonds-Karp算法",
    "时间复杂度 $O(VE^{2})$，其中 $V$ 为点的总数，$E$ 为边的总数\n```cpp",
    "include",
    "using namespace std;",
    "const int N=210;// 最大节点数量\nconst int INF=0x7FFFFFFF;\nint n,m; // n为节点数，m为汇点编号\nint map0[N][N]; // 残留图，表示每条有向边的容量\nint pi[N];  //BFS的前驱图\nint flow_in[N]; //流入i的最大流量是flow_in[i]\nint start,end0; // 源点和汇点\nqueue q;",
    "int bfs();\nint Edmonds_Karp();",
    "int main(){\n    int i,u,v,cost;\n    while(scanf(\"%d%d\",&n,&m)!=EOF){ // 读取节点数和汇点编号\n        memset(map0,0,sizeof(map0));\n        for(i=0;i<n;i++){\n            scanf(\"%d%d%d\",&u,&v,&cost);\n            map0[u][v]+=cost; // 更新残留图的容量\n        }\n        start=1,end0=m;  // 1是源点，m是汇点\n        printf(\"%d\\n\",Edmonds_Karp());\n    }\n    return 0;\n}",
    "int bfs(){\n    int i,t;\n    while(!q.empty()) q.pop();\n    memset(pi,-1,sizeof(pi));\n    pi[start]=0; // 源点的前驱为自己\n    flow_in[start]=INF;",
    "}",
    "int Edmonds_Karp(){\n    int max_flow_in=0; // 流f的流值|f|\n    int cf_p;     // 增广路径的残留容量Cf(p)",
    "}\n```",
    "Dinic算法",
    "时间复杂度 $O(V^{2}E)$，其中 $V$ 为点的总数，$E$ 为边的总数\n+ 第一行一个正整数 T（1≤T≤10），表示数据组数。\n+ 对于每组数据，第一行四个正整数 n,m,s,t（1≤n≤100，1≤m≤5×10^3，1≤s,t≤n），n个点，m条边，计算从s到t的最大流。\n+ 接下来 m 行，每行三个正整数 ui,vi,wi（1≤ui,vi≤n，0≤wi<2^31），表示第 i 条有向边 ui→vi 的最大容量为 wi。\n+ 图中有可能存在重边和自环。\n```cpp",
    "include",
    "include",
    "include",
    "include",
    "using namespace std;\ntypedef long long ll;\nconst int V_MAX = 205; // 最大顶点数\nconst int E_MAX = 5005; // 最大边数\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nll max_stream = 0; // 最大流\nint cnt_E = 0;\nint n, m, s, t;",
    "struct Edge {\n    int to; // 边的目标顶点\n    int nxt; // 下一条边的索引\n    ll val; // 边的容量\n} e[E_MAX * 2]; // 边数组，每条边对应一条正向边和一条反向边\nint head[V_MAX]; // 邻接表的头指针数组\nint depth[V_MAX]; // 每个顶点的层次\nvoid addEdge(int x, int y, int w);\nvoid read();\nbool bfs();\nll Dinic();",
    "int main() {\n    int T;\n    cin >> T;\n    while(T--){\n        cin >> n >> m >> s >> t; // 顶点数 边数 源点 汇点\n        cnt_E = 0, max_stream = 0; // 初始化边计数器和最大流\n        fill(head + 1, head + 1 + n, -1);\n        read();\n        cout << Dinic() << '\\n';\n    }\n    return 0;\n}\nvoid addEdge(int x, int y, int w) {\n    e[cnt_E].to = y;\n    e[cnt_E].val = w;\n    e[cnt_E].nxt = head[x];\n    head[x] = cnt_E++;\n}\nvoid read() {\n    int u, v, w;\n    for (int i = 0; i < m; i++) {\n        cin >> u >> v >> w;\n        addEdge(u, v, w); // 添加正向边\n        addEdge(v, u, 0); // 添加反向边，容量为0\n    }\n}\nbool bfs() {   // bfs用于获得层次（分层图）\n    memset(depth, 0, sizeof(depth));\n    depth[s] = 1; // 源点的层次为1\n    queue q;\n    q.push(s); // 将源点加入队列\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = head[u]; i > -1; i = e[i].nxt) {\n            int v = e[i].to;\n            if (e[i].val && !depth[v]) { // 边有剩余容量且目标顶点未访问\n                depth[v] = depth[u] + 1; // 更新目标顶点的层次\n                q.push(v); // 将目标顶点加入队列\n            }\n        }\n    }\n    if (depth[t] != 0) // 如果汇点可达\n        return true; // 返回true表示存在增广路径\n    return false;\n}",
    "ll dfs(int pos, ll in) { // DFS用于寻找增广路径并计算流量\n    if (pos == t) // 如果当前顶点是汇点，则返回当前流量\n        return in;\n    ll out = 0; // 初始化当前顶点的流出量为0\n    for (int u = head[pos]; u > -1 && in; u = e[u].nxt) {\n        int v = e[u].to;\n        // 如果边有剩余容量且目标顶点的层次恰好是当前顶点层次加1\n        if (e[u].val && depth[v] == depth[pos] + 1) {\n            // 递归调用dfs寻找增广路径，并计算可以流过当前边的流量\n            ll res = dfs(v, min(e[u].val, in));\n            e[u].val -= res; // 更新正向边的容量\n            e[u ^ 1].val += res; // 更新反向边的容量\n            in -= res; // 减少当前流量\n            out += res; // 增加流出量\n        }\n    }\n    if (out == 0)\n        // 如果当前顶点没有流出量，则将其层次设为0，表示在后续的BFS中不会再访问\n        depth[pos] = 0;\n    return out;\n}\nll Dinic() {\n    while (bfs())   // 存在增广路径\n        max_stream += dfs(s, LL_INF);\n    return max_stream;\n}\n```",
    "最大二分匹配",
    "Dinic最小割/最大流算法",
    "时间复杂度 $O(VE)$ \n```cpp\n// 最大流等于最小割",
    "include",
    "include",
    "include",
    "include",
    "using namespace std;\nconst int N = 1e3+10, M = 5e5+1e4+10, INT = 0x3f3f3f3f;\n// 最大节点数(至少n+m+2) 最大边数(至少最大边数+n+m，因为有源点汇点的边) 无穷大常量\nint e[M], ne[M], f[M], h[N], idx;\n// e边的终点 ne下一条边的索引 f边的容量 h每个节点边的起始索引 idx边的索引\nint cur[N], d[N]; // cur当前弧优化 d节点层次\n// 弧优化通过记录每次DFS搜索的断点，使得下一次DFS可以直接从上次搜索的断点继续，从而跳过那些已经饱和的边\nint n, m, eNum, S, T; // n: 节点数, m: 边数, S: 源点, T: 汇点",
    "void add(int a, int b, int c);\nint dinic();\nbool bfs();\nint dfs(int u, int lim);",
    "int main(){\n    scanf(\"%d%d%d\", &n, &m, &eNum);\n    S = 0, T = n + m + 1; // 设置源点和汇点\n    memset(h, -1, sizeof h);\n    for (int i = 1; i <= n; i++) add(S, i, 1); // 添加源点到左侧点的边\n    for (int i = n + 1; i <= n+m; i++) add(i, T, 1); // 添加右侧点到汇点的边\n    for(int i = 1; i <= eNum; i++){\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        add(a, b+n, 1); // 起点 终点 容量为1\n    }\n    cout << dinic() << \"\\n\"; // 输出二分图最大匹配的边数\n    for(int i=0;i    {        if(e[i]>n && e[i]<=n+m && !f[i]) // 是右侧的边且剩余容量为0(这条边在最大流中已经被完全使用)\n        {\n            printf(\"%d %d\\n\",e[i^1],e[i]-n); // 左侧的点 右侧的点\n        }\n    }\n    return 0;\n}",
    "void add(int a, int b, int c){ // a: 起点, b: 终点, c: 容量\n    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++; // 添加正向边\n    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++; // 添加反向边，容量为0\n}",
    "// Dinic算法主函数\nint dinic(){\n    int r = 0, flow; // 初始化最大流为0\n    while(bfs()) // 当BFS可以构建分层图时\n        while(flow = dfs(S, INT))\n            r += flow; // 通过DFS寻找增广路径并累加流量\n    return r; // 返回最大流\n}",
    "// BFS用于分层图构建\nbool bfs(){\n    queue q;\n    q.push(S); // 将源点加入队列\n    memset(d, -1, sizeof d);\n    d[S] = 0, cur[S] = h[S]; // 源点的层次为0，初始化当前弧\n    while(q.size()){\n        int t = q.front(); q.pop();\n        for(int i = h[t]; ~i; i = ne[i]){ // 遍历所有邻接边\n            int ver = e[i]; // 邻接边的终点\n            if(d[ver] == -1 && f[i]){ // 如果终点未访问且正向边有容量\n                d[ver] = d[t] + 1; // 更新终点层次\n                cur[ver] = h[ver]; // 初始化当前弧\n                if(ver == T) return true; // 如果到达汇点，返回true\n                q.push(ver); // 将终点加入队列\n            }\n        }\n    }\n    return false; // 如果无法到达汇点，返回false\n}",
    "// DFS用于寻找增广路径\nint dfs(int u, int lim){\n    if(u == T) return lim; // 如果到达汇点，返回剩余流量\n    int flow = 0; // 初始化当前节点的流量为0\n    for(int i = cur[u]; ~i && flow < lim; i = ne[i]){ // 遍历当前节点所有邻接边\n        int ver = e[i]; // 邻接边的终点\n        cur[u] = i; // 更新当前弧\n        if(d[ver] == d[u] + 1 && f[i]){ // 如果终点层次正确且正向边有容量\n            int t = dfs(ver, min(f[i], lim - flow)); // 递归寻找增广路径\n            if(!t)\n                d[ver] = -1; // 如果无法增广，更新终点层次为-1\n            f[i] -= t, f[i^1] += t, flow += t; // 更新正向边和反向边的容量，累加流量\n        }\n    }\n    return flow; // 返回当前节点的流量\n}\n```",
    "匈牙利算法",
    "```cpp",
    "include",
    "using namespace std;\nconst int N=555;   // 定义最大可能的节点数\nvector G[N];  // 邻接表，用于存储每个男生的认识的女生的列表\nint match[N],vis[N];\n// match用于存储谁（i）和谁（match[i]）匹配\n// vis用于存储当前这一边搜索是否已经让某个男生找过增广路了\nbool used[N][N];   // 用于标记某个男生和女生之间是否有边\nbool hungary(int p,int op);",
    "int main(){\n    int n,m,e,a,b; // n男生数 m女生数 e边数 a男生编号 b女生编号\n    scanf(\"%d%d%d\",&n,&m,&e);\n    while(e--){\n        scanf(\"%d%d\",&a,&b); //a范围1~n b范围1~m\n        if(used[a][b]) //判重边\n            continue;\n        used[a][b]=true;\n        G[a].push_back(b);\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        if(hungary(i,i))    // 第i个男生，同时也是第i次搜寻\n            ans++;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\nbool hungary(int p,int op){  // p表示第几个男生，op表示第几趟匹配\n    if(vis[p]==op) // 如果当前男生在当前轮次已经找过增广路径，返回false\n        return false;\n    vis[p]=op;\n    for(int i:G[p]){    // 对于每个男生p，遍历一遍他认识的女生\n        if(!match[i]||hungary(match[i],op)){\n            // 如果当前的女生没被匹配到，自然可以直接让她与当前的男生p进行匹配\n            // 如果已经被匹配过，则尝试让匹配她的那个男生去再找找看其他女生（开始套娃），\n            // 如果返回true也可以正常匹配\n            match[i]=p;\n            return true;\n        }\n    }\n    return false;\n}\n```",
    "最小生成树",
    "prim-朴素版",
    "```cpp",
    "include",
    "include",
    "include",
    "using namespace std;\nconst int N = 2005,M = 5005,INF = 0x3f3f3f3f;\n// N最大节点数 M最大边数 INF无穷大\nint n,m;\nint g[N][N]; // g为图的邻接矩阵，存储所有节点之间的边权重\nint dist[N]; // dist存储从已选节点集合到未选节点集合的最小距离\nbool used[N];// used标记节点是否已被添加到最小生成树中\nint prim();",
    "int main(){\n    scanf(\"%d%d\",&n,&m); // 读取节点数和边数\n    //重要\n    memset(g,0x3f,sizeof(g));\n    for(int i = 0;i < m; i++){\n        int u,v,w; // 读取边(u, v)的权重w\n        scanf(\"%d%d%d\",&u,&v,&w);\n        g[u][v] = g[v][u] = min(g[u][v],w); // 更新邻接矩阵，保证是无向图且权重最小\n    }",
    "}",
    "int prim(){ // 返回最小生成树的权重和\n    memset(dist,0x3f,sizeof dist);\n    int res = 0; // res用于存储最小生成树的权重和\n    for(int i = 0;i < n;i++){\n        int t = -1; // t用于存储当前未选节点中距离已选节点集合最近的节点\n        for(int j = 1;j <= n; j++){\n            if((!used[j]) && (t == -1 || dist[t] > dist[j]))\n                t = j;\n        }\n        used[t] = true;\n        // 如果不是第一个节点且距离为无穷大，说明图不连通，返回无穷大\n        if(i && dist[t] == INF) return INF;\n        if(i)res += dist[t]; // 如果不是第一个节点，累加到res中",
    "}\n```",
    "prim-堆优化",
    "^890feb",
    "```cpp",
    "include",
    "using namespace std;",
    "define INF 2147483647",
    "define N (100000+10)",
    "typedef pairpii;\nstruct cmp{\n    //自定义排序方法 因为我定义的优先队列里，边权和是第二个元素，如果直接greater，它会默认按第一个元素排序\n    bool operator()(pii &a,pii &b){\n        return a.second>b.second;\n    }\n};\nvectore[N]; // 邻接表，e[i] 存储与节点 i 相连的边和对应的权重\nint d[N],vis[N],cnt,sum,n,m;\n// d存储最小距离，vis标记节点是否已访问，cnt计数，sum总权重，n节点数，m边数\npriority_queue ,cmp > q; // 优先队列，用于存储和获取最小边\nvoid add_edge(int x, int y, int z);\nvoid init(int n);\nvoid prim();",
    "int main(){\n    scanf(\"%d%d\",&n,&m); // 节点数n 边数m\n    init(n);\n    for(int i=1; i<=m; i++){\n        int x,y,z; // 边(x, y)的权重z\n        scanf(\"%d%d%d\",&x,&y,&z);\n        add_edge(x,y,z);\n    }\n    prim(); // 调用prim函数计算最小生成树的权重和\n    if (cnt==n) printf(\"%d\",sum); // 有最小生成树\n    else printf(\"orz\"); // 否则输出\"orz\"，表示图不连通\n}\nvoid add_edge(int x, int y, int z){  //邻接表存图\n    e[x].push_back(make_pair(y, z));\n    e[y].push_back(make_pair(x, z)); // 无向图，添加边(y, x)权重z\n}\nvoid init(int n){ //初始化\n    for (int i = 1; i <= n; i++) e[i].clear();\n    for (int i = 1; i <= n; i++) d[i] = INF;\n}\nvoid prim(){\n    d[1]=0; // 从节点1开始，将其距离设为0\n    q.push(make_pair(1,0)); // 将节点1和距离0加入优先队列\n    while(!q.empty() && cnt<n){ // 当队列不为空且处理过的节点数小于n时\n        int now=q.top().first; // 当前处理的节点\n        int dis=q.top().second; // 当前节点的最小距离\n        q.pop(); // 弹出当前节点\n        if(vis[now]) continue; // 如果当前节点已访问，跳过\n        cnt++; // 计数增加\n        sum += dis; // 累加到总权重\n        vis[now] = 1; // 标记当前节点为已访问\n        for(int i=0; i            int v=e[now][i].first; // 邻接节点            if(d[v]>e[now][i].second){ // 如果找到更小的距离\n                d[v]=e[now][i].second; // 更新最小距离\n                q.push(make_pair(v,d[v])); // 将新距离和节点加入优先队列\n            }\n        }\n    }\n}\n```",
    "kruskal",
    "^10b36b",
    "```cpp",
    "include",
    "include",
    "define V_MAX 300005 // 定义最大顶点数",
    "define E_MAX 500005 // 定义最大边数",
    "using namespace std;\ntypedef long long ll;\nstruct Edge {\n    int x, y, w;    // 起点 终点 权重\n    bool operator<(const Edge &b) const { return w < b.w; }\n} e[E_MAX];\nint v[V_MAX]; // 并查集数组，用于存储每个顶点的父节点\nint Find(int x); // 查找元素x所在集合的代表元素\nbool isUnion(int x, int y); // 判断两个元素是否在同一个集合中\nvoid Union(int x, int y); // 合并两个集合\nvoid makeSet(int n); // 初始化并查集",
    "int main() {\n    int n, m;\n    cin >> n >> m; // n为顶点数，m为边数\n    makeSet(n);\n    for (int i = 0; i < m; i++)\n        cin >> e[i].x >> e[i].y >> e[i].w;\n    sort(e, e + m); // 按权重从小到大对边进行排序\n    int cnt = 0; // 已加入最小生成树的边数\n    ll sum = 0; // 最小生成树的总权重\n    for(int i = 0; cnt < n - 1; i++){ // 循环直到找到n-1条边\n        if(isUnion(e[i].x, e[i].y)) // 如果两个顶点已经在同一个集合中，跳过这条边\n            continue;\n        cnt++;\n        sum += e[i].w;\n        Union(e[i].x, e[i].y); \n    }\n    cout << sum; // 输出最小生成树的总权重\n    return 0;\n}",
    "void makeSet(int n) { // 初始化并查集，每个顶点自成一个集合\n    for (int i = 1; i <= n; i++)\n        v[i] = i; // 初始化顶点i的父节点为自身\n}",
    "int Find(int x) { // 查找x所在集合的代表元素，并进行路径压缩\n    if (v[x] == x)  // 如果x是代表元素，直接返回\n        return x;\n    return v[x] = Find(v[x]); // 否则递归查找并路径压缩\n}",
    "// 判断两个元素是否在同一个集合中\nbool isUnion(int x, int y) { return Find(x) == Find(y); }\n// 合并两个集合，将y所在集合的代表元素指向x所在集合的代表元素\nvoid Union(int x, int y) { v[Find(y)] = Find(x); }\n```",
    "傅里叶变换",
    "最高次数为n，次数界可以为n, n+1, n+2, 2n\n对于次数界为n的多项式 $A(x) = \\sum\\limits_{j=0}^{n-1}a_{j}x^{j}$ ，dft求的是 $y_{k} = A(\\omega_{n}^{k})=\\sum\\limits_{j=0}^{n-1}a_{j}\\omega_{n}^{kj}$ 即 $y = DFT_{n}(a)$ 其中 $ω=cos\\frac{2π}{2^{n}}+i\\ sin\\frac{2π}{2^{n}}$",
    "多项式乘法-普通版",
    "时间复杂度 $\\Theta(nlgn)$\n```cpp",
    "include",
    "include",
    "include",
    "const double Pi = acos(-1);\nconst int MAX = 4000005;  // 字符串最大长度\nusing namespace std;\ntypedef long long ll;",
    "struct Complex {\n    double x, y; // 实部和虚部\n    Complex operator+(const Complex &b) const {\n        return {x + b.x, y + b.y};\n    }",
    "} f[MAX], p[MAX], sav[MAX];\nvoid dft(Complex f, int len);\nvoid idft(Complex f, int len);",
    "int main() {\n    int n, m;\n    cin >> n >> m;  // 第一个多项式最多n次，第二个最多m次\n    for (int i = 0; i <= n; i++)\n        cin >> f[i].x;  // 读入第一个多项式的系数\n    for (int i = 0; i <= m; i++)\n        cin >> p[i].x;  // 读入第二个多项式的系数\n    for (m += n, n = 1; n <= m; n <<= 1);  // 相乘最多n+m位\n    dft(f, n); // 对第一个多项式进行DFT\n    dft(p, n); // 对第二个多项式进行DFT\n    for (int i = 0; i < n; i++)\n        f[i] = f[i] * p[i]; // 点乘得到乘积的DFT\n    idft(f, n); // 对结果进行逆DFT\n    for (int i = 0; i <= m; i++)\n        cout << (int) (f[i].x / n + 0.49) << \" \";  // 四舍五入\n    return 0;\n}",
    "void dft(Complex f, int len) {\n    if (len == 1)\n        return;\n    Complex fl = f, fr = f + len / 2; // 分治法，将数组分为两部分\n    for (int k = 0; k < len; k++)\n        sav[k] = f[k]; // 备份原数组\n    for (int k = 0; k < len / 2; k++) {\n        fl[k] = sav[k << 1]; // 分配偶数次的系数到左子数组\n        fr[k] = sav[k << 1 | 1]; // 分配奇数次的系数到右子数组\n    }\n    dft(fl, len / 2);\n    dft(fr, len / 2);\n    Complex tG = {cos(2 * Pi / len), sin(2 * Pi / len)};  // omega_n单位根\n    Complex buf = {1, 0};  // omega初始化旋转因子\n    for (int k = 0; k < len / 2; k++) {\n        sav[k] = fl[k] + buf * fr[k]; // 合并结果\n        sav[k + len / 2] = fl[k] - buf * fr[k];\n        buf = buf * tG;  // omega = omegaomega_n更新旋转因子\n    }\n    for (int k = 0; k < len; k++)\n        f[k] = sav[k];\n}",
    "void idft(Complex f, int len) {\n    if (len == 1)\n        return;\n    Complex fl = f, *fr = f + len / 2;\n    for (int k = 0; k < len; k++)\n        sav[k] = f[k];\n    for (int k = 0; k < len / 2; k++) {\n        fl[k] = sav[k << 1];\n        fr[k] = sav[k << 1 | 1];\n    }\n    idft(fl, len / 2);\n    idft(fr, len / 2);\n    Complex tG = {cos(2 * Pi / len), -sin(2 * Pi / len)}; // 与dft唯一的区别\n    Complex buf = {1, 0};\n    for (int k = 0; k < len / 2; k++) {\n        sav[k] = fl[k] + buf * fr[k];\n        sav[k + len / 2] = fl[k] - buf * fr[k];\n        buf = buf * tG;\n    }\n    for (int k = 0; k < len; k++)\n        f[k] = sav[k];\n}\n```",
    "多项式乘法-高效版/位逆序版",
    "```cpp",
    "include",
    "include",
    "using namespace std;\nconst int maxn = 1000000 + 7;",
    "define PI acos(-1)",
    "struct Complex {\n    double x, y; // 实部和虚部\n    Complex operator+(const Complex &b) const {\n        return {x + b.x, y + b.y};\n    }",
    "};",
    "int n,m; // 两个多项式的次数\nComplex a[maxn3], b[maxn3]; // 存储多项式的系数\nint pos[maxn3]; // 定义位置数组，用于FFT中的位置交换\nvoid FFT(ComplexA, int len, int type);",
    "int main(){\n    int x;pos[0] = 0;\n    int maxLen = 1, l = 0; // maxLen为FFT的长度，l为log2(maxLen)\n    scanf(\"%d%d\", &n, &m);\n    while(maxLen < n+m+1){\n        maxLen<<=1;\n        l++;\n    }\n    for(int i = 0;i<=n;i++){ // 第一个多项式的系数\n        scanf(\"%lf\",&a[i].x);\n    }\n    for(int i = 0;i<=m;i++){ // 读取第二个多项式的系数\n        scanf(\"%lf\",&b[i].x);\n    }\n    for(int i = 0;i        pos[i] = (pos[i>>1]>>1)|((i&1)<<(l-1));\n        // 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011->110)\n        // i>>1 将i的二进制位右移一位，即去掉最低位\n        // pos[i>>1]>>1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位\n        // (i&1)<<(l-1) 取i的最低位，并将其左移到最高位的位置\n        // 通过|操作将两部分合并，得到i的位逆序\n    }",
    "}\n// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT\nvoid FFT(ComplexA, int len, int type){\n    for(int i=0; i<len; i++){//将数组A中的元素按照位逆序的位置进行交换\n        if(i<pos[i])// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过\n            swap(A[i], A[pos[i]]);//保证每对只交换一次\n    }\n    for(int L=2; L<=len; L<<=1){//循环合并的区间长度\n        int HLen = L/2;//区间的一半\n        Complex Wn = {cos(2.0PI/L), typesin(2.0PI/L)}; // 计算单位根\n        for(int R=0; R<len; R+=L){//每个小区间的起点\n            Complex w = {1,0}; // 初始化旋转因子\n            for(int k=0; k<HLen; k++, w=wWn){//求该区间下的值\n                Complex Buf = A[R+k];//蝴蝶操作，去掉odd和even数组，使变化原地进行\n                A[R+k] =  A[R+k] + wA[R+k+HLen];\n                A[R+k+HLen] = Buf - w*A[R+k+HLen];\n            }\n        }\n    }\n    if (type == -1) {\n        for (int i = 0; i < len; i++) {\n            A[i].x /= len;\n            A[i].y /= len;\n        }\n    }\n}\ncpp\n// 位逆序代码",
    "include",
    "include",
    "using namespace std;\nconst int maxn = 1000000 + 7;",
    "define PI acos(-1)",
    "struct Complex {\n    int x, y; // 实部和虚部\n    Complex operator+(const Complex &b) const {\n        return {x + b.x, y + b.y};\n    }\n    Complex operator-(const Complex &b) const {\n        return {x - b.x, y - b.y};\n    }\n    Complex operator*(const Complex &b) const {\n        return {x * b.x - y * b.y, x * b.y + y * b.x};\n    }\n};",
    "int n,m; // 两个多项式的次数\nComplex a[maxn3], b[maxn3]; // 存储多项式的系数\nint pos[maxn3]; // 定义位置数组，用于FFT中的位置交换\nvoid FFT(ComplexA, int len, int type);",
    "int main(){\n    int x;pos[0] = 0;\n    int maxLen = 1, l = 0; // maxLen为FFT的长度，l为log2(maxLen)\n    scanf(\"%d\", &n);\n    while(maxLen < n){\n        maxLen<<=1;\n        l++;\n    }\n    for(int i = 0;i        scanf(\"%d\",&a[i].x);    }    for(int i = 0;i\\        pos[i] = (pos[i>>1]>>1)|((i&1)<<(l-1));\n        // 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011->110)\n        // i>>1 将i的二进制位右移一位，即去掉最低位\n        // pos[i>>1]>>1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位\n        // (i&1)<<(l-1) 取i的最低位，并将其左移到最高位的位置\n        // 通过|操作将两部分合并，得到i的位逆序\n    }\n    FFT(a,maxLen,1);\n    for(int i=0; i<n; i++){\n        printf(\"%d \", a[i].x);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT\nvoid FFT(Complex*A, int len, int type){\n    for(int i=0; i<len; i++){//将数组A中的元素按照位逆序的位置进行交换\n        if(i<pos[i])// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过\n            swap(A[i], A[pos[i]]);//保证每对只交换一次\n    }\n}\n```",
    "高精度乘法",
    "```cpp",
    "include",
    "include",
    "using namespace std;\nconst int maxn = 1000000 + 7;",
    "define PI acos(-1)",
    "struct Complex {\n    double x, y; // 实部和虚部\n    Complex operator+(const Complex &b) const {\n        return {x + b.x, y + b.y};\n    }",
    "};",
    "int n,m; // 两个多项式的次数\nComplex a[maxn3], b[maxn3]; // 存储多项式的系数\nlong long ans[maxn3];\nint pos[maxn3]; // 定义位置数组，用于FFT中的位置交换\nvoid FFT(Complex*A, int len, int type);",
    "int main(){\n    int t;\n    scanf(\"%d\", &t);\n    while(t--){\n        int x;pos[0] = 0;\n        int maxLen = 1, l = 0; // maxLen为FFT的长度，l为log2(maxLen)\n        char str1[maxn], str2[maxn];\n        scanf(\" %s %s\", str1, str2); // 读取两个大数\n        n = strlen(str1);\n        m = strlen(str2);\n        while(maxLen < n+m+1){\n            maxLen<<=1;\n            l++;\n        }\n        for(int i=0; i<=maxLen; i++){\n            a[i].y = a[i].x = b[i].y = b[i].x = ans[i] = 0;\n        }\n        for(int i = 0; i < n; i++) { // 将第一个大数的字符转换为数字，并倒序存储\n            a[i].x = str1[n - i - 1] - '0';\n        }\n        for(int i = 0; i < m; i++) {\n            b[i].x = str2[m - i - 1] - '0';\n        }\n        for(int i = 0;i            pos[i] = (pos[i>>1]>>1)|((i&1)<<(l-1));\n            // 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011->110)\n            // i>>1 将i的二进制位右移一位，即去掉最低位\n            // pos[i>>1]>>1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位\n            // (i&1)<<(l-1) 取i的最低位，并将其左移到最高位的位置\n            // 通过|操作将两部分合并，得到i的位逆序\n        }",
    "}\n// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT\nvoid FFT(ComplexA, int len, int type){\n    for(int i=0; i<len; i++){//将数组A中的元素按照位逆序的位置进行交换\n        if(i<pos[i])// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过\n            swap(A[i], A[pos[i]]);//保证每对只交换一次\n    }\n    for(int L=2; L<=len; L<<=1){//循环合并的区间长度\n        int HLen = L/2;//区间的一半\n        Complex Wn = {cos(2.0PI/L), typesin(2.0PI/L)}; // 计算单位根\n        for(int R=0; R<len; R+=L){//每个小区间的起点\n            Complex w = {1,0}; // 初始化旋转因子\n            for(int k=0; k<HLen; k++, w=wWn){//求该区间下的值\n                Complex Buf = A[R+k];//蝴蝶操作，去掉odd和even数组，使变化原地进行\n                A[R+k] =  A[R+k] + wA[R+k+HLen];\n                A[R+k+HLen] = Buf - w*A[R+k+HLen];\n            }\n        }\n    }\n    if (type == -1) { // 归一化\n        for (int i = 0; i < len; i++) {\n            A[i].x /= len;\n            A[i].y /= len;\n        }\n    }\n}\n```",
    "最大公约数：欧几里得算法",
    "cpp\nint euclid(int a, int b){\n    if(b == 0){\n        return a;\n    }else{\n        return euclid(b, a%b);\n    }\n}",
    "欧几里得算法的扩展形式",
    "```cpp\n// 法1",
    "include",
    "using namespace std;",
    "int d, x, y;",
    "void extendedEuclid(int a, int b){\n    if(b == 0){\n        d = a, x = 1, y = 0;\n    }else{\n        extendedEuclid(b, a%b);\n        int tempX = x;\n        x = y, y = tempX-(int)floor(a/b)y;\n    }\n}\nint main() {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    extendedEuclid(a, b);\n    printf(\"%d = gcd(%d, %d) = %d%d+%d*%d\", d, a, b, a, x, b, y);\n    return 0;\n}\n```",
    "同余方程 $ax ≡ b (mod\\ m)$",
    "$ax ≡ b (mod\\ m)$ 即 $ax - b = km$ \n1. 通解形式：线性同余方程 ax ≡ b (mod m) 的通解可以表示为 x = x0 + km/d，其中 x0 是一个特解，k 是任意整数，d = gcd(a, m)。\n2. 遍历所有解：解的周期性为 d，我们可以通过遍历 k 从 0 到 d-1 来找到所有可能的解。\ncpp\n// 计算同余方程的所有解  \nint f(long long a,long long b,long long m){  \n    extendedEuclid(a,m);  \n    if(b%d) // 同余方程有解的前提是b是d（a和m的最大公约数的倍数）  \n        return -1;//无解  \n    x=x*(b/d)%m; // 一个特解  \n    for(int i=1; i<=d; i++){ // 遍历所有解的可能  \n        long long tempAns = (x+(i-1)*m/d)%m;  \n        while(tempAns<0){ // 确保解为正数  \n            tempAns += m;  \n        }  \n        if(tempAns < ans){ // 更新解为最小的解  \n            ans = tempAns;  \n        }  \n    }  \n    printf(\"%lld\", ans);  \n}",
    "字符串匹配",
    "Rabin-Karp算法 双哈希",
    "预处理时间 $\\Theta(m)$，最坏运行时间 $\\Theta((n-m+1)m)$，期望运行时间 $O(n)+O(m(v+\\frac{n}{q}))$ \n```cpp",
    "include",
    "include",
    "using namespace std;",
    "void Rabin_Karp_search(const string &T, const string &P, int d, int q1, int q2);",
    "int main() {\n    string T = \"Rabin–Karp string search algorithm: Rabin-Karp\";  // 文本字符串\n    string P = \"Rabin\";  // 模式字符串\n    int q1 = 101; // 第一个质数，用于取模运算\n    int q2 = 103; // 第二个质数，用于取模运算\n    int d = 52; // a到z 大小写\n    Rabin_Karp_search(T, P, d, q1, q2);\n    return 0;\n}",
    "// T文本字符串 P模式字符串 字符集的大小 两个用于取模运算的质数\nvoid Rabin_Karp_search(const string &T, const string &P, int d, int q1, int q2){\n    int m = P.length(); // 模式字符串的长度\n    int n = T.length(); // 文本字符串的长度\n    int i, j;\n    int p1 = 0, p2 = 0; // 模式字符串的双哈希值\n    int t1 = 0, t2 = 0; // 文本字符串的双哈希值\n    int h1 = 1, h2 = 1; // 用于计算哈希值的基数",
    "}\n```",
    "字符匹配有限自动机",
    "```cpp",
    "include",
    "using namespace std;",
    "include",
    "define total_chars 256 // 字符集的总数，通常是256（ASCII字符集大小）",
    "define trans_func(i, j) (trans_func[(i) * (m+1) + (j)])",
    "// 定义转换函数的宏，用于访问转换表\nvoid transition(int* trans_func, string &pattern);\nvoid FSA(string &pattern, string &text);",
    "int main(){\n    string pattern = \"abc\"; // 模式字符串\n    string text = \"abcabcdefghabc\"; // 文本字符串\n    FSA(pattern, text);\n}",
    "void FSA(string &pattern, string &text) {\n    int m = pattern.length();\n    int n = text.length();\n    int trans_func = new int[total_chars * m]; // 分配转换表的空间\n    transition(trans_func, pattern); // 构建转换表\n    int q = 0; // 状态机的当前状态\n    for (int i = 0; i < n; i++) {\n        q = trans_func(text[i], q); // 根据当前字符和状态更新状态\n        if (q == m) { // 如果达到最终状态（模式匹配成功）\n            printf(\"Pattern found at index :%d \", i-m+1);\n            q = 0; // 重置状态\n        }\n    }\n    // 输出一个表格，i,j表示如果第j个字符是i，会匹配跳转到哪里\n    long long ans = 0;\n    for(int j=0; j<total_chars; j++){\n        for (int i = (m+1)j+0; i < (m+1)*j+m+1; i++) {\n//            printf(\"%d \", trans_func[i]);\n            ans += trans_func[i];\n        }\n//        puts(\"\");\n    }\n//    printf(\"%lld\", ans);\n}",
    "void transition(int* trans_func, string &pattern) {\n    int m = pattern.length();\n    for (int i = 0; i < total_chars; i++) { // 初始化转换表的第一列\n        if (i == pattern[0]) { // 如果字符匹配模式的第一个字符\n            trans_func(i, 0) = 1;\n        } else {\n            trans_func(i, 0) = 0;\n        }\n    }\n    int X = 0; // 失败函数，记录了pattern的前j个字符中最长相同前后缀\n    // 例如，对于模式字符串\"ABABAC\"，其部分匹配表为[0, 0, 1, 2, 3, 0]。\n    for (int j = 1; j < m; j++) { // 构建转换表的其余部分\n        for (int i = 0; i < total_chars; i++) {\n            if (pattern[j] == i) { // 如果字符匹配模式的当前字符\n                trans_func(i, j) = j + 1; // 状态转移到下一个\n            } else {\n                trans_func(i, j) = trans_func(i, X);\n            }\n        }\n        X = trans_func(pattern[j], X);\n    }\n    // 转换表的最后一列\n    for (int i = 0; i < total_chars; i++) {\n        if (pattern[X] == i) {\n            trans_func(i, m) = X + 1;\n        } else {\n            trans_func(i, m) = trans_func(i, X);\n        }\n    }\n}\n```",
    "KMP算法",
    "时间复杂度 $O(m+n)$ \n```cpp",
    "include",
    "include",
    "include",
    "using namespace std;\nvector prefix(string str);",
    "int main(){\n    string text;\n    string key;\n    cin >> text; // 文本字符串\n    cin >> key;  // 模式字符串\n    int kl = key.length();\n    vector kmp = prefix(key); // 计算模式字符串的KMP前缀表即π\n    int k = 0;\n    for(int i = 0; i < text.length(); i++){\n        // 当匹配长度大于0且当前字符不匹配时，回退到前缀表的相应位置\n        while (k && key[k] != text[i])\n            k = kmp[k - 1];\n        // 如果当前字符匹配，增加匹配长度\n        if(text[i] == key[k])\n            k++;\n        // 如果匹配长度等于模式字符串的长度，输出匹配的位置\n        if(k == kl)\n            cout << i - k + 2 << \"\\n\";\n    }\n    for(auto x: kmp) // 输出KMP前缀表即π的每个值\n        cout << x << \" \";\n    return 0;\n}\nvector prefix(string str){\n    int l = (int) str.length();\n    vector pre(l); // 创建一个长度为l的向量来存储前缀表\n    for(int i = 1; i < l; i++){\n        int j = pre[i - 1];     // i-1的最大的前缀==后缀\n        // 如果 j>0(防止死循环) 且当前字符与前缀的最后一个字符不匹配时，回退j的值\n        while (j && str[j] != str[i])\n            j = pre[j - 1];     // ababaababab\n        if(str[j] == str[i]) // 如果当前字符与前缀的最后一个字符匹配，增加j的值\n            j++;\n        pre[i] = j; // 设置当前字符的前缀表值\n    }\n    return pre;\n}\n```",
    "确定连续线段是向左转还是向右转",
    "已知 $\\overrightarrow{p_{0}p_{1}}, \\overrightarrow{p_{1}p_{2}}$ 。计算 $(p_{2}-p_{0})\\times(p_{1}-p_{0}) = (x_{2}-x_{0})(y_{1}-y_{0})-(y_{2}-y_{0})(x_{1}-x_{0})$\n+ 结果 $<0$ ，则在 $p_{1}$ 左转\n+ 结果 $>0$ ，则在 $p_{1}$ 右转\n+ 结果 $=0$ ，则在 $p_{0}, p_{1}, p_{2}$ 三者共线\ncpp\nstruct dot{  \n    int x, y;  \n};  \nint direction(dot pi, dot pj, dot pk){  \n    // 计算向量pi-pj和向量pk-pj的叉积，用于判断方向  \n    // 如果<0，则pipj pjpk在pj左转  \n    // 如果>0，则pipj pjpk在pj右转  \n    // 否则三者共线  \n    return ((pk.x-pi.x)*(pj.y-pi.y)-(pk.y-pi.y)*(pj.x-pi.x));  \n}",
    "判定两条线是否相交",
    "cpp\nstruct dot{  \n    int x, y;  \n};  \n// 计算向量pi-pj和向量pk-pj的叉积，用于判断方向  \nint direction(dot pi, dot pj, dot pk){  \n    return ((pk.x-pi.x)*(pj.y-pi.y)-(pk.y-pi.y)*(pj.x-pi.x));  \n}  \nbool onSegment(dot pi, dot pj, dot pk){ // 判断点pk是否在线段pi-pj上  \n    if(min(pi.x, pj.x) <= pk.x && max(pi.x, pj.x) >= pk.x &&  \n            // 判断pk的x坐标是否在pi和pj的x坐标之间  \n            min(pi.y, pj.y) <= pk.y && max(pi.y, pj.y) >= pk.y){  \n            // 判断pk的y坐标是否在pi和pj的y坐标之间  \n        return true;  \n    }  \n    return false;  \n}  \n//线段p1p2与p3p4是否相交  \nbool segmentsIntersect(dot p1, dot p2, dot p3, dot p4){  \n    int d1 = direction(p3, p4, p1);  \n    int d2 = direction(p3, p4, p2);  \n    int d3 = direction(p1, p2, p3);  \n    int d4 = direction(p1, p2, p4);  \n    if(((d1>0 && d2<0)||(d1<0 && d2>0)) && ((d3>0 && d4<0)||(d3<0 && d4>0))){  \n        return true; // 如果两线段在彼此的两侧，则相交  \n    }else if(d1 == 0 && onSegment(p3, p4, p1)){  \n        return true; // 如果p1在p3p4上  \n    }else if(d2 == 0 && onSegment(p3, p4, p2)){  \n        return true; // 如果p2在p3p4上  \n    }else if(d3 == 0 && onSegment(p1, p2, p3)){  \n        return true; // 如果p3在p1p2上  \n    }else if(d4 == 0 && onSegment(p1, p2, p4)){  \n        return true; // 如果p4在p1p2上  \n    }else{  \n        return false;  \n    }  \n}",
    "确定任意一对线段是否相交",
    "$O(n^2)$\n```cpp",
    "include",
    "include",
    "include",
    "using namespace std;\nstruct Point {\n    int x, y;\n    Point operator+(const Point &b) const {\n        return {x + b.x, y + b.y};\n    }\n    Point operator-(const Point &b) const {\n        return {x - b.x, y - b.y};\n    }\n    // 重载乘法运算符，用于点与整数相乘\n    Point operator*(const int &b) const {\n        return {x * b, y * b};\n    }\n    // 重载异或运算符，用于计算两个向量的叉积\n    int operator^(const Point &b) const {\n        return x * b.y - y * b.x;\n    }\n};\nstruct Line { // 定义线段结构体\n    Point p; // 线段的起点\n    Point q; // 线段的终点\n};\nvector lines;\nint sgn(int x);\nbool intersect(Line l1, Line l2);\nbool onSegment(Point point, Line line);",
    "int main() {\n    int n, cnt = 0;\n    cin >> n; // 线段数量\n    int x1, y1, x2, y2;\n    for (int i = 0; i < n; i++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n        lines.push_back({{x1, y1}, {x2, y2}}); // 将线段添加到数组中\n    }\n    for (int i = 0; i < n; i++) // 双重循环遍历所有线段对，判断是否相交\n        for (int j = 0; j < i; j++)\n            if (intersect(lines[i], lines[j]))\n                cnt++; // 如果相交，则计数器加一\n    cout << cnt; // 输出相交线段对数\n    return 0;\n}",
    "int sgn(int x) {\n    if (x < 0) return -1;\n    if (x > 0) return 1;\n    return 0;\n}",
    "bool intersect(Line l1, Line l2) {\n    int d1 = sgn((l1.q - l1.p) ^ (l2.p - l1.p));\n    int d2 = sgn((l1.q - l1.p) ^ (l2.q - l1.p));\n    int d3 = sgn((l2.q - l2.p) ^ (l1.p - l2.p));\n    int d4 = sgn((l2.q - l2.p) ^ (l1.q - l2.p));\n    // 如果两线段在彼此的两侧，则相交\n    if (d1 * d2 < 0 && d3 * d4 < 0)\n        return true;\n    // 其中一个端点在另一条线段上，也视为相交\n    if (d1 == 0 && onSegment(l2.p, l1))\n        return true;\n    if (d2 == 0 && onSegment(l2.q, l1))\n        return true;\n    if (d3 == 0 && onSegment(l1.p, l2))\n        return true;\n    if (d4 == 0 && onSegment(l1.q, l2))\n        return true;\n    return false;\n}",
    "bool onSegment(Point point, Line line) { // 判断点是否在线段上\n    if (point.x >= min(line.p.x, line.q.x) &&\n        point.x <= max(line.p.x, line.q.x) &&\n        point.y >= min(line.p.y, line.q.y) &&\n        point.y <= max(line.p.y, line.q.y))\n        return true;\n    return false;\n}\n```",
    "寻找凸包(Graham扫描法)",
    "```cpp",
    "include",
    "include",
    "include",
    "include",
    "using namespace std;\nconst int MAX = 200005;\nconst double eps = 1e-7;\nstruct Point {\n    double x, y;\n    Point operator+(const Point &b) const {\n        return {x + b.x, y + b.y};\n    }\n    Point operator-(const Point &b) const {\n        return {x - b.x, y - b.y};\n    }\n    // 重载异或运算符，用于计算两个向量的叉积\n    double operator^(const Point &b) const {\n        return x * b.y - y * b.x;\n    }\n    bool operator<(const Point &b) const {\n        if (x != b.x)\n            return x < b.x;\n        return y < b.y;\n    }\n};\nPoint p[MAX]; // 存储所有点的数组\nPoint s[MAX]; // 用于构建凸包的栈\nint top; // 栈顶指针\nvoid selMin(int n);\nint cmp(Point a, Point b);\nbool equal(double a, double b);\ndouble dis(Point a, Point b);\nvoid graham(int n);\ndouble s_sqr(Point a, Point b, Point c);\ndouble diameter();",
    "int main() {\n    int n;\n    cin >> n; // 点的数量\n    for (int i = 0; i < n; i++)\n        cin >> p[i].x >> p[i].y; // 每个点的坐标\n    selMin(n); // 选择最小的点作为起点\n    sort(p + 1, p + n, cmp); // 根据极角排序\n    graham(n); // 执行Graham扫描算法构建凸包，凸包中的点在数组s中\n    printf(\"%.6f\", sqrt(diameter())) ; // 输出凸包的直径（开方后）\n    return 0;\n}",
    "void selMin(int n) {\n    Point Min = p[0]; // 初始化最小点\n    int IDMin = 0; // 最小点的索引\n    for (int i = 0; i < n; i++)\n        if (p[i] < Min) { // 如果找到更小的点\n            Min = p[i];\n            IDMin = i;\n        }\n    swap(p[0], p[IDMin]); // 将最小点交换到数组第一个位置\n}",
    "int cmp(Point a, Point b) {\n    double x = (a - p[0]) ^ (b - p[0]); // 计算相对于起点的叉积\n    if (x > 0) // 点a的极角大于点b的极角\n        return 1;\n    if (equal(x, 0) && (dis(a, p[0]) < dis(b, p[0])))\n        // 如点a和点b具有相同的极角且a离起点更近\n        return 1;\n    return 0;\n}",
    "double dis(Point a, Point b) { // 计算点a到点b距离\n    double x = a.x - b.x;\n    double y = a.y - b.y;\n    return x * x + y * y;\n}",
    "void graham(int n) {    // n点的个数\n    top = 1; // 初始化栈顶指针\n    s[0] = p[0]; // 起点入栈\n    s[1] = p[1]; // 第二个点入栈\n    for (int i = 2; i < n; i++) {\n        // 如果当前点与栈顶两个点构成的向量方向不是逆时针，则栈顶点出栈\n        while (top > 1 && ((p[i] - s[top]) ^ (s[top - 1] - s[top])) <= 0)\n            top--;\n        s[++top] = p[i]; // 当前点入栈\n    }\n}",
    "double s_sqr(Point a, Point b, Point c) {// 计算三角形abc的面积平方\n    return fabs((a - b) ^ (c - b));\n}",
    "double diameter() {// 计算凸包的直径（即最远点对距离）\n    double diam = 0;\n    int j = 2; // 初始化另一个点的索引\n    s[++top] = s[0]; // 将凸包的起点再次加入栈中，以便于计算\n    if (top < 3) // 如果凸包中的点少于3个，直接返回这两点间的距离\n        return dis(s[0], s[1]);\n    for (int i = 0; i < top - 1; i++) {\n        // 旋转卡壳算法，寻找以s[i]和s[i+1]为基线的最远点s[j]\n        while (s_sqr(s[i], s[i + 1], s[j]) < s_sqr(s[i], s[i + 1], s[(j + 1) % top]))\n            j = (j + 1) % top; // 更新j的值，取模是为了循环遍历凸包上的点\n        // 更新直径，取当前基线与最远点的最大距离\n        diam = max(diam, max(dis(s[i], s[j]), dis(s[i + 1], s[j])));\n    }\n    return diam;\n}\nbool equal(double a, double b){// 判断两个浮点数是否相等\n    return fabs(a - b) < eps;\n}\n```",
    "点、向量相关",
    "cpp\n//向量、点结构定义和操作\nstruct point{\n    double x,y;\n    //求点所在的象限\n    int quad(){\n        if(x>0&&y>=0) return 1;if(x<=0&&y>0) return 2;\n        if(x<0&&y<=0) return 3;if(x>=0&&y<0) return 4;\n    }\n};\n//以x升序排列，其次以y升序排列  \nbool sortXupYup(point u,point v){  \n    if(u.x!=v.x) return u.x<v.x;  \n    else return u.y<v.y;  \n}  \n//以y升序排列，其次以x升序排列  \nbool sortYupXup(point u,point v){  \n    if(u.y!=v.y) return u.y<v.y;  \n    else return u.x<v.x;  \n}  \n//对点进行极角排序\nbool sortPointAngle(point a,point b){\n    if(a.quad()!=b.quad()) return a.quad()<b.quad();\n    return (a^b)>0;\n}\n//向量取模\ndouble norm(point u){\n    return sqrt(u.x*u.x+u.y*u.y);\n}\n//点到点的距离  \ndouble disPointPoint(point u,point v){  \n    return sqrt((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y));  \n}  \n//向量的旋转  \npoint SpinPoint(point u,double zhita){  // 向量u绕原点旋转zhita角  \n    //逆时针旋转zhita角  \n    double r=sqrt(u.x*u.x+u.y*u.y);  \n    double sinphi=u.y/r,cosinphi=u.x/r; // 向量u的原始角度的正弦和余弦值  \n    double sinr=sinphi*cos(zhita)+cosinphi*sin(zhita); // 旋转后角度的正弦值  \n    double cosr=cosinphi*cos(zhita)-sinphi*sin(zhita); // 旋转后角度的余弦值  \n    point v;  \n    v.x=r*cosr;v.y=r*sinr;  \n    return v;  \n}  \n// 求一组点中的最小距离 a为点的数组 size为数组大小 u,v表示这两个点 返回最小距离  \n//分治法的入口,分治前需要排序  \ndouble mindisset1(point* a,int size,int &u,int &v){  \n    //函数起始入口  \n    double minn=1e18; // 初始化最小距离为一个非常大的数  \n    sort(a+1,a+1+size,sortXupYup); // 对点集按照x坐标升序，y坐标升序进行排序  \n    Nearestpoint(a,1,size,u,v,minn); // 调用分治法函数求解最近点对  \n    return minn; // 返回最小距离  \n}  \nvoid Nearestpoint(point *a,int l,int r,int &u,int &v,double &d){  \n    /*a点的数组 l左边界 r右边界 uv最近的两个点的index d最小距离  \n      应当注意距离的定义形式，如果为平方的形式，      则代码中绝对值的部分也应当改为平方  \n     */    if(l==r) return ; // 如果只有一个点，则没有最近点对，直接返回  \n    if(l+1==r) { // 如果只有两个点，直接计算它们之间的距离  \n        if(disPointPoint(a[l],a[r])<d) { // 这两个点的距离小于当前最小距离d  \n            d = disPointPoint(a[l], a[r]); // 更新最小距离  \n            u = l, v = r; // 更新最近点对的索引  \n        }  \n        return ;  \n    }  \n    int mid=l+r>>1,m=0;  \n    Nearestpoint(a,l,mid,u,v,d),Nearestpoint(a,mid+1,r,u,v,d);  \n    point b[r-l+10]; // 定义一个临时数组，用于存储中间区域附近的点  \n    for(int i=l;i<=r;i++){  \n        if(abs(a[i].x-a[mid].x)<d) // 如果点a[i]到中间垂线的距离小于当前最小距离d  \n            b[++m]=a[i]; // 将点a[i]加入临时数组  \n    }  \n    sort(b+1,b+1+m,sortYupXup); // 按照y坐标升序，x坐标升序对临时数组进行排序  \n    for(int i=1;i<=m;i++){  \n        for(int j=i+1;j<=m&&abs(b[i].y-b[j].y)<d;j++){ // 在临时数组中查找最近点对  \n            if(d>disPointPoint(b[i],b[j])) { // 找到更近的点对  \n                d = disPointPoint(b[i], b[j]); // 更新最小距离  \n                u = i, v = j; // 更新最近点对的索引  \n            }  \n        }  \n    }  \n    return ;  \n}",
    "maybe凸包相关",
    "cpp\n//余弦定理 计算cosC ab为邻边 c为对边  \ndouble cosinesLaw(double a,double b,double c){  \n    return (a*a+b*b-c*c)/(2*a*b);  \n}  \n//求三角形面积  \ndouble triarea(point u,point v,point w){  \n    //叉积方法  \n    return abs((v-u)^(w-u))/2.0;  \n}  \ndouble triarea(double a,double b,double c){ // abc为三角形边长  \n    //海伦公式  \n    double p=(a+b+c)/2;  \n    return sqrt(p*(p-a)*(p-b)*(p-c));  \n}  \n//求多边形的面积  \ndouble polygonArea(point *u,int size){  \n    double area=0;  \n    point begin=u[0];  \n    /*  \n      由第一个点起始的顺序叉积，其中，点可以无序，  \n      面积值为边之间连线的封闭部分，叉积能够计算容斥部分  \n     */    for(int i=2;i<size;i++) area+=((u[i-1]-begin)^(u[i]-begin))/2;  \n    return area;  \n}  \n//判断一个点是否在多边形内 u需要判断的点 v多边形顶点数组 size多边形顶点数量  \n// 多边形的顶点按照顺时针或逆时针顺序排列（先调用凸包中的sort和cmp按照极角给点排序）  \nbool Isinside(point u,point *v,int size){  \n    // 检查点u是否在以v[1]为起点的两条边界线的同一侧，如果不在同一侧，则点u不在多边形内  \n    if(((v[size]-v[1])^(u-v[1]))>0||((v[2]-v[1])^(u-v[1]))<0) return false;  \n    int l=2,r=size; // 初始化二分查找的左右边界  \n    while(l<=r){ // 进行二分查找，找到点u在多边形边界上的位置  \n        int mid=l+r>>1;  \n        // 判断点u相对于以v[1]为起点的边界线的位置  \n        if(((v[mid]-v[1])^(u-v[1]))<0) l=mid+1; // 点u在边界线的左侧，调整左边界  \n        else r=mid-1; // 点u在边界线的右侧或在线上，调整右边界  \n    }  \n    // 检查点u是否在以v[r]和v[l]为端点的边界线的同一侧或线上，如果是，则点u在多边形内  \n    if(((v[r]-v[l])^(u-v[l]))>=0) return true;  \n    return false;  \n}",
    "直线相关",
    "```cpp\n//直线结构定义和直线的极角排序\nstruct line{\n    //ax+by+c=0\n    double a,b,c;\n    //u为直线上一点，v为方向向量\n    point u,v;\n    line(){}\n    //两点确定的直线方程\n    line(point p,point q){\n        a=p.y-q.y;b=q.x-p.x;c=p.xq.y-q.xp.y;// 根据两点式求直线方程系数\n        //保证u、v两点逆时针排列\n        if((p^q)<0) swap(p,q);\n        u=p;v=q-p;\n    }\n};\n//对直线进行极角排序 极角是指直线方向向量与x轴正方向的夹角\n// 调用：sort(lines.begin(), lines.end(), sortLineAngle);\nbool sortLineAngle(line a,line b){\n    // 首先比较两条直线的方向向量所在象限\n    if(a.v.quad()!=b.v.quad()) return a.v.quad()    // 如果方向向量在同一象限，则比较它们的叉积    else return (a.v^b.v)==0?(a.v^(a.u-b.u))>0:(a.v^b.v)>0;\n}",
    "//点、线运算",
    "//点u到直线l的距离\ndouble disPointLine(point u,line l){\n    double length;\n    length = abs(l.au.x+l.bu.y+l.c)/(sqrt(l.al.a+l.bl.b));\n    return length;\n}\n//点u在直线l上的投影点 返回投影点v\npoint proPointLine(point u,line l){\n    point v;\n    // 计算投影点坐标的参数t\n    double t=(-u.xl.a-u.yl.b-l.c)/(l.al.a+l.bl.b);\n    // 根据参数t和直线方程计算投影点坐标\n    v.x=u.x+l.at;\n    v.y=u.y+l.bt;\n    return v;\n}\n// 点到线段的距离 点u到线段vw的距离 返回点到线段的距离\ndouble disPointSeg(point u, point v, point w) {\n    // d1是向量uv在向量vw上的投影长度的平方\n    long long d1 = (u.x - v.x) * (w.x - v.x) + (u.y - v.y) * (w.y - v.y);\n    // 如果投影长度小于等于0，说明点u在v点或v点延长线上，直接计算uv的距离\n    if (d1 <= 0.0) return sqrt((u.x - v.x) * (u.x - v.x) + (u.y - v.y) * (u.y - v.y));\n    // d2是向量vw的长度的平方\n    long long d2 = (v.x - w.x) * (v.x - w.x) + (v.y - w.y) * (v.y - w.y);\n    // 如果投影长度大于等于d2，说明点u在w点或w点延长线上，直接计算uw的距离\n    if (d1 >= d2) return sqrt((u.x - w.x) * (u.x - w.x) + (u.y - w.y) * (u.y - w.y));\n    // 计算点u在vw上的投影点坐标\n    double r = 1.0 * d1 / d2;\n    double px = v.x + (w.x - v.x) * r;\n    double py = v.y + (w.y - v.y) * r;\n    // 返回点u到其投影点的距离\n    return sqrt((u.x - px) * (u.x - px) + (u.y - py) * (u.y - py));\n}\n// 求两直线的交点 线段l1l2 返回交点p\npoint itsLineLine(line l1, line l2) {\n    point p;\n    // k是两直线方程系数的行列式，用于判断两直线是否平行\n    double k = l1.a * l2.b - l1.b * l2.a;\n    // 计算交点坐标，使用克莱姆法则解线性方程组\n    p.x = -(l1.c * l2.b - l1.b * l2.c) / k;\n    p.y = -(l1.a * l2.c - l1.c * l2.a) / k;\n    return p;\n}",
    "// 计算多个半平面的交集，并返回交集区域的多边形顶点\nconst line bd[4] = {// 定义四个边界直线，形成一个无限大的矩形，用于限制半平面的范围\n        line(point{-INF,-INF},point{INF,-INF}),line(point{INF,-INF},point{INF,INF}),\n        line(point{INF,INF},point{-INF,INF}),line(point{-INF,INF},point{-INF,-INF}),\n};\nvector HalfPlaneInter(vector k){ // 计算多个半平面的交集，返回交集的多边形顶点\n    // 将边界直线添加到半平面直线集合中\n    for (int i = 0; i < 4; i++) k.push_back(bd[i]);\n    // 按照直线的极角进行排序\n    sort(k.begin(), k.end(), sortLineAngle);",
    "}\n```",
    "圆相关",
    "cpp\n//圆结构  \nstruct circle{  \n    //圆心  \n    point cc;  \n    //半径  \n    double radius;  \n};  \n//求三点uvw所确定的圆c  \ncircle concyclic(point u, point v, point w) {  \n    circle c;  \n    point o;  \n    // 计算圆心坐标的系数k  \n    double k = 2 * (v.x - u.x) * (w.y - v.y) - 2 * (v.y - u.y) * (w.x - v.x);  \n    // 计算圆心o的x坐标  \n    o.x = (w.y - v.y) * (v.x * v.x + v.y * v.y - u.x * u.x - u.y * u.y) - (v.y - u.y) * (w.x * w.x + w.y * w.y - v.x * v.x - v.y * v.y);  \n    // 计算圆心o的y坐标  \n    o.y = (v.x - u.x) * (w.x * w.x + w.y * w.y - v.x * v.x - v.y * v.y) - (w.x - v.x) * (v.x * v.x + v.y * v.y - u.x * u.x - u.y * u.y);  \n    o.x /= k; o.y /= k; // 除以系数k得到圆心坐标  \n    c.cc = o; // 设置圆心  \n    c.radius = disPointPoint(o, u); // 计算半径并设置  \n    return c;  \n}  \n//求圆c与直线l的交点ans  \nvector<point> itsStrCir(line l, circle c) {  \n    double k = l.u * l.v; // 计算直线与圆心的向量点积  \n    double a = norm(l.u), b = norm(l.v); // 计算直线向量的模的平方  \n    double r = c.radius; // 圆的半径  \n    double d = k * k - b * b * (a * a - r * r); // 计算判别式  \n    vector<point> ans;  \n    // 判别式为0，有一个交点  \n    if (d == 0) ans.push_back(l.u + l.v * (-k / (b * b)));  \n    // 判别式大于0，有两个交点  \n    else {  \n        ans.push_back(l.u + l.v * ((-k + d) / (b * b)));  \n        ans.push_back(l.u + l.v * ((-k - d) / (b * b)));  \n    }  \n    // 返回交点集合  \n    return ans;  \n}  \n// 求两圆c1c2的交点ans  \nvector<point> itsCirCir(circle c1, circle c2) {  \n    vector<point> ans;  \n    point o1 = c1.cc, o2 = c2.cc; // 圆心o1和o2  \n    point a = o2 - o1; // 向量a从o1指向o2  \n    point b; // 向量b垂直于a  \n    b.x = a.y; b.y = -a.x;  \n    double r1 = c1.radius, r2 = c2.radius; // 两圆的半径  \n    double d = disPointPoint(o1, o2); // 圆心距离  \n    double S = triarea(r1, r2, d); // 两圆半径和圆心距离构成的三角形面积  \n    double h = 2 * S / d; // 交点连线的中垂线到圆心连线的距离  \n    double t = sqrt(r1 * r1 - h * h);  \n    if (r1 * r1 + d * d < r2 * r2) t = -t; // 如果两圆内含，调整t的符号  \n    // 计算交点  \n    if (h == 0) {  \n        // 如果h为0，两圆相切，只有一个交点  \n        ans.push_back(o1 + a * t / norm(a));  \n    } else {  \n        // 否则有两组交点  \n        ans.push_back(o1 + a * t / norm(a) + b * h / norm(b));  \n        ans.push_back(o1 + a * t / norm(a) - b * h / norm(b));  \n    }  \n    return ans;  \n}  \n// 求一点u与圆c的切线ans  \nvector<line> tlPointCircle(point u, circle c) {  \n    vector<line> ans;  \n    // 构造一个辅助圆，圆心为u和c.cc的中点，半径为u到c.cc距离的一半  \n    circle o;  \n    o.cc = (c.cc + u) / 2;  \n    o.radius = disPointPoint(c.cc, u) / 2;  \n    // 求辅助圆与原圆的交点  \n    vector<point> p = itsCirCir(o, c);  \n    // 如果只有一个交点，则切线只有一条  \n    if (p.size() == 1) {  \n        point v;  \n        v.x = (u - c.cc).y; v.y = -(u - c.cc).x;  \n        ans.push_back(line(u, u + v));  \n    }  \n    // 如果有两个交点，则切线有两条  \n    if (p.size() == 2) {  \n        ans.push_back(line(p[0], u));  \n        ans.push_back(line(p[1], u));  \n    }  \n    return ans;  \n}  \n// 求两圆c1c2的公切线ans  \nvector<line> comTangent(circle c1, circle c2) {  \n    vector<line> ans, q;  \n    int r1 = c1.radius, r2 = c2.radius; // 两圆的半径  \n    int d = disPointPoint(c1.cc, c2.cc); // 两圆心之间的距离  \n    point u, v, a = c2.cc - c1.cc, t; // 向量a从c1的圆心指向c2的圆心  \n    // 如果两圆半径相等，则有两条外公切线和两条内公切线  \n    if (r1 == r2) {  \n        u = c1.cc - c2.cc;  \n        v.x = u.y; v.y = -u.x; // v是u的垂直向量  \n        // 添加两条外公切线  \n        ans.push_back(line(c1.cc + v * r1 / norm(v), c1.cc + v * r1 / norm(v) + u));  \n        ans.push_back(line(c1.cc - v * r1 / norm(v), c1.cc - v * r1 / norm(v) + u));  \n    } else {  \n        // 内侧切线（内公切线）  \n        if (triarea(r1, r2, d) == 0) { // 如果两圆内切  \n            t = c1.cc + a * r1 / r2; // 计算切点  \n            q = tlPointCircle(t, c1); // 求切线  \n            while (q.size()) { ans.push_back(q.back()); q.pop_back(); } // 添加到答案中  \n        }  \n        // 外侧切线（外公切线）  \n        t = c1.cc + a * r1 / (r1 - r2); // 计算切点  \n        q = tlPointCircle(t, c1); // 求切线  \n        while (q.size()) { ans.push_back(q.back()); q.pop_back(); } // 添加到答案中  \n    }  \n    return ans;  \n}  \n// 最小圆覆盖 给定点集u和点的数量size，求最小的圆c能够覆盖所有点  \ncircle Smallestcir(point *u, int size) {  \n    random_shuffle(u + 1, u + 1 + size); // 随机打乱点集  \n    point o = u[1]; // 初始圆心为第一个点  \n    double r = 0; // 初始半径为0  \n    for (int i = 2; i <= size; i++) {  \n        if (disPointPoint(o, u[i]) <= r) continue; // 如果点在当前圆内，跳过  \n        o = (u[i] + u[1]) / 2; // 更新圆心为i和1号点的中点  \n        r = disPointPoint(u[i], u[1]) / 2; // 更新半径为i和1号点距离的一半  \n        for (int j = 2; j < i; j++) {  \n            if (disPointPoint(u[j], o) <= r) continue; // 如果点在当前圆内，跳过  \n            o = (u[i] + u[j]) / 2; // 更新圆心为i和j号点的中点  \n            r = disPointPoint(u[i], u[j]) / 2; // 更新半径为i和j号点距离的一半  \n            for (int k = 1; k < j; k++) {  \n                if (disPointPoint(u[k], o) <= r) continue; // 如果点在当前圆内，跳过  \n                circle c = concyclic(u[i], u[j], u[k]); // 求通过i、j、k三点的圆  \n                o = c.cc; r = c.radius; // 更新圆心和半径  \n            }  \n        }  \n    }  \n    circle c;  \n    c.cc = o; c.radius = r;  \n    return c;  \n}",
    "快速幂取余",
    "cpp\n// 快速幂取模函数 计算 (a^b) % m 的结果res  \nll fast_pow_mod(ll a, ll b, ll m){  \n    a %= m; // 对a取模，减少后续计算中的数值大小  \n    ll res = 1; // 初始化结果为1（任何数的0次幂都是1）  \n    while (b > 0) { // 当指数b大于0时，进行循环  \n        // 如果b的当前最低位为1，则将当前a乘到结果中  \n        if (b & 1) res = res * a % m;  \n        a = a * a % m; // 将a平方，用于下一轮循环  \n        b >>= 1; // 将b右移一位，相当于除以2  \n    }  \n    return res;  \n}",
    "快速打质数表",
    "```cpp\n// 生成小于等于n的所有素数列表prime_list\nvector generate_prime_list(int n) {\n    if (n <= 2) // 如果n小于等于2，返回只包含2的列表\n        return vector{2};\n    if (n <= 3) // 如果n小于等于3，返回包含2和3的列表\n        return vector{2, 3};\n    if (n <= 5) // 如果n小于等于5，返回包含2、3和5的列表\n        return vector{2, 3, 5};\n    vector prime_list = {2, 3, 5}; // 初始化素数列表，包含最小的三个素数2、3和5\n    int i = 1; // 初始化循环变量i\n    int x;\n    while (true) {\n        x = 6 * i + 1; // 计算6i+1，这是除了2和3之外素数的可能形式之一\n        if (x > n) // 如果x大于n，则不再继续查找\n            break;\n        if (is_prime(x, prime_list)) // 如果x是素数，则添加到素数列表中\n            prime_list.push_back(x);",
    "}",
    "// 判断一个数x是否为素数，利用已知的素数列表prime_list进行判断\nbool is_prime(int x, const vector &prime_list) {\n    for(auto u: prime_list){ // 遍历素数列表中的每个素数u\n        if(x % u == 0) // 如果x能被u整除，则x不是素数\n            return false;\n        if(u * u > x) // 如果u的平方大于x，则x是素数\n            return true;\n    }\n    return true; // 如果没有找到能整除x的素数，则x是素数\n}\n```",
    "单调栈",
    "寻找右侧第一个比当前元素小的元素：从左到右遍历元素，构造单调递减栈（从栈顶到栈底递减）\n    一个元素右侧第一个比它小的元素就是将其「弹出单调递减栈」时即将插入的元素。\n    如果该元素没有被弹出栈，则说明右侧不存在比当前元素小的元素。",
    "查找 「比当前元素大的元素」 就用 单调递增栈，查找 「比当前元素小的元素」 就用 单调递减栈。",
    "include",
    "define MAX (300000+10)",
    "int monoIncreaseStack(int height, int id);\nvoid push(long long height, long long id);\nlong long pop();\nstruct student{\n    long long id;\n    long long height;\n    long long leftBigId, rightBigId; // 左侧第一个比当前元素的height大的数的id 右侧...\n};\nstruct student stacks[MAX]; // 栈\nstruct student students[MAX]; // 所有的学生\nint Top = -1;// 栈指针",
    "int main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--){\n        int n;\n        Top = -1;\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; ++i) { // 读取所有height，单调栈处理\n            long long height;\n            scanf(\"%lld\", &height);\n            students[i].height = height;\n            students[i].id = i;\n            monoIncreaseStack(height, i);\n        }\n        while(Top != -1){\n            // 现在还在栈里的数的右侧都没有比它大的数\n            students[stacks[Top].id].rightBigId = n;\n            pop();\n        }\n    }\n    return 0;\n}\nint monoIncreaseStack(int height, int id){ // 当前元素大小height index为id\n    // 弹出所有比当前元素小的元素\n    while(Top!=-1 && height>=stacks[Top].height){\n        long long popId = pop();\n        students[popId].rightBigId = id; // id是popId右侧第一个比它大的元素\n    }\n    if(Top == -1){\n        students[id].leftBigId = -1; // id左侧没有比它大的元素\n    }else{\n        students[id].leftBigId = stacks[Top].id;\n    }\n    push(height, id); // 入栈\n}\nvoid push(long long height, long long id){\n    stacks[++Top].height = height;  // 入栈成功\n    stacks[Top].id = id;\n}\nlong long pop(){\n    return stacks[Top--].id;    // 出栈成功\n}\n```",
    "秦九韶算法/Horner 规则",
    "$A(x)=a_{n}x_{n}+a_{n−1}x_{n−1}+...+a_{1}x+a_{0}$ 在 $x_{0}$ 处的值相当于 $a_0+x_0(a_{1}+...+x_{0}(a_{n−1}+x_{0}a_{n}))$",
    "大数相乘",
    "```java",
    "include",
    "include",
    "define MAX 1000005",
    "char s1[MAX], s2[MAX];\nint a1[MAX], a2[MAX], ans[MAX];\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for(int z=0; z<n; z++){\n        int i, j, len1, len2;\n        scanf(\"%s%s\", s1, s2);\n        len1 = strlen(s1);\n        len2 = strlen(s2);\n        for (i = 0; i < len1; i++) { // 转化成数字后逆序存储\n            a1[i] = s1[len1 - 1 - i] - '0';\n        }\n        for (i = 0; i < len2; i++) { // 转化成数字后逆序存储\n            a2[i] = s2[len2 - 1 - i] - '0';\n        }\n        for (i = 0; i < len1; i++) {\n            for (j = 0; j < len2; j++) {\n                ans[i + j] += a1[i] * a2[j];\n            }\n        }\n        for (i = 0, j = 0; i < len1 + len2; i++) {\n            ans[i] += j;\n            j = ans[i] / 10; // 8进制就把10换成8\n            ans[i] %= 10; // 8进制就把10换成8\n        }\n        int flag = 0;\n        for (; ans[i] == 0; i--){ //跳过前面的0\n            if(i<0){ // 大数相乘结果本身就是0\n                printf(\"0\");\n                puts(\"\");\n                flag = 1;\n                break;\n            }\n        }     \n        if(flag == 0){\n            for (; i >= 0; i--) { // 逆序输出\n                printf(\"%d\", ans[i]);\n                ans[i] = 0;\n            }\n            puts(\"\");\n        }\n    }\n    return 0;\n}\n```",
    "随机数",
    "cpp\n// 生成0-99的随机数\ninline int Rand() {\n    return rand()%100;\n}",
    "模逆元",
    "模逆元：$a×x≡1 (mod m)$\n如果p是一个质数，a是任意整数，且a不是p的倍数，那么a的模逆元可以表示为：$a^{-1} \\equiv a^{p-2} \\ (\\text{mod} \\ p)$\n即\ncpp\nlong long qmi(long long mom, long long b, long long mod){ // 快速幂函数\n    long long res = 1;  \n    while(b){  \n        if(b & 1) res = res * mom % mod;  \n        b >>= 1;  \n        mom = mom * mom % mod;  \n    }  \n    return res;  \n}\nx = qmi(a, MOD-2, MOD); //x是a在mod MOD下的逆元",
    "MORE……"
  ],
  "sources": [
    "第1章-信号与系统基本概念-W01_173400.pdf 第1页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第2页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第3页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第4页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第5页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第6页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第7页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第8页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第9页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第10页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第11页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第12页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第13页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第14页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第15页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第16页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第17页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第18页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第19页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第20页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第21页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第22页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第23页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第24页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第25页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第27页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第28页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第29页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第30页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第31页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第32页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第33页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第34页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第35页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第36页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第37页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第38页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第39页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第40页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第41页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第42页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第43页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第44页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第45页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第46页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第47页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第48页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第49页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第50页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第51页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第52页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第53页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第54页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第55页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第56页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第57页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第58页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第59页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第60页",
    "第1章-信号与系统基本概念-W01_173400.pdf 第61页",
    "upload-14507506258348637041-《学科前沿讲座》期末报告—232115+23373125+付宁远_124929.docx 第1段",
    "upload-14507506258348637041-《学科前沿讲座》期末报告—232115+23373125+付宁远_124929.docx 第2段",
    "upload-14507506258348637041-《学科前沿讲座》期末报告—232115+23373125+付宁远_124929.docx 表格1",
    "upload-14507506258348637041-《学科前沿讲座》期末报告—232115+23373125+付宁远_124929.docx 表格1",
    "upload-14507506258348637041-《学科前沿讲座》期末报告—232115+23373125+付宁远_124929.docx 表格1",
    "upload-14507506258348637041-《学科前沿讲座》期末报告—232115+23373125+付宁远_124929.docx 表格1",
    "upload-14507506258348637041-《学科前沿讲座》期末报告—232115+23373125+付宁远_124929.docx 表格1",
    "upload-14437495790382175380-《学科前沿讲座》期末报告—232115+23373125+付宁远_124934.docx 第1段",
    "upload-14437495790382175380-《学科前沿讲座》期末报告—232115+23373125+付宁远_124934.docx 第2段",
    "upload-14437495790382175380-《学科前沿讲座》期末报告—232115+23373125+付宁远_124934.docx 表格1",
    "upload-14437495790382175380-《学科前沿讲座》期末报告—232115+23373125+付宁远_124934.docx 表格1",
    "upload-14437495790382175380-《学科前沿讲座》期末报告—232115+23373125+付宁远_124934.docx 表格1",
    "upload-14437495790382175380-《学科前沿讲座》期末报告—232115+23373125+付宁远_124934.docx 表格1",
    "upload-14437495790382175380-《学科前沿讲座》期末报告—232115+23373125+付宁远_124934.docx 表格1",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第7段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第8段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第14段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第15段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第17段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第18段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第19段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第22段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第23段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第24段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第25段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第26段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第27段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第28段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第29段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第30段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第31段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第32段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第33段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第34段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第35段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第36段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第37段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第38段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第39段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第40段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第41段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第42段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第43段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第44段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第45段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第46段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第47段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第48段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第49段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第50段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第51段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第52段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第53段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第54段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第55段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第56段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第57段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第58段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第59段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第60段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第63段",
    "upload-9513338049255030311-23373125-付宁远-网络信息法论文_125005.docx 第64段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第1段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第3段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第5段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第7段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第9段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第11段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第12段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第13段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第15段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第17段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第19段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第20段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第22段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第24段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第26段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第28段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第30段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第32段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第33段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第34段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第36段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第38段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第40段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第42段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第44段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第46段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第48段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第50段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第51段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第53段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第55段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第57段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第59段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第61段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第63段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第65段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第66段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第67段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第69段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第71段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第73段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第75段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第77段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第79段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第81段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第82段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第84段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第86段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第88段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第90段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第92段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第94段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第96段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第97段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第98段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第99段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第101段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第102段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第103段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第104段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第105段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第106段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第107段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第108段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第109段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第111段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第112段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第113段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第114段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第115段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第117段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第118段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第119段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第120段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第121段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第122段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第124段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第125段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第126段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第127段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第128段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第129段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第130段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第132段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第134段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第135段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第137段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第138段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第139段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第140段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第142段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第143段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第144段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第145段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第147段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第148段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第149段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第150段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第152段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第153段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第154段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第155段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第156段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第157段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第159段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第161段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第162段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第164段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第165段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第166段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第167段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第169段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第170段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第171段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第172段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第174段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第175段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第176段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第178段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第180段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第181段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第183段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第184段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第185段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第186段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第187段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第189段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第190段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第191段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第193段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第194段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第195段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第197段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第199段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第200段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第202段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第204段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第206段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第208段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第210段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第212段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第214段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第216段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第217段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第218段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第219段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第220段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第221段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第222段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第223段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第224段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第225段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第226段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第227段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第228段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第229段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第230段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第231段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第232段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第233段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第234段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第235段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第236段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第237段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第238段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第239段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第240段",
    "upload-6244697558691603912-ABAS ERP营销战略深度研究报告_145848.docx 第241段",
    "upload-18442962070461204815-038班+付宁远+23373125_145928.docx 第1段",
    "upload-18442962070461204815-038班+付宁远+23373125_145928.docx 第2段",
    "upload-18442962070461204815-038班+付宁远+23373125_145928.docx 第3段",
    "upload-18442962070461204815-038班+付宁远+23373125_145928.docx 表格1",
    "01 认识TensorFlow.js-1_154844.mp4 0.0-13.8s",
    "01 认识TensorFlow.js-1_154844.mp4 13.8-20.4s",
    "01 认识TensorFlow.js-1_154844.mp4 20.4-26.8s",
    "01 认识TensorFlow.js-1_154844.mp4 26.8-30.4s",
    "01 认识TensorFlow.js-1_154844.mp4 30.4-36.0s",
    "01 认识TensorFlow.js-1_154844.mp4 36.0-42.0s",
    "01 认识TensorFlow.js-1_154844.mp4 42.0-48.0s",
    "01 认识TensorFlow.js-1_154844.mp4 48.0-53.3s",
    "01 认识TensorFlow.js-1_154844.mp4 53.3-62.9s",
    "01 认识TensorFlow.js-1_154844.mp4 62.9-67.7s",
    "01 认识TensorFlow.js-1_154844.mp4 67.7-78.8s",
    "01 认识TensorFlow.js-1_154844.mp4 78.8-84.9s",
    "01 认识TensorFlow.js-1_154844.mp4 84.9-91.8s",
    "01 认识TensorFlow.js-1_154844.mp4 91.8-96.6s",
    "01 认识TensorFlow.js-1_154844.mp4 96.6-100.3s",
    "01 认识TensorFlow.js-1_154844.mp4 100.3-105.3s",
    "01 认识TensorFlow.js-1_154844.mp4 105.3-108.7s",
    "01 认识TensorFlow.js-1_154844.mp4 108.7-112.4s",
    "01 认识TensorFlow.js-1_154844.mp4 112.4-117.8s",
    "01 认识TensorFlow.js-1_154844.mp4 117.8-123.4s",
    "01 认识TensorFlow.js-1_154844.mp4 123.4-130.3s",
    "01 认识TensorFlow.js-1_154844.mp4 130.3-134.7s",
    "01 认识TensorFlow.js-1_154844.mp4 134.7-137.2s",
    "01 认识TensorFlow.js-1_154844.mp4 137.2-140.0s",
    "01 认识TensorFlow.js-1_154844.mp4 140.0-144.6s",
    "01 认识TensorFlow.js-1_154844.mp4 144.6-147.4s",
    "01 认识TensorFlow.js-1_154844.mp4 147.4-154.0s",
    "01 认识TensorFlow.js-1_154844.mp4 154.0-157.2s",
    "01 认识TensorFlow.js-1_154844.mp4 157.2-160.3s",
    "01 认识TensorFlow.js-1_154844.mp4 160.3-164.6s",
    "01 认识TensorFlow.js-1_154844.mp4 166.4-170.4s",
    "01 认识TensorFlow.js-1_154844.mp4 171.5-174.7s",
    "01 认识TensorFlow.js-1_154844.mp4 174.7-179.4s",
    "01 认识TensorFlow.js-1_154844.mp4 181.2-184.2s",
    "01 认识TensorFlow.js-1_154844.mp4 184.6-188.6s",
    "01 认识TensorFlow.js-1_154844.mp4 189.4-194.7s",
    "01 认识TensorFlow.js-1_154844.mp4 195.1-199.0s",
    "01 认识TensorFlow.js-1_154844.mp4 199.0-201.8s",
    "01 认识TensorFlow.js-1_154844.mp4 203.0-206.2s",
    "01 认识TensorFlow.js-1_154844.mp4 206.2-209.8s",
    "01 认识TensorFlow.js-1_154844.mp4 211.5-216.8s",
    "01 认识TensorFlow.js-1_154844.mp4 217.2-221.8s",
    "01 认识TensorFlow.js-1_154844.mp4 221.8-224.5s",
    "01 认识TensorFlow.js-1_154844.mp4 225.6-228.6s",
    "01 认识TensorFlow.js-1_154844.mp4 228.6-230.4s",
    "01 认识TensorFlow.js-1_154844.mp4 231.1-233.4s",
    "01 认识TensorFlow.js-1_154844.mp4 234.4-240.4s",
    "01 认识TensorFlow.js-1_154844.mp4 240.4-243.5s",
    "01 认识TensorFlow.js-1_154844.mp4 244.5-250.5s",
    "01 认识TensorFlow.js-1_154844.mp4 251.5-259.5s",
    "01 认识TensorFlow.js-1_154844.mp4 260.5-263.5s",
    "01 认识TensorFlow.js-1_154844.mp4 264.5-267.5s",
    "01 认识TensorFlow.js-1_154844.mp4 267.5-271.5s",
    "01 认识TensorFlow.js-1_154844.mp4 272.5-276.5s",
    "01 认识TensorFlow.js-1_154844.mp4 276.5-278.5s",
    "01 认识TensorFlow.js-1_154844.mp4 279.5-284.5s",
    "01 认识TensorFlow.js-1_154844.mp4 285.5-288.5s",
    "01 认识TensorFlow.js-1_154844.mp4 288.5-291.5s",
    "01 认识TensorFlow.js-1_154844.mp4 291.5-295.5s",
    "01 认识TensorFlow.js-1_154844.mp4 296.5-300.5s",
    "01 认识TensorFlow.js-1_154844.mp4 300.5-303.5s",
    "01 认识TensorFlow.js-1_154844.mp4 307.5-313.5s",
    "01 认识TensorFlow.js-1_154844.mp4 313.5-319.5s",
    "01 认识TensorFlow.js-1_154844.mp4 319.5-323.5s",
    "01 认识TensorFlow.js-1_154844.mp4 323.5-327.5s",
    "01 认识TensorFlow.js-1_154844.mp4 328.5-330.5s",
    "01 认识TensorFlow.js-1_154844.mp4 330.5-334.5s",
    "01 认识TensorFlow.js-1_154844.mp4 335.5-339.5s",
    "01 认识TensorFlow.js-1_154844.mp4 340.5-346.5s",
    "01 认识TensorFlow.js-1_154844.mp4 346.5-349.5s",
    "01 认识TensorFlow.js-1_154844.mp4 349.5-354.5s",
    "01 认识TensorFlow.js-1_154844.mp4 354.5-357.5s",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 第5段",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 第6段",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 第12段",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 第13段",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 第14段",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 第15段",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 第16段",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 第21段",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-11307266335940138682-23373125-付宁远-2024秋-学院党委会-党员发展信息_113829.docx 表格1",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 第1段",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格1",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格1",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格1",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格1",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格1",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格1",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格2",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格2",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格2",
    "upload-17336104690341029689-23373125-付宁远-“向党推优”登记表(2)(1)_095857.docx 表格2",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第1段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第3段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第5段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第6段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第7段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第9段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第10段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第11段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第13段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第14段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第15段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第17段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第18段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第19段",
    "upload-7038302007267773318-232115-23373125-付宁远-周三上午班_100332.docx 第21段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第1段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第3段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第5段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第6段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第7段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第9段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第10段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第11段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第13段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第14段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第15段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第17段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第18段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第19段",
    "upload-11956498529124046474-232115-23373125-付宁远-周三上午班_100558.docx 第21段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第1段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第3段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第5段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第6段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第7段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第9段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第10段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第11段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第13段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第14段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第15段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第17段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第18段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第19段",
    "upload-8848624105972268353-232115-23373125-付宁远-周三上午班_100905.docx 第21段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第1段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第3段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第5段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第6段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第7段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第9段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第10段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第11段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第13段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第14段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第15段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第17段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第18段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第19段",
    "upload-14719532983177820965-232115-23373125-付宁远-周三上午班_101503.docx 第21段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第1段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第3段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第5段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第6段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第7段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第9段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第10段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第11段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第13段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第14段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第15段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第17段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第18段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第19段",
    "upload-8547725340231812201-232115-23373125-付宁远-周三上午班_101609.docx 第21段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第1段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第3段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第5段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第6段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第7段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第9段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第10段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第11段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第13段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第14段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第15段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第17段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第18段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第19段",
    "upload-4378477984750873143-232115-23373125-付宁远-周三上午班_104213.docx 第21段",
    "upload-7761753159852119363-挑战性任务_171158.pdf 第1页",
    "upload-7761753159852119363-挑战性任务_171158.pdf 第2页",
    "upload-7761753159852119363-挑战性任务_171158.pdf 第3页",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第7段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第8段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第14段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第15段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第17段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第18段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第19段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第22段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第23段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第24段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第25段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第26段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第27段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第28段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第29段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第30段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第31段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第32段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第33段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第34段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第35段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第36段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第37段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第38段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第39段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第40段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第41段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第42段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第43段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第44段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第45段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第46段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第47段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第48段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第49段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第50段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第51段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第52段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第53段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第54段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第55段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第56段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第57段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第58段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第59段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第60段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第63段",
    "upload-7459045384036899714-23373125-付宁远-网络信息法论文_171256.docx 第64段",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h6",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md h1",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5",
    "upload-656514869169007779-算法板子_171449.md p",
    "upload-656514869169007779-算法板子_171449.md h5"
  ]
}