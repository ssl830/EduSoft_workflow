import axios from 'axios';
import axiosInstance from './axios';

// 通知类型枚举（严格按照后端规范）
export enum NotificationType {
  COURSE_NOTICE = 'COURSE_NOTICE',    // 课程通知
  PRACTICE_NOTICE = 'PRACTICE_NOTICE', // 练习通知
  DDL_REMINDER = 'DDL_REMINDER',      // DDL提醒
  TASK_REMINDER = 'TASK_REMINDER',    // 任务提醒
  HOMEWORK = 'HOMEWORK',              // 作业
  TASK = 'TASK',                      // 任务
  PRACTICE = 'PRACTICE',              // 在线练习
  SYSTEM = 'SYSTEM',                  // 系统通知
  DISCUSSION_REPLY = 'DISCUSSION_REPLY', // 讨论回复
  ASSIGNMENT = 'ASSIGNMENT'           // 作业分配
}

// 后端通知类型定义（严格按照后端规范）
export interface BackendNotification {
  id: number;
  userId?: number;
  title: string;
  message: string; // 后端使用message字段
  type: string; // 通知类型 
  readFlag: boolean; // 后端使用readFlag字段
  createdAt: string;
  relatedId?: number;
  relatedType?: string;
}

// 前端通知类型定义（兼容前端现有代码）
export interface Notification extends BackendNotification {
  content: string; // 前端使用content字段
  read: boolean; // 前端使用read字段
  priority?: 'low' | 'medium' | 'high' | 'urgent';
  courseName?: string;
  courseId?: string;
  dueDate?: string;
  link?: string;
  senderRole?: 'teacher' | 'assistant' | 'system';
  senderId?: string;
  targetType?: 'individual' | 'class' | 'all';
  autoGenerated?: boolean;
  taskId?: string;
  tags?: string[];
}

// 个人任务类型定义
export interface PersonalTask {
  id: number;
  title: string;
  description?: string;
  completed: boolean;
  createdAt: string;
  dueDate?: string;
  priority: 'low' | 'medium' | 'high';
  tags?: string[];
  linkedNotificationId?: number;
}

// 任务分配信息
export interface TaskAssignment {
  id: string;
  title: string;
  description: string;
  courseId: string;
  courseName: string;
  dueDate: string;
  assignedBy: string;
  assignedTo: string[];
  link?: string;
  createdAt: string;
}

// API响应类型
export interface ApiResponse<T = any> {
  code: number;
  message: string;
  data?: T;
  total?: number; // 分页查询时的总数
}

const notificationApi = {
  // 获取通知列表
  getNotifications: async (params?: {
    type?: string;
    read?: boolean;
    courseId?: string;
    limit?: number;
    offset?: number;
  }) => {
    console.log('[getNotifications] Called with params:', params);
    try {
      const response: ApiResponse<BackendNotification[]> = await axiosInstance.get('/api/notifications', { params });
      console.log('[getNotifications] Raw API response:', response);
      
      if (response && response.code === 200) {
        console.log('[getNotifications] API response code 200. Response data:', response.data);
        let backendNotifications: BackendNotification[] = [];
        
        // 检查 response.data 的类型和内容
        if (Array.isArray(response.data)) {
          // 标准情况：data 是一个通知数组
          backendNotifications = response.data;
          console.log('[getNotifications] response.data is an array. backendNotifications:', backendNotifications);
        } else if (response.data === '' || response.data == null) { 
          // 处理空字符串、null 或 undefined，表示没有通知
          backendNotifications = [];
          console.log('[getNotifications] response.data is empty string, null, or undefined. Set backendNotifications to [].');
        } else {
          // 数据存在但不是数组，也不是预期的空值类型。
          // 这是一个意外的格式。记录警告并视为空列表以防止后续错误。
          console.warn(
            '[getNotifications] API success (200) but notification data format is unexpected. Expected array, empty string, null, or undefined. Received:', 
            response.data, 
            '(Type:', typeof response.data + ')'
          );
          backendNotifications = []; 
        }
        
        const notifications = backendNotifications.map(notification => {
          if (!notification) { // Add null check for items within the array if necessary
            console.warn('[getNotifications] Encountered null/undefined notification object in backendNotifications array. Skipping this item.');
            return {
              id: 0, // Or some other unique temporary ID
              title: '无效通知',
              message: '无效的通知数据',
              type: NotificationType.SYSTEM, // Default type
              readFlag: false,
              createdAt: new Date().toISOString(),
              // Frontend specific fields
              content: '无效的通知数据',
              read: false,
              priority: 'low' as const
            };
          }
          
          // 确保 notification.type 是有效的枚举值
          const validType = Object.values(NotificationType).includes(notification.type as any) 
            ? notification.type 
            : NotificationType.SYSTEM; // 如果类型无效，默认为系统通知

          return {
            ...notification,
            content: notification.message || '', // 后端 message 映射到前端 content
            read: notification.readFlag !== undefined ? notification.readFlag : false, // 后端 readFlag 映射到前端 read
            type: validType, // 使用验证过的类型
            priority: getPriorityByType(validType) // 根据类型获取优先级
          };
        });
        
        const result = {
          notifications,
          total: response.total !== undefined ? response.total : notifications.length
        };
        console.log('[getNotifications] Processed notifications and total:', result);
        return result;
      } else {
        const errorMsg = response?.message || '获取通知失败';
        console.error('[getNotifications] API returned error or non-200 code:', errorMsg, response); 
        throw new Error(errorMsg);
      }
    } catch (error: any) {
      let errorMessage = '获取通知失败';
      if (error.response) { // Error from server (e.g. 4xx, 5xx)
        errorMessage = error.response.data?.message || 
                      `服务器错误 (${error.response.status})`;
      } else if (error.request) { // Network error or no response from server
        errorMessage = '无法连接到服务器';
      } else if (error.message && !error.response && !error.request) { // Errors thrown by our code before request or non-Axios errors
        errorMessage = error.message;
      } else if (error.message) { // Other JavaScript errors
        errorMessage = error.message;
      }
      console.error('[getNotifications] API call failed (Outer Catch):', errorMessage, error);
      throw new Error(errorMessage);
    }
  },

  // 获取未读通知数量
  getUnreadCount: async () => {
    console.log('[getUnreadCount] Called.');
    try {
      const resultFromAxios: any = await axiosInstance.get('/api/notifications/unread');
      console.log('[getUnreadCount] Raw response from axiosInstance.get:', resultFromAxios, '(Type:', typeof resultFromAxios + ')');

      // 情况1: 后端直接返回空字符串表示数量为0 
      if (resultFromAxios === '') {
        console.log('[getUnreadCount] Condition 1: Received empty string directly. Interpreting as 0 unread notifications.');
        return 0;
      }

      // 情况2: 后端返回标准的 ApiResponse 对象
      if (typeof resultFromAxios === 'object' && resultFromAxios !== null && 'code' in resultFromAxios) {
        console.log('[getUnreadCount] Condition 2: Received an object, potentially ApiResponse.');
        const apiResponse = resultFromAxios as ApiResponse<any>; // data可以是 {count: number} 或 ""
        console.log('[getUnreadCount] ApiResponse content:', apiResponse);

        if (apiResponse.code === 200) {
          console.log('[getUnreadCount] ApiResponse code is 200. Checking apiResponse.data:', apiResponse.data);
          // 子情况2.1: ApiResponse.data 是空字符串
          if (apiResponse.data === '') {
            console.log('[getUnreadCount] Sub-condition 2.1: ApiResponse.data is empty string. Interpreting as 0.');
            return 0;
          }
          // 子情况2.2: ApiResponse.data 是 { count: N }
          if (apiResponse.data && typeof apiResponse.data.count === 'number') {
            console.log('[getUnreadCount] Sub-condition 2.2: ApiResponse.data has count. Returning:', apiResponse.data.count);
            return apiResponse.data.count;
          }
          // 子情况2.3: ApiResponse.data 格式非预期
          console.warn('[getUnreadCount] Sub-condition 2.3: API success (200) but unread count data format is unexpected. Data:', apiResponse.data, '(Type:', typeof apiResponse.data + ')');
          console.log('[getUnreadCount] Defaulting to 0 due to unexpected data format.');
          return 0; // 默认返回0并记录警告
        } else {
          // ApiResponse 对象，但 code 不是 200
          const errorMsg = apiResponse.message || `获取未读通知数量失败 (代码: ${apiResponse.code})`;
          console.error('[getUnreadCount] ApiResponse code is not 200:', errorMsg, apiResponse);
          throw new Error(errorMsg);
        }
      }
      
      // 情况3: 响应格式未知 (既不是空字符串，也不是预期的ApiResponse对象)
      console.error('[getUnreadCount] Condition 3: Unknown response format. Response:', resultFromAxios);
      throw new Error('获取未读通知数量失败 (未知响应格式)');

    } catch (error: any) {
      let errorMessage = '获取未读通知数量API调用失败';
      // 检查是否是我们主动抛出的错误，如果是，则使用其消息
      if (error && error.message && !error.response && !error.request) {
          errorMessage = error.message;
          console.log('[getUnreadCount] Caught error explicitly thrown in try block:', errorMessage);
      } else if (error.response) { // Axios 的错误结构 (服务器错误)
        errorMessage = error.response.data?.message || `服务器错误 (${error.response.status})`;
      } else if (error.request) { // Axios 的错误结构 (网络错误)
        errorMessage = '无法连接到服务器';
      } else if (error.message) { // 其他JavaScript错误
        errorMessage = error.message;
      }
      console.error('[getUnreadCount] API call failed (Outer Catch):', errorMessage, error);
      throw new Error(errorMessage);
    }
  },

  // 标记通知为已读
  markAsRead: async (id: number) => {
    try {
      // response 类型是 ApiResponse
      const response: ApiResponse = await axiosInstance.put(`/api/notifications/${id}/read`);
      if (response && response.code === 200) {
        return true;
      } else {
        const errorMsg = response?.message || '标记通知已读失败';
        console.error('标记通知已读API调用失败:', errorMsg, response);
        throw new Error(errorMsg);
      }
    } catch (error: any) {
      let errorMessage = '标记通知已读API调用失败';
       if (error.response) {
        errorMessage = error.response.data?.message || `服务器错误 (${error.response.status})`;
      } else if (error.request) {
        errorMessage = '无法连接到服务器';
      } else if (error.message) {
        errorMessage = error.message;
      }
      console.error('标记通知已读API调用失败:', errorMessage, error);
      throw new Error(errorMessage);
    }
  },

  // 标记所有通知为已读
  markAllAsRead: async () => {
    try {
      // response 类型是 ApiResponse
      const response: ApiResponse = await axiosInstance.put('/api/notifications/read-all');
      if (response && response.code === 200) {
        return true;
      } else {
        const errorMsg = response?.message || '标记所有通知已读失败';
        console.error('标记所有通知已读API调用失败:', errorMsg, response);
        throw new Error(errorMsg);
      }
    } catch (error: any) {
      let errorMessage = '标记所有通知已读API调用失败';
      if (error.response) {
        errorMessage = error.response.data?.message || `服务器错误 (${error.response.status})`;
      } else if (error.request) {
        errorMessage = '无法连接到服务器';
      } else if (error.message) {
        errorMessage = error.message;
      }
      console.error('标记所有通知已读API调用失败:', errorMessage, error);
      throw new Error(errorMessage);
    }
  },

  // 批量标记为已读
  markMultipleAsRead: async (ids: number[]) => {
    try {
      const promises = ids.map(id => notificationApi.markAsRead(id));
      const results = await Promise.all(promises);
      return results.every(result => result === true);
    } catch (error: any) { 
      const errorMessage = error.message || '批量标记已读失败';
      console.error('批量标记已读失败:', errorMessage, error);
      throw new Error(errorMessage);
    }
  },

  // 删除通知
  deleteNotification: async (id: number) => {
    try {
      // response 类型是 ApiResponse
      const response: ApiResponse = await axiosInstance.delete(`/api/notifications/${id}`);
      if (response && response.code === 200) {
        return true;
      } else {
        const errorMsg = response?.message || '删除通知失败';
        console.error('删除通知API调用失败:', errorMsg, response);
        throw new Error(errorMsg);
      }
    } catch (error: any) {
      let errorMessage = '删除通知API调用失败';
      if (error.response) {
        errorMessage = error.response.data?.message || `服务器错误 (${error.response.status})`;
      } else if (error.request) {
        errorMessage = '无法连接到服务器';
      } else if (error.message) {
        errorMessage = error.message;
      }
      console.error('删除通知API调用失败:', errorMessage, error);
      throw new Error(errorMessage);
    }
  },

  // 创建通知（用于教师/助教）
  createNotification: async (notificationData: Omit<Notification, 'id' | 'createdAt'>) => {
    try {
      // response 类型是 ApiResponse<Notification>
      const response: ApiResponse<Notification> = await axiosInstance.post('/notifications', notificationData);
      if (response && response.code === 200 && response.data) {
        return response.data; 
      } else {
        const errorMsg = response?.message || '创建通知失败';
        console.error('创建通知失败:', errorMsg, response);
        throw new Error(errorMsg);
      }
    } catch (error: any) {
      let errorMessage = '创建通知API调用失败';
      if (error.response) {
        errorMessage = error.response.data?.message || `服务器错误 (${error.response.status})`;
      } else if (error.request) {
        errorMessage = '无法连接到服务器';
      } else if (error.message) {
        errorMessage = error.message;
      }
      console.error('创建通知API调用失败:', errorMessage, error);
      throw new Error(errorMessage);
    }
  },

  // 自动生成任务分配通知
  generateTaskAssignmentNotification: async (taskAssignment: TaskAssignment) => {
    // 注意：此函数仍在使用全局 axios。如果需要拦截器行为，应改为 axiosInstance
    // 并且需要根据实际的API响应调整返回值和错误处理
    const response = await axios.post('/notifications/auto-generate/task-assignment', taskAssignment);
    return response.data;
  },

  // 自动生成DDL提醒
  generateDeadlineReminder: async (taskId: string, reminderDays: number[]) => {
    // 注意：此函数仍在使用全局 axios。
    const response = await axios.post('/notifications/auto-generate/deadline-reminder', {
      taskId,
      reminderDays
    });
    return response.data;
  },

  // 任务完成时自动删除相关通知
  autoDeleteOnTaskCompletion: async (taskId: string) => {
    // 注意：此函数仍在使用全局 axios。
    const response = await axios.delete(`/notifications/auto-delete/task/${taskId}`);
    return response.data;
  },
  // 获取个人任务清单
  getPersonalTasks: async (params?: {
    completed?: boolean;
    limit?: number;
    offset?: number;
  }) => {
    try {
      // 注意：此函数仍在使用全局 axios。
      const response = await axios.get('/api/personal-tasks', { params });
      return {
        tasks: response.data?.data || [],
        total: response.data?.data?.length || 0, // 这可能不准确，取决于后端如何返回 total
        success: response.data?.code === 200
      };
    } catch (error) {
      console.error('获取个人任务列表失败:', error);
      return { tasks: [], total: 0, success: false };
    }
  },

  // 创建个人任务
  createPersonalTask: async (task: Omit<PersonalTask, 'id' | 'createdAt'>) => {
    // 注意：此函数仍在使用全局 axios。
    const response = await axios.post('/personal-tasks', task);
    return response.data;
  },

  // 更新个人任务
  updatePersonalTask: async (id: number, updates: Partial<PersonalTask>) => {
    // 注意：此函数仍在使用全局 axios。
    const response = await axios.patch(`/personal-tasks/${id}`, updates);
    return response.data;
  },

  // 删除个人任务
  deletePersonalTask: async (id: number) => {
    // 注意：此函数仍在使用全局 axios。
    const response = await axios.delete(`/personal-tasks/${id}`);
    return response.data;
  },
  // 检查DDL并生成提醒（系统调用）
  checkDeadlinesAndGenerateReminders: async () => {
    try {
      // 注意：此函数仍在使用全局 axios。
      const response = await axios.post('/api/notifications/check-deadlines');
      return {
        success: response.data?.code === 200,
        message: response.data?.message || '提醒生成成功'
      };
    } catch (error) {
      console.error('检查DDL并生成提醒失败:', error);
      return { success: false, message: '检查DDL并生成提醒失败' };
    }
  },

  // 获取通知设置
  getNotificationSettings: async () => {
    // 注意：此函数仍在使用全局 axios。
    const response = await axios.get('/notifications/settings');
    return response.data;
  },

  // 更新通知设置
  updateNotificationSettings: async (settings: any) => {
    // 注意：此函数仍在使用全局 axios。
    const response = await axios.patch('/notifications/settings', settings);
    return response.data;
  }
};

// 辅助函数: 根据通知类型设置优先级
function getPriorityByType(type: string): 'low' | 'medium' | 'high' | 'urgent' {
  switch(type) {
    case NotificationType.DDL_REMINDER:
    case NotificationType.HOMEWORK:
    case NotificationType.ASSIGNMENT: // 作业分配设为高优先级
      return 'high';
    case NotificationType.TASK_REMINDER:
      return 'urgent';
    case NotificationType.DISCUSSION_REPLY: // 讨论回复设为中优先级
    case NotificationType.PRACTICE_NOTICE:
    case NotificationType.PRACTICE:
      return 'medium';
    case NotificationType.COURSE_NOTICE:
    case NotificationType.TASK:
    case NotificationType.SYSTEM: // 系统通知设为低优先级
    default:
      return 'low';
  }
}

export default notificationApi;
